
/*
* sp_dec.c
*
*
* Project:
*    AMR Floating-Point Codec
*
* Contains:
*    This module contains all the functions needed decoding AMR
*    encoder parameters to 16-bit speech samples
*
*/
/*
* include files
*/
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>
#include <float.h>
#include "typedef.h"
#include "dec.h"
#include "cuda_runtime.h"
#define PRMNO_MR475 17
#define PRMNO_MR515 19
#define PRMNO_MR59  19
#define PRMNO_MR67  19
#define PRMNO_MR74  19
#define PRMNO_MR795 23
#define PRMNO_MR102 39
#define PRMNO_MR122 57
#define PRMNO_MRDTX 5

/*
* tables
*/
__device__ static const UWord8 block_size[16] = { 13, 14, 16, 18, 20, 21, 27, 32,
6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 };

__device__ static const UWord8 toc_byte[16] = { 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C };
/* Subjective importance of the speech encoded bits */
__device__ static Word16 order_MR475[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	7, 0x8,
	7, 0x4,
	10, 0x8,
	10, 0x4,
	14, 0x8,
	14, 0x4,
	6, 0x1,
	6, 0x2,
	6, 0x4,
	6, 0x8,
	13, 0x1,
	13, 0x2,
	13, 0x4,
	13, 0x8,
	2, 0x20,
	2, 0x10,
	2, 0x4,
	2, 0x1,
	13, 0x10,
	13, 0x20,
	13, 0x40,
	13, 0x80,
	3, 0x2,
	3, 0x1,
	6, 0x10,
	6, 0x20,
	6, 0x40,
	6, 0x80,
	5, 0x2,
	5, 0x1,
	2, 0x40,
	2, 0x8,
	2, 0x2,
	7, 0x2,
	7, 0x1,
	9, 0x2,
	9, 0x1,
	10, 0x2,
	10, 0x1,
	12, 0x2,
	12, 0x1,
	14, 0x2,
	14, 0x1,
	16, 0x2,
	16, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x4,
	4, 0x2,
	8, 0x20,
	8, 0x10,
	8, 0x4,
	8, 0x2,
	11, 0x20,
	11, 0x10,
	11, 0x4,
	11, 0x2,
	15, 0x20,
	15, 0x10,
	15, 0x4,
	15, 0x2,
	4, 0x8,
	8, 0x8,
	11, 0x8,
	15, 0x8,
	4, 0x1,
	8, 0x1,
	11, 0x1,
	15, 0x1,
	4, 0x40,
	8, 0x40,
	11, 0x40,
	15, 0x40
};
__device__ static Word16 order_MR515[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	0, 0x80,
	1, 0x1,
	1, 0x2,
	1, 0x4,
	1, 0x8,
	1, 0x10,
	1, 0x20,
	1, 0x40,
	1, 0x80,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	7, 0x8,
	11, 0x8,
	15, 0x8,
	6, 0x1,
	6, 0x2,
	6, 0x4,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	14, 0x1,
	14, 0x2,
	14, 0x4,
	18, 0x1,
	18, 0x2,
	18, 0x4,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	3, 0x4,
	7, 0x4,
	11, 0x4,
	15, 0x4,
	2, 0x10,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	3, 0x2,
	7, 0x2,
	11, 0x2,
	2, 0x20,
	2, 0x4,
	2, 0x1,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	2, 0x2,
	3, 0x1,
	7, 0x1,
	11, 0x1,
	15, 0x2,
	2, 0x8,
	2, 0x40,
	15, 0x1,
	5, 0x1,
	5, 0x2,
	9, 0x1,
	9, 0x2,
	13, 0x1,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	13, 0x2,
	17, 0x1,
	17, 0x2,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x20,
	8, 0x20,
	4, 0x10,
	8, 0x10,
	12, 0x20,
	12, 0x10,
	16, 0x20,
	16, 0x10,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8
};
__device__ static Word16 order_MR59[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x8,
	0, 0x4,
	0, 0x10,
	0, 0x2,
	0, 0x1,
	0, 0x20,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x40,
	11, 0x40,
	3, 0x80,
	11, 0x80,
	3, 0x8,
	11, 0x8,
	7, 0x8,
	15, 0x8,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	3, 0x4,
	11, 0x4,
	7, 0x4,
	15, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	7, 0x2,
	15, 0x2,
	3, 0x2,
	11, 0x2,
	3, 0x1,
	11, 0x1,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	17, 0x1,
	5, 0x2,
	13, 0x2,
	17, 0x2,
	9, 0x2,
	9, 0x1,
	5, 0x1,
	13, 0x1,
	2, 0x1,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	7, 0x1,
	15, 0x1,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x10,
	8, 0x10,
	12, 0x10,
	16, 0x10,
	4, 0x20,
	8, 0x20,
	12, 0x20,
	16, 0x20
};
__device__ static Word16 order_MR67[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x8,
	0, 0x10,
	0, 0x4,
	0, 0x2,
	1, 0x8,
	0, 0x1,
	0, 0x20,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x2,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x40,
	11, 0x40,
	3, 0x80,
	11, 0x80,
	3, 0x8,
	11, 0x8,
	1, 0x1,
	7, 0x8,
	15, 0x8,
	7, 0x4,
	15, 0x4,
	3, 0x4,
	11, 0x4,
	7, 0x2,
	15, 0x2,
	6, 0x40,
	10, 0x40,
	14, 0x40,
	18, 0x40,
	3, 0x2,
	11, 0x2,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	7, 0x1,
	15, 0x1,
	3, 0x1,
	11, 0x1,
	2, 0x40,
	2, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	2, 0x10,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	5, 0x1,
	9, 0x1,
	13, 0x1,
	17, 0x1,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	5, 0x2,
	9, 0x2,
	13, 0x2,
	17, 0x2,
	18, 0x20,
	14, 0x20,
	10, 0x20,
	6, 0x20,
	5, 0x4,
	9, 0x4,
	13, 0x4,
	17, 0x4,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	4, 0x20,
	8, 0x20,
	12, 0x20,
	16, 0x20,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x200,
	8, 0x200,
	12, 0x200,
	16, 0x200,
	4, 0x400,
	8, 0x400,
	12, 0x400,
	16, 0x400,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8,
	4, 0x10,
	8, 0x10,
	12, 0x10,
	16, 0x10,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100
};
__device__ static Word16 order_MR74[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x100,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	3, 0x80,
	11, 0x80,
	3, 0x40,
	11, 0x40,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x8,
	11, 0x8,
	6, 0x40,
	10, 0x40,
	14, 0x40,
	18, 0x40,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	7, 0x10,
	15, 0x10,
	7, 0x8,
	15, 0x8,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	3, 0x4,
	7, 0x4,
	11, 0x4,
	15, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	5, 0x1,
	9, 0x1,
	13, 0x1,
	17, 0x1,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	5, 0x2,
	9, 0x2,
	13, 0x2,
	17, 0x2,
	5, 0x4,
	9, 0x4,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	13, 0x4,
	17, 0x4,
	5, 0x8,
	9, 0x8,
	13, 0x8,
	17, 0x8,
	3, 0x2,
	3, 0x1,
	7, 0x2,
	7, 0x1,
	11, 0x2,
	11, 0x1,
	15, 0x2,
	15, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	4, 0x2,
	4, 0x1,
	8, 0x20,
	8, 0x10,
	8, 0x8,
	8, 0x4,
	8, 0x2,
	8, 0x1,
	12, 0x20,
	12, 0x10,
	12, 0x8,
	12, 0x4,
	12, 0x2,
	12, 0x1,
	16, 0x20,
	16, 0x10,
	16, 0x8,
	16, 0x4,
	16, 0x2,
	16, 0x1,
	4, 0x1000,
	8, 0x1000,
	12, 0x1000,
	16, 0x1000,
	4, 0x800,
	8, 0x800,
	12, 0x800,
	16, 0x800,
	4, 0x400,
	8, 0x400,
	12, 0x400,
	16, 0x400,
	4, 0x200,
	8, 0x200,
	12, 0x200,
	16, 0x200,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40
};
__device__ static Word16 order_MR795[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	7, 0x10,
	12, 0x10,
	17, 0x10,
	22, 0x10,
	7, 0x8,
	12, 0x8,
	17, 0x8,
	22, 0x8,
	7, 0x4,
	12, 0x4,
	17, 0x4,
	22, 0x4,
	6, 0x8,
	11, 0x8,
	16, 0x8,
	21, 0x8,
	6, 0x4,
	11, 0x4,
	16, 0x4,
	21, 0x4,
	3, 0x80,
	13, 0x80,
	3, 0x40,
	13, 0x40,
	3, 0x20,
	13, 0x20,
	3, 0x10,
	13, 0x10,
	3, 0x8,
	13, 0x8,
	8, 0x20,
	18, 0x20,
	8, 0x10,
	18, 0x10,
	8, 0x8,
	18, 0x8,
	7, 0x2,
	12, 0x2,
	17, 0x2,
	22, 0x2,
	3, 0x4,
	13, 0x4,
	8, 0x4,
	18, 0x4,
	0, 0x80,
	0, 0x100,
	2, 0x2,
	2, 0x1,
	3, 0x2,
	13, 0x2,
	3, 0x1,
	13, 0x1,
	8, 0x2,
	18, 0x2,
	8, 0x1,
	18, 0x1,
	6, 0x2,
	11, 0x2,
	16, 0x2,
	21, 0x2,
	7, 0x1,
	12, 0x1,
	17, 0x1,
	22, 0x1,
	6, 0x1,
	11, 0x1,
	16, 0x1,
	21, 0x1,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	4, 0x2,
	9, 0x2,
	14, 0x2,
	19, 0x2,
	4, 0x10,
	9, 0x10,
	14, 0x10,
	19, 0x10,
	4, 0x80,
	9, 0x80,
	14, 0x80,
	19, 0x80,
	4, 0x800,
	9, 0x800,
	14, 0x800,
	19, 0x800,
	15, 0x8,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	20, 0x8,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	10, 0x8,
	5, 0x1,
	5, 0x2,
	5, 0x4,
	5, 0x8,
	4, 0x1,
	4, 0x4,
	4, 0x8,
	4, 0x20,
	4, 0x100,
	4, 0x1000,
	9, 0x1,
	9, 0x4,
	9, 0x8,
	9, 0x20,
	9, 0x100,
	9, 0x1000,
	14, 0x1,
	14, 0x4,
	14, 0x8,
	14, 0x20,
	14, 0x100,
	14, 0x1000,
	19, 0x1,
	19, 0x4,
	19, 0x8,
	19, 0x20,
	19, 0x100,
	19, 0x1000,
	4, 0x40,
	9, 0x40,
	14, 0x40,
	19, 0x40,
	4, 0x400,
	9, 0x400,
	14, 0x400,
	19, 0x400,
	4, 0x200,
	9, 0x200,
	14, 0x200,
	19, 0x200,
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	7, 0x10,
	12, 0x10,
	17, 0x10,
	22, 0x10,
	7, 0x8,
	12, 0x8,
	17, 0x8,
	22, 0x8,
	7, 0x4,
	12, 0x4,
	17, 0x4,
	22, 0x4,
	6, 0x8,
	11, 0x8,
	16, 0x8,
	21, 0x8,
	6, 0x4,
	11, 0x4,
	16, 0x4,
	21, 0x4,
	3, 0x80,
	13, 0x80,
	3, 0x40,
	13, 0x40,
	3, 0x20,
	13, 0x20,
	3, 0x10,
	13, 0x10,
	3, 0x8,
	13, 0x8,
	8, 0x20,
	18, 0x20,
	8, 0x10,
	18, 0x10,
	8, 0x8,
	18, 0x8,
	7, 0x2,
	12, 0x2,
	17, 0x2,
	22, 0x2,
	3, 0x4,
	13, 0x4,
	8, 0x4,
	18, 0x4,
	0, 0x80,
	0, 0x100,
	2, 0x2,
	2, 0x1,
	3, 0x2,
	13, 0x2,
	3, 0x1,
	13, 0x1,
	8, 0x2,
	18, 0x2,
	8, 0x1,
	18, 0x1,
	6, 0x2,
	11, 0x2,
	16, 0x2,
	21, 0x2,
	7, 0x1,
	12, 0x1,
	17, 0x1,
	22, 0x1,
	6, 0x1,
	11, 0x1,
	16, 0x1,
	21, 0x1,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	4, 0x2,
	9, 0x2,
	14, 0x2,
	19, 0x2,
	4, 0x10,
	9, 0x10,
	14, 0x10,
	19, 0x10,
	4, 0x80,
	9, 0x80,
	14, 0x80,
	19, 0x80,
	4, 0x800,
	9, 0x800,
	14, 0x800,
	19, 0x800,
	15, 0x8,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	20, 0x8,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	10, 0x8,
	5, 0x1,
	5, 0x2,
	5, 0x4,
	5, 0x8,
	4, 0x1,
	4, 0x4,
	4, 0x8,
	4, 0x20,
	4, 0x100,
	4, 0x1000,
	9, 0x1,
	9, 0x4,
	9, 0x8,
	9, 0x20,
	9, 0x100,
	9, 0x1000,
	14, 0x1,
	14, 0x4,
	14, 0x8,
	14, 0x20,
	14, 0x100,
	14, 0x1000,
	19, 0x1,
	19, 0x4,
	19, 0x8,
	19, 0x20,
	19, 0x100,
	19, 0x1000,
	4, 0x40,
	9, 0x40,
	14, 0x40,
	19, 0x40,
	4, 0x400,
	9, 0x400,
	14, 0x400,
	19, 0x400,
	4, 0x200,
	9, 0x200,
	14, 0x200,
	19, 0x200
};
__device__ static Word16 order_MR102[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	0, 0x80,
	1, 0x1,
	1, 0x2,
	1, 0x4,
	1, 0x8,
	1, 0x10,
	1, 0x20,
	1, 0x40,
	1, 0x80,
	1, 0x100,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	21, 0x80,
	21, 0x40,
	21, 0x20,
	21, 0x10,
	21, 0x8,
	21, 0x4,
	12, 0x10,
	12, 0x8,
	30, 0x10,
	30, 0x8,
	11, 0x40,
	11, 0x8,
	11, 0x4,
	20, 0x40,
	20, 0x8,
	20, 0x4,
	29, 0x40,
	29, 0x8,
	29, 0x4,
	38, 0x40,
	38, 0x8,
	38, 0x4,
	3, 0x2,
	3, 0x1,
	21, 0x2,
	21, 0x1,
	12, 0x4,
	12, 0x2,
	30, 0x4,
	30, 0x2,
	11, 0x20,
	20, 0x20,
	29, 0x20,
	38, 0x20,
	2, 0x40,
	2, 0x4,
	2, 0x10,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	7, 0x1,
	6, 0x1,
	5, 0x1,
	4, 0x1,
	16, 0x1,
	15, 0x1,
	14, 0x1,
	13, 0x1,
	25, 0x1,
	24, 0x1,
	23, 0x1,
	22, 0x1,
	34, 0x1,
	33, 0x1,
	32, 0x1,
	31, 0x1,
	11, 0x2,
	11, 0x10,
	11, 0x1,
	20, 0x2,
	20, 0x10,
	20, 0x1,
	29, 0x2,
	29, 0x10,
	29, 0x1,
	38, 0x2,
	38, 0x10,
	38, 0x1,
	12, 0x1,
	30, 0x1,
	17, 0x200,
	17, 0x100,
	18, 0x100,
	18, 0x200,
	18, 0x80,
	17, 0x80,
	18, 0x20,
	17, 0x20,
	17, 0x40,
	18, 0x40,
	19, 0x40,
	19, 0x20,
	18, 0x10,
	19, 0x8,
	17, 0x10,
	19, 0x10,
	17, 0x8,
	18, 0x8,
	26, 0x200,
	26, 0x100,
	27, 0x100,
	27, 0x200,
	27, 0x80,
	26, 0x80,
	27, 0x20,
	26, 0x20,
	26, 0x40,
	27, 0x40,
	28, 0x40,
	28, 0x20,
	27, 0x10,
	28, 0x8,
	26, 0x10,
	28, 0x10,
	26, 0x8,
	27, 0x8,
	35, 0x200,
	35, 0x100,
	36, 0x100,
	36, 0x200,
	36, 0x80,
	35, 0x80,
	36, 0x20,
	35, 0x20,
	35, 0x40,
	36, 0x40,
	37, 0x40,
	37, 0x20,
	36, 0x10,
	37, 0x8,
	35, 0x10,
	37, 0x10,
	35, 0x8,
	36, 0x8,
	8, 0x200,
	8, 0x100,
	9, 0x100,
	9, 0x200,
	9, 0x80,
	8, 0x80,
	9, 0x20,
	8, 0x20,
	8, 0x40,
	9, 0x40,
	10, 0x40,
	10, 0x20,
	9, 0x10,
	10, 0x8,
	8, 0x10,
	10, 0x10,
	8, 0x8,
	9, 0x8,
	37, 0x4,
	35, 0x1,
	36, 0x1,
	37, 0x1,
	35, 0x4,
	37, 0x2,
	35, 0x2,
	36, 0x4,
	36, 0x2,
	28, 0x4,
	26, 0x1,
	27, 0x1,
	28, 0x1,
	26, 0x4,
	28, 0x2,
	26, 0x2,
	27, 0x4,
	27, 0x2,
	19, 0x4,
	17, 0x1,
	18, 0x1,
	19, 0x1,
	17, 0x4,
	19, 0x2,
	17, 0x2,
	18, 0x4,
	18, 0x2,
	10, 0x4,
	8, 0x1,
	9, 0x1,
	10, 0x1,
	8, 0x4,
	10, 0x2,
	8, 0x2,
	9, 0x4,
	9, 0x2
};
__device__ static Word16 order_MR122[] =
{
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	2, 0x1,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	2, 0x20,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x2,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	5, 0x100,
	31, 0x100,
	5, 0x80,
	31, 0x80,
	5, 0x40,
	31, 0x40,
	5, 0x20,
	31, 0x20,
	5, 0x10,
	31, 0x10,
	5, 0x8,
	31, 0x8,
	5, 0x4,
	31, 0x4,
	5, 0x2,
	31, 0x2,
	5, 0x1,
	31, 0x1,
	6, 0x8,
	19, 0x8,
	32, 0x8,
	45, 0x8,
	6, 0x4,
	19, 0x4,
	32, 0x4,
	45, 0x4,
	6, 0x2,
	19, 0x2,
	32, 0x2,
	45, 0x2,
	17, 0x10,
	30, 0x10,
	43, 0x10,
	56, 0x10,
	17, 0x8,
	30, 0x8,
	43, 0x8,
	56, 0x8,
	17, 0x4,
	30, 0x4,
	43, 0x4,
	56, 0x4,
	18, 0x20,
	44, 0x20,
	18, 0x10,
	44, 0x10,
	18, 0x8,
	44, 0x8,
	18, 0x4,
	44, 0x4,
	18, 0x2,
	44, 0x2,
	3, 0x4,
	3, 0x2,
	3, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	6, 0x1,
	19, 0x1,
	32, 0x1,
	45, 0x1,
	17, 0x2,
	30, 0x2,
	43, 0x2,
	56, 0x2,
	7, 0x8,
	20, 0x8,
	33, 0x8,
	46, 0x8,
	8, 0x8,
	21, 0x8,
	34, 0x8,
	47, 0x8,
	17, 0x1,
	30, 0x1,
	43, 0x1,
	56, 0x1,
	9, 0x8,
	22, 0x8,
	35, 0x8,
	48, 0x8,
	10, 0x8,
	23, 0x8,
	36, 0x8,
	49, 0x8,
	11, 0x8,
	24, 0x8,
	37, 0x8,
	50, 0x8,
	4, 0x2,
	4, 0x1,
	7, 0x1,
	7, 0x2,
	7, 0x4,
	8, 0x1,
	8, 0x2,
	8, 0x4,
	9, 0x1,
	9, 0x2,
	9, 0x4,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	11, 0x1,
	11, 0x2,
	11, 0x4,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	21, 0x1,
	21, 0x2,
	21, 0x4,
	22, 0x1,
	22, 0x2,
	22, 0x4,
	23, 0x1,
	23, 0x2,
	23, 0x4,
	24, 0x1,
	24, 0x2,
	24, 0x4,
	33, 0x1,
	33, 0x2,
	33, 0x4,
	34, 0x1,
	34, 0x2,
	34, 0x4,
	35, 0x1,
	35, 0x2,
	35, 0x4,
	36, 0x1,
	36, 0x2,
	36, 0x4,
	37, 0x1,
	37, 0x2,
	37, 0x4,
	46, 0x1,
	46, 0x2,
	46, 0x4,
	47, 0x1,
	47, 0x2,
	47, 0x4,
	48, 0x1,
	48, 0x2,
	48, 0x4,
	49, 0x1,
	49, 0x2,
	49, 0x4,
	50, 0x1,
	50, 0x2,
	50, 0x4,
	12, 0x1,
	12, 0x2,
	12, 0x4,
	13, 0x1,
	13, 0x2,
	13, 0x4,
	14, 0x1,
	14, 0x2,
	14, 0x4,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	16, 0x1,
	16, 0x2,
	16, 0x4,
	25, 0x1,
	25, 0x2,
	25, 0x4,
	26, 0x1,
	26, 0x2,
	26, 0x4,
	27, 0x1,
	27, 0x2,
	27, 0x4,
	28, 0x1,
	28, 0x2,
	28, 0x4,
	29, 0x1,
	29, 0x2,
	29, 0x4,
	38, 0x1,
	38, 0x2,
	38, 0x4,
	39, 0x1,
	39, 0x2,
	39, 0x4,
	40, 0x1,
	40, 0x2,
	40, 0x4,
	41, 0x1,
	41, 0x2,
	41, 0x4,
	42, 0x1,
	42, 0x2,
	42, 0x4,
	51, 0x1,
	51, 0x2,
	51, 0x4,
	52, 0x1,
	52, 0x2,
	52, 0x4,
	53, 0x1,
	53, 0x2,
	53, 0x4,
	54, 0x1,
	54, 0x2,
	54, 0x4,
	55, 0x1,
	55, 0x2,
	55, 0x4,
	18, 0x1,
	44, 0x1
};
__device__ static Word16 order_MRDTX[] =
{
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	2, 0x20,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x2,
	2, 0x1,
	3, 0x100,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	3, 0x2,
	3, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	4, 0x2,
	4, 0x1
};

/* Homing frames for the decoder */
__device__ static const Word16 dhf_MR475[PRMNO_MR475] =
{
	0x00F8,
	0x009D,
	0x001C,
	0x0066,
	0x0000,
	0x0003,
	0x0028,
	0x000F,
	0x0038,
	0x0001,
	0x000F,
	0x0031,
	0x0002,
	0x0008,
	0x000F,
	0x0026,
	0x0003
};
__device__ static const Word16 dhf_MR515[PRMNO_MR515] =
{
	0x00F8,
	0x009D,
	0x001C,
	0x0066,
	0x0000,
	0x0003,
	0x0037,
	0x000F,
	0x0000,
	0x0003,
	0x0005,
	0x000F,
	0x0037,
	0x0003,
	0x0037,
	0x000F,
	0x0023,
	0x0003,
	0x001F
};
__device__ static const Word16 dhf_MR59[PRMNO_MR59] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0000,
	0x0003,
	0x0037,
	0x000F,
	0x0001,
	0x0003,
	0x000F,
	0x0060,
	0x00F9,
	0x0003,
	0x0037,
	0x000F,
	0x0000,
	0x0003,
	0x0037
};
__device__ static const Word16 dhf_MR67[PRMNO_MR67] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0002,
	0x0007,
	0x0000,
	0x000F,
	0x0098,
	0x0007,
	0x0061,
	0x0060,
	0x05C5,
	0x0007,
	0x0000,
	0x000F,
	0x0318,
	0x0007,
	0x0000
};
__device__ static const Word16 dhf_MR74[PRMNO_MR74] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0006,
	0x000F,
	0x0000,
	0x001B,
	0x0208,
	0x000F,
	0x0062,
	0x0060,
	0x1BA6,
	0x000F,
	0x0000,
	0x001B,
	0x0006,
	0x000F,
	0x0000
};
__device__ static const Word16 dhf_MR795[PRMNO_MR795] =
{
	0x00C2,
	0x00E3,
	0x002F,
	0x00BD,
	0x0006,
	0x000F,
	0x000A,
	0x0000,
	0x0039,
	0x1C08,
	0x0007,
	0x000A,
	0x000B,
	0x0063,
	0x11A6,
	0x000F,
	0x0001,
	0x0000,
	0x0039,
	0x09A0,
	0x000F,
	0x0002,
	0x0001
};
__device__ static const Word16 dhf_MR102[PRMNO_MR102] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x0045,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x001B,
	0x0000,
	0x0001,
	0x0000,
	0x0001,
	0x0326,
	0x00CE,
	0x007E,
	0x0051,
	0x0062,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x015A,
	0x0359,
	0x0076,
	0x0000,
	0x001B,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x017C,
	0x0215,
	0x0038,
	0x0030
};
__device__ static const Word16 dhf_MR122[PRMNO_MR122] =
{
	0x0004,
	0x002A,
	0x00DB,
	0x0096,
	0x002A,
	0x0156,
	0x000B,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0036,
	0x000B,
	0x0000,
	0x000F,
	0x000E,
	0x000C,
	0x000D,
	0x0000,
	0x0001,
	0x0005,
	0x0007,
	0x0001,
	0x0008,
	0x0024,
	0x0000,
	0x0001,
	0x0000,
	0x0005,
	0x0006,
	0x0001,
	0x0002,
	0x0004,
	0x0007,
	0x0004,
	0x0002,
	0x0003,
	0x0036,
	0x000B,
	0x0000,
	0x0002,
	0x0004,
	0x0000,
	0x0003,
	0x0006,
	0x0001,
	0x0007,
	0x0006,
	0x0005,
	0x0000
};


/* parameter sizes (# of bits), one table per mode */
__device__ static const Word16 bitno_MR475[PRMNO_MR475] =
{
	8, 8, 7,    /* LSP VQ          */
	8, 7, 2, 8, /* first subframe  */
	4, 7, 2,    /* second subframe */
	4, 7, 2, 8, /* third subframe  */
	4, 7, 2     /* fourth subframe */
};
__device__ static const Word16 bitno_MR515[PRMNO_MR515] =
{
	8, 8, 7,    /* LSP VQ          */
	8, 7, 2, 6, /* first subframe  */
	4, 7, 2, 6, /* second subframe */
	4, 7, 2, 6, /* third subframe  */
	4, 7, 2, 6  /* fourth subframe */
};
__device__ static const Word16 bitno_MR59[PRMNO_MR59] =
{
	8, 9, 9,    /* LSP VQ          */
	8, 9, 2, 6, /* first subframe  */
	4, 9, 2, 6, /* second subframe */
	8, 9, 2, 6, /* third subframe  */
	4, 9, 2, 6  /* fourth subframe */
};
__device__ static const Word16 bitno_MR67[PRMNO_MR67] =
{
	8, 9, 9,       /* LSP VQ          */
	8, 11, 3, 7,   /* first subframe  */
	4, 11, 3, 7,   /* second subframe */
	8, 11, 3, 7,   /* third subframe  */
	4, 11, 3, 7    /* fourth subframe */
};
__device__ static const Word16 bitno_MR74[PRMNO_MR74] =
{
	8, 9, 9,       /* LSP VQ          */
	8, 13, 4, 7,   /* first subframe  */
	5, 13, 4, 7,   /* second subframe */
	8, 13, 4, 7,   /* third subframe  */
	5, 13, 4, 7    /* fourth subframe */
};
__device__ static const Word16 bitno_MR795[PRMNO_MR795] =
{
	9, 9, 9,          /* LSP VQ          */
	8, 13, 4, 4, 5,   /* first subframe  */
	6, 13, 4, 4, 5,   /* second subframe */
	8, 13, 4, 4, 5,   /* third subframe  */
	6, 13, 4, 4, 5    /* fourth subframe */
};
__device__ static const Word16 bitno_MR102[PRMNO_MR102] =
{
	8, 9, 9,                      /* LSP VQ          */
	8, 1, 1, 1, 1, 10, 10, 7, 7,  /* first subframe  */
	5, 1, 1, 1, 1, 10, 10, 7, 7,  /* second subframe */
	8, 1, 1, 1, 1, 10, 10, 7, 7,  /* third subframe  */
	5, 1, 1, 1, 1, 10, 10, 7, 7   /* fourth subframe */
};
__device__ static const Word16 bitno_MR122[PRMNO_MR122] =
{
	7, 8, 9, 8, 6,                            /* LSP VQ          */
	9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* first subframe  */
	6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* second subframe */
	9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* third subframe  */
	6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5     /* fourth subframe */
};
__device__ static const Word16 bitno_MRDTX[PRMNO_MRDTX] =
{
	3, 8, 9, 9, 6
};
#define PRMNO_MR475 17
#define PRMNO_MR515 19
#define PRMNO_MR59  19
#define PRMNO_MR67  19
#define PRMNO_MR74  19
#define PRMNO_MR795 23
#define PRMNO_MR102 39
#define PRMNO_MR122 57
#define PRMNO_MRDTX 5

/*
* tables
*/

/* level adjustment for different modes Q11 */
__device__ static const Word16 dtx_log_en_adjust[9] =
{
	-1023,
	/* MR475 */ -878,
	/* MR515 */ -732,
	/* MR59  */ -586,
	/* MR67  */ -440,
	/* MR74  */ -294,
	/* MR795 */ -148,
	/* MR102 */ 0,
	/* MR122 */ 0,
	/* MRDTX */
};

/* attenuation factors for codebook gain */
__device__ static const Word32 cdown[7] =
{
	32767,
	32112,
	32112,
	32112,
	32112,
	32112,
	22937
};

/* attenuation factors for adaptive codebook gain */
__device__ static const Word32 pdown[7] =
{
	32767,
	32112,
	32112,
	26214,
	9830,
	6553,
	6553
};

/* algebraic code book gain MA predictor coefficients */
__device__ static const Word32 pred[NPRED] =
{
	5571,
	4751,
	2785,
	1556
};

/* algebraic code book gain MA predictor coefficients (MR122) */
__device__ static const Word32 pred_MR122[NPRED] =
{
	44,
	37,
	22,
	12
};

__device__ static const Word32 gamma4_gamma3_MR122[M] =
{
	22938,
	16057,
	11240,
	7868,
	5508,
	3856,
	2699,
	1889,
	1322,
	925
};
__device__ static const Word32 gamma3[M] =
{
	18022,
	9912,
	5451,
	2998,
	1649,
	907,
	499,
	274,
	151,
	83
};
__device__ static const Word32 gamma4_MR122[M] =
{
	24576,
	18432,
	13824,
	10368,
	7776,
	5832,
	4374,
	3281,
	2461,
	1846
};


/* adaptive codebook gain quantization table (MR122, MR795) */
#define NB_QUA_PITCH 16
__device__ static const Word32 qua_gain_pitch[NB_QUA_PITCH] =
{
	0,
	3277,
	6556,
	8192,
	9830,
	11469,
	12288,
	13107,
	13926,
	14746,
	15565,
	16384,
	17203,
	18022,
	18842,
	19661
};

/* fixed codebook gain quantization table (MR122, MR795) */
#define NB_QUA_CODE 32
__device__ static const Word32 qua_gain_code[NB_QUA_CODE * 3] =
{
	/* gain factor (g_fac) and quantized energy error (qua_ener_MR122, qua_ener)
	* are stored:
	*
	* qua_ener_MR122 = log2(g_fac)      (not the rounded floating point value, but
	*                                    the value the original EFR algorithm
	*                                    calculates from g_fac [using Log2])
	* qua_ener       = 20*log10(g_fac); (rounded floating point value)
	*
	*
	* g_fac (Q11),
	* qua_ener_MR122 (Q10),
	* qua_ener (Q10)
	*/ 159,
	-3776,
	-22731,
	206,
	-3394,
	-20428,
	268,
	-3005,
	-18088,
	349,
	-2615,
	-15739,
	419,
	-2345,
	-14113,
	482,
	-2138,
	-12867,
	554,
	-1932,
	-11629,
	637,
	-1726,
	-10387,
	733,
	-1518,
	-9139,
	842,
	-1314,
	-7906,
	969,
	-1106,
	-6656,
	1114,
	-900,
	-5416,
	1281,
	-694,
	-4173,
	1473,
	-487,
	-2931,
	1694,
	-281,
	-1688,
	1948,
	-75,
	-445,
	2241,
	133,
	801,
	2577,
	339,
	2044,
	2963,
	545,
	3285,
	3408,
	752,
	4530,
	3919,
	958,
	5772,
	4507,
	1165,
	7016,
	5183,
	1371,
	8259,
	5960,
	1577,
	9501,
	6855,
	1784,
	10745,
	7883,
	1991,
	11988,
	9065,
	2197,
	13231,
	10425,
	2404,
	14474,
	12510,
	2673,
	16096,
	16263,
	3060,
	18429,
	21142,
	3448,
	20763,
	27485,
	3836,
	23097
};

/* gray coding table */
__device__ static const Word8 gray[8] =
{
	0,
	1,
	3,
	2,
	6,
	4,
	5,
	7
};

/* gray decoding table */
__device__ static const Word32 dgray[8] =
{
	0,
	1,
	3,
	2,
	5,
	6,
	4,
	7
};

/* table[i] = sqrt((i+16)*2^-6) * 2^15, i.e. sqrt(x) scaled Q15 */
__device__ static const Word32 sqrt_table[49] =
{
	16384,
	16888,
	17378,
	17854,
	18318,
	18770,
	19212,
	19644,
	20066,
	20480,
	20886,
	21283,
	21674,
	22058,
	22435,
	22806,
	23170,
	23530,
	23884,
	24232,
	24576,
	24915,
	25249,
	25580,
	25905,
	26227,
	26545,
	26859,
	27170,
	27477,
	27780,
	28081,
	28378,
	28672,
	28963,
	29251,
	29537,
	29819,
	30099,
	30377,
	30652,
	30924,
	31194,
	31462,
	31727,
	31991,
	32252,
	32511,
	32767
};

__device__ static const Word32 inv_sqrt_table[49] =
{
	32767,
	31790,
	30894,
	30070,
	29309,
	28602,
	27945,
	27330,
	26755,
	26214,
	25705,
	25225,
	24770,
	24339,
	23930,
	23541,
	23170,
	22817,
	22479,
	22155,
	21845,
	21548,
	21263,
	20988,
	20724,
	20470,
	20225,
	19988,
	19760,
	19539,
	19326,
	19119,
	18919,
	18725,
	18536,
	18354,
	18176,
	18004,
	17837,
	17674,
	17515,
	17361,
	17211,
	17064,
	16921,
	16782,
	16646,
	16514,
	16384
};
/* table used inbase 2 logharithm computation */
__device__ static const Word32 log2_table[33] =
{
	0,
	1455,
	2866,
	4236,
	5568,
	6863,
	8124,
	9352,
	10549,
	11716,
	12855,
	13967,
	15054,
	16117,
	17156,
	18172,
	19167,
	20142,
	21097,
	22033,
	22951,
	23852,
	24735,
	25603,
	26455,
	27291,
	28113,
	28922,
	29716,
	30497,
	31266,
	32023,
	32767
};

/* table used in 2 to the power computation */
__device__ static const Word32 pow2_table[33] =
{
	16384,
	16743,
	17109,
	17484,
	17867,
	18258,
	18658,
	19066,
	19484,
	19911,
	20347,
	20792,
	21247,
	21713,
	22188,
	22674,
	23170,
	23678,
	24196,
	24726,
	25268,
	25821,
	26386,
	26964,
	27554,
	28158,
	28774,
	29405,
	30048,
	30706,
	31379,
	32066,
	32767
};

/* table of cos(x) */
__device__ static const Word32 cos_table[65] =
{
	32767,
	32729,
	32610,
	32413,
	32138,
	31786,
	31357,
	30853,
	30274,
	29622,
	28899,
	28106,
	27246,
	26320,
	25330,
	24279,
	23170,
	22006,
	20788,
	19520,
	18205,
	16846,
	15447,
	14010,
	12540,
	11039,
	9512,
	7962,
	6393,
	4808,
	3212,
	1608,
	0,
	-1608,
	-3212,
	-4808,
	-6393,
	-7962,
	-9512,
	-11039,
	-12540,
	-14010,
	-15447,
	-16846,
	-18205,
	-19520,
	-20788,
	-22006,
	-23170,
	-24279,
	-25330,
	-26320,
	-27246,
	-28106,
	-28899,
	-29622,
	-30274,
	-30853,
	-31357,
	-31786,
	-32138,
	-32413,
	-32610,
	-32729,
	-32768
};

/* slope used to compute y = acos(x) */
__device__ static const Word32 acos_slope[64] =
{
	-26887,
	-8812,
	-5323,
	-3813,
	-2979,
	-2444,
	-2081,
	-1811,
	-1608,
	-1450,
	-1322,
	-1219,
	-1132,
	-1059,
	-998,
	-946,
	-901,
	-861,
	-827,
	-797,
	-772,
	-750,
	-730,
	-713,
	-699,
	-687,
	-677,
	-668,
	-662,
	-657,
	-654,
	-652,
	-652,
	-654,
	-657,
	-662,
	-668,
	-677,
	-687,
	-699,
	-713,
	-730,
	-750,
	-772,
	-797,
	-827,
	-861,
	-901,
	-946,
	-998,
	-1059,
	-1132,
	-1219,
	-1322,
	-1450,
	-1608,
	-1811,
	-2081,
	-2444,
	-2979,
	-3813,
	-5323,
	-8812,
	-26887
};

/* All impulse responses are in Q15 */
/* phase dispersion impulse response (MR795) */
__device__ static const Word32 ph_imp_low_MR795[] =
{
	26777,
	801,
	2505,
	-683,
	-1382,
	582,
	604,
	-1274,
	3511,
	-5894,
	4534,
	-499,
	-1940,
	3011,
	-5058,
	5614,
	-1990,
	-1061,
	-1459,
	4442,
	-700,
	-5335,
	4609,
	452,
	-589,
	-3352,
	2953,
	1267,
	-1212,
	-2590,
	1731,
	3670,
	-4475,
	-975,
	4391,
	-2537,
	949,
	-1363,
	-979,
	5734
};
/* phase dispersion impulse response (MR795) */
__device__ static const Word32 ph_imp_mid_MR795[] =
{
	30274,
	3831,
	-4036,
	2972,
	-1048,
	-1002,
	2477,
	-3043,
	2815,
	-2231,
	1753,
	-1611,
	1714,
	-1775,
	1543,
	-1008,
	429,
	-169,
	472,
	-1264,
	2176,
	-2706,
	2523,
	-1621,
	344,
	826,
	-1529,
	1724,
	-1657,
	1701,
	-2063,
	2644,
	-3060,
	2897,
	-1978,
	557,
	780,
	-1369,
	842,
	655
};

/* phase dispersion impulse response (MR475 - MR67) */
__device__ static const Word32 ph_imp_low[] =
{
	14690,
	11518,
	1268,
	-2761,
	-5671,
	7514,
	-35,
	-2807,
	-3040,
	4823,
	2952,
	-8424,
	3785,
	1455,
	2179,
	-8637,
	8051,
	-2103,
	-1454,
	777,
	1108,
	-2385,
	2254,
	-363,
	-674,
	-2103,
	6046,
	-5681,
	1072,
	3123,
	-5058,
	5312,
	-2329,
	-3728,
	6924,
	-3889,
	675,
	-1775,
	29,
	10145
};

/* phase dispersion impulse response (MR475 - MR67) */
__device__ static const Word32 ph_imp_mid[] =
{
	30274,
	3831,
	-4036,
	2972,
	-1048,
	-1002,
	2477,
	-3043,
	2815,
	-2231,
	1753,
	-1611,
	1714,
	-1775,
	1543,
	-1008,
	429,
	-169,
	472,
	-1264,
	2176,
	-2706,
	2523,
	-1621,
	344,
	826,
	-1529,
	1724,
	-1657,
	1701,
	-2063,
	2644,
	-3060,
	2897,
	-1978,
	557,
	780,
	-1369,
	842,
	655
};

/* initialization table for the MA predictor in DTX */
#define PAST_RQ_INIT_SIZE 8

/* initalization table for MA predictor in dtx mode */
__device__ static const Word32 past_rq_init[80] =
{
	-258,
	-318,
	-439,
	-634,
	-656,
	-773,
	-711,
	-502,
	-268,
	-193,
	-2,
	125,
	122,
	-39,
	-9,
	105,
	129,
	283,
	372,
	575,
	-277,
	-324,
	-197,
	-487,
	-445,
	-362,
	-292,
	-27,
	177,
	543,
	342,
	517,
	516,
	130,
	27,
	-104,
	-120,
	-140,
	-74,
	-56,
	-564,
	-943,
	-1520,
	-965,
	-814,
	-526,
	-322,
	-2,
	159,
	657,
	-312,
	-284,
	-386,
	-597,
	-493,
	-526,
	-418,
	-229,
	105,
	449,
	-557,
	-870,
	-1075,
	-919,
	-950,
	-752,
	-709,
	-316,
	62,
	486,
	-314,
	-191,
	-203,
	-330,
	-160,
	-103,
	-51,
	131,
	338,
	515
};

#define ALPHA     29491
#define ONE_ALPHA 3277
/* LSF means (not in MR122) */
__device__ static const Word32 mean_lsf_3[10] =
{
	1546,
	2272,
	3778,
	5488,
	6972,
	8382,
	10047,
	11229,
	12766,
	13714
};

#define ALPHA_122     31128
#define ONE_ALPHA_122 1639
/* LSF means ->normalize frequency domain */
__device__ static const Word32 mean_lsf_5[10] =
{
	1384,
	2077,
	3420,
	5108,
	6742,
	8122,
	9863,
	11092,
	12714,
	13701
};

/* LSF prediction factors (not in MR122) */
__device__ static const Word32 pred_fac[10] =
{
	9556,
	10769,
	12571,
	13292,
	14381,
	11651,
	10588,
	9767,
	8593,
	6484
};
#define DICO1_SIZE_3  256
#define DICO2_SIZE_3  512
#define DICO3_SIZE_3  512

/* 1st LSF quantizer (not in MR122 and MR795) */
__device__ static const Word32 dico1_lsf_3[] =
{
	6,
	82,
	-131,
	154,
	-56,
	-735,
	183,
	-65,
	-265,
	9,
	-210,
	-361,
	113,
	718,
	1817,
	1010,
	1214,
	1573,
	857,
	1333,
	2276,
	827,
	1568,
	1933,
	717,
	1989,
	2206,
	838,
	1172,
	1823,
	721,
	1000,
	2154,
	286,
	476,
	1509,
	-247,
	-531,
	230,
	147,
	-82,
	569,
	26,
	-177,
	-944,
	-27,
	-273,
	692,
	-164,
	-264,
	-183,
	224,
	790,
	1039,
	899,
	946,
	601,
	485,
	771,
	1150,
	524,
	677,
	903,
	-140,
	375,
	778,
	410,
	676,
	429,
	301,
	530,
	1009,
	719,
	646,
	38,
	226,
	367,
	40,
	145,
	-45,
	-505,
	290,
	121,
	-121,
	302,
	127,
	166,
	-124,
	-383,
	-956,
	-358,
	-455,
	-977,
	715,
	878,
	894,
	978,
	923,
	211,
	477,
	272,
	64,
	188,
	-78,
	17,
	-143,
	-65,
	38,
	643,
	586,
	621,
	-134,
	-426,
	-651,
	347,
	545,
	2820,
	1188,
	2726,
	2442,
	142,
	-80,
	1735,
	283,
	130,
	461,
	-262,
	-399,
	-1145,
	-411,
	155,
	430,
	329,
	375,
	779,
	53,
	-226,
	-139,
	-129,
	-236,
	1682,
	285,
	744,
	1327,
	738,
	697,
	1664,
	312,
	409,
	266,
	325,
	720,
	135,
	1,
	221,
	453,
	8,
	203,
	145,
	299,
	640,
	760,
	29,
	468,
	638,
	103,
	429,
	379,
	420,
	954,
	932,
	1326,
	1210,
	1258,
	704,
	1012,
	1152,
	-166,
	-444,
	-266,
	-316,
	-130,
	-376,
	191,
	1151,
	1904,
	-240,
	-543,
	-1260,
	-112,
	268,
	1207,
	70,
	1062,
	1583,
	278,
	1360,
	1574,
	-258,
	-272,
	-768,
	19,
	563,
	2240,
	-3,
	-265,
	135,
	-295,
	-591,
	-388,
	140,
	354,
	-206,
	-260,
	-504,
	-795,
	-433,
	-718,
	-1319,
	109,
	331,
	962,
	-429,
	-87,
	652,
	-296,
	426,
	1019,
	-239,
	775,
	851,
	489,
	1334,
	1073,
	-334,
	-332,
	25,
	543,
	1206,
	1807,
	326,
	61,
	727,
	578,
	849,
	1405,
	-208,
	-277,
	329,
	-152,
	64,
	669,
	-434,
	-678,
	-727,
	-454,
	-71,
	251,
	605,
	480,
	254,
	-482,
	11,
	996,
	-289,
	395,
	486,
	722,
	1049,
	1440,
	-30,
	-316,
	-786,
	-106,
	-115,
	-619,
	861,
	1474,
	1412,
	1055,
	1366,
	1184,
	812,
	1237,
	925,
	42,
	-251,
	-576,
	342,
	141,
	-454,
	-168,
	-80,
	1359,
	-342,
	-656,
	-1763,
	100,
	821,
	725,
	990,
	747,
	800,
	332,
	440,
	568,
	663,
	379,
	852,
	112,
	165,
	-369,
	597,
	910,
	282,
	-8,
	834,
	1281,
	-352,
	572,
	695,
	462,
	2246,
	1806,
	345,
	190,
	1374,
	416,
	915,
	2166,
	168,
	-82,
	280,
	-516,
	-446,
	840,
	47,
	533,
	44,
	-362,
	-711,
	-1143,
	22,
	193,
	1472,
	-85,
	233,
	1813,
	-62,
	579,
	1504,
	550,
	944,
	1749,
	723,
	650,
	1148,
	972,
	884,
	1395,
	-425,
	643,
	0,
	1000,
	952,
	1098,
	249,
	1446,
	672,
	-334,
	-87,
	2172,
	-554,
	1882,
	2672,
	140,
	1826,
	1853,
	920,
	1749,
	2590,
	1076,
	1933,
	2038,
	-137,
	-443,
	-1555,
	1269,
	1174,
	468,
	-493,
	-122,
	1521,
	-451,
	1033,
	1214,
	482,
	1695,
	1118,
	815,
	649,
	384,
	-446,
	-692,
	107,
	-319,
	-605,
	-118,
	-207,
	-505,
	525,
	-468,
	-12,
	2736,
	75,
	1934,
	1305,
	880,
	2358,
	2267,
	1285,
	1575,
	2004,
	-48,
	-304,
	-1186,
	-435,
	-461,
	-251,
	-366,
	-404,
	-547,
	-289,
	-605,
	-597,
	-538,
	-810,
	-165,
	-120,
	3,
	356,
	639,
	1241,
	1502,
	96,
	177,
	750,
	-435,
	-585,
	-1174,
	-356,
	109,
	-79,
	-485,
	288,
	2005,
	9,
	1116,
	731,
	880,
	2134,
	946,
	-265,
	1585,
	1065,
	1157,
	1210,
	843,
	-498,
	-668,
	431,
	374,
	321,
	-229,
	1440,
	2101,
	1381,
	449,
	461,
	1155,
	-105,
	39,
	-384,
	-263,
	367,
	182,
	-371,
	-660,
	773,
	-188,
	1151,
	971,
	1333,
	1632,
	1435,
	774,
	1267,
	1221,
	-482,
	-832,
	-1489,
	-237,
	-210,
	860,
	890,
	1615,
	1064,
	472,
	1062,
	1192,
	185,
	1077,
	989,
	-568,
	-992,
	-1704,
	-449,
	-902,
	-2043,
	-142,
	-377,
	-458,
	-210,
	-554,
	-1029,
	-11,
	1133,
	2265,
	-329,
	-675,
	-893,
	-250,
	657,
	1187,
	519,
	1510,
	1779,
	520,
	539,
	1403,
	527,
	1421,
	1302,
	-563,
	-871,
	-1248,
	-147,
	-463,
	879,
	-76,
	2334,
	2840,
	563,
	2573,
	2385,
	632,
	1926,
	2920,
	719,
	2023,
	1840,
	-545,
	-723,
	1108,
	129,
	-125,
	884,
	1417,
	1632,
	925,
	-94,
	1566,
	1751,
	-341,
	1533,
	1551,
	591,
	395,
	-274,
	-76,
	981,
	2831,
	153,
	2985,
	1844,
	1032,
	2565,
	2749,
	1508,
	2832,
	1879,
	791,
	1199,
	538,
	-190,
	-453,
	1489,
	-278,
	-548,
	1158,
	-245,
	1941,
	2044,
	1024,
	1560,
	1650,
	512,
	253,
	466,
	-62,
	-323,
	1151,
	-473,
	-376,
	507,
	-433,
	1380,
	2162,
	899,
	1943,
	1445,
	134,
	704,
	440,
	460,
	525,
	-28,
	-450,
	279,
	1338,
	0,
	971,
	252,
	-445,
	-627,
	-991,
	-348,
	-602,
	-1424,
	398,
	712,
	1656,
	-107,
	314,
	-178,
	93,
	2226,
	2238,
	518,
	849,
	656,
	-462,
	-711,
	-447,
	174,
	-34,
	1191,
	-119,
	42,
	1005,
	-372,
	274,
	758,
	1036,
	2352,
	1838,
	675,
	1724,
	1498,
	430,
	1286,
	2133,
	-129,
	-439,
	0,
	-373,
	800,
	2144,
	6,
	1587,
	2478,
	478,
	596,
	2128,
	-428,
	-736,
	1505,
	385,
	178,
	980,
	139,
	449,
	1225,
	-526,
	-842,
	-982,
	145,
	1554,
	1242,
	623,
	1448,
	656,
	349,
	1016,
	1482,
	31,
	-280,
	415,
	-316,
	724,
	1641,
	360,
	1058,
	556,
	-436,
	-358,
	1201,
	-355,
	1123,
	1939,
	401,
	1584,
	2248,
	-527,
	-1012,
	355,
	233,
	238,
	2233,
	-550,
	-897,
	-639,
	-365,
	-501,
	1957,
	389,
	1860,
	1621,
	162,
	1132,
	1264,
	-237,
	1174,
	1390,
	-640,
	-411,
	116,
	-228,
	1694,
	2298,
	1639,
	2186,
	2267,
	562,
	1273,
	2658,
	323,
	338,
	1774,
	578,
	1107,
	852,
	22,
	594,
	934,
	-143,
	718,
	446
};

/* 2nd LSF quantizer (not in MR122) */
__device__ static const Word32 dico2_lsf_3[] =
{
	50,
	71,
	-9,
	-338,
	-698,
	-1407,
	102,
	-138,
	-820,
	-310,
	-469,
	-1147,
	414,
	67,
	-267,
	1060,
	814,
	1441,
	1548,
	1360,
	1272,
	1754,
	1895,
	1661,
	2019,
	2133,
	1820,
	1808,
	2318,
	1845,
	644,
	-93,
	454,
	858,
	329,
	-136,
	489,
	-258,
	-128,
	-198,
	-745,
	-41,
	-52,
	-265,
	-985,
	346,
	137,
	479,
	-1741,
	-748,
	-684,
	-1163,
	-1725,
	-367,
	-895,
	-1145,
	-784,
	-488,
	-946,
	-968,
	-85,
	-390,
	-725,
	215,
	-340,
	-171,
	1020,
	916,
	1969,
	564,
	179,
	746,
	662,
	977,
	1734,
	887,
	622,
	914,
	939,
	856,
	1165,
	309,
	688,
	803,
	917,
	161,
	570,
	118,
	-20,
	-283,
	-816,
	-42,
	204,
	-1228,
	-325,
	-462,
	-963,
	-202,
	-143,
	-988,
	-484,
	-361,
	-702,
	-978,
	-477,
	-302,
	-790,
	-1188,
	-100,
	-786,
	-1088,
	-1054,
	-947,
	-1684,
	-202,
	-843,
	-782,
	-1039,
	-1378,
	-901,
	-624,
	-110,
	-85,
	356,
	213,
	-10,
	-493,
	364,
	774,
	425,
	822,
	479,
	-83,
	557,
	520,
	-992,
	-1560,
	-572,
	-603,
	-741,
	-26,
	-502,
	-638,
	-903,
	209,
	306,
	147,
	-316,
	-593,
	-596,
	-85,
	-211,
	-225,
	-918,
	-529,
	117,
	233,
	-439,
	-738,
	1101,
	751,
	633,
	1457,
	1716,
	1511,
	1765,
	1457,
	910,
	1122,
	1156,
	849,
	1354,
	868,
	470,
	-871,
	-1150,
	-1796,
	-871,
	-861,
	-992,
	-118,
	155,
	212,
	-1051,
	-849,
	-606,
	-1117,
	-1849,
	-2750,
	-1019,
	-1427,
	-1869,
	370,
	-184,
	-414,
	959,
	493,
	104,
	958,
	1039,
	543,
	154,
	653,
	201,
	1249,
	507,
	150,
	663,
	503,
	230,
	623,
	777,
	675,
	659,
	88,
	-110,
	843,
	244,
	224,
	382,
	541,
	302,
	724,
	433,
	666,
	1166,
	734,
	341,
	-138,
	20,
	-397,
	-1183,
	-424,
	-46,
	-321,
	-352,
	-124,
	1333,
	1021,
	1080,
	262,
	366,
	723,
	922,
	283,
	-551,
	31,
	-636,
	-611,
	-689,
	-697,
	-415,
	-952,
	-779,
	-201,
	-1329,
	-598,
	-359,
	-953,
	-1285,
	166,
	493,
	305,
	221,
	846,
	703,
	610,
	840,
	936,
	774,
	-723,
	-1324,
	-1261,
	-357,
	-1025,
	-1388,
	-1096,
	-1376,
	-365,
	-1416,
	-1881,
	-608,
	-1798,
	-1727,
	-674,
	-545,
	-1173,
	-703,
	678,
	786,
	148,
	-123,
	696,
	1288,
	644,
	350,
	-10,
	414,
	614,
	15,
	137,
	344,
	-211,
	-814,
	-1512,
	-819,
	-391,
	-930,
	-588,
	47,
	-591,
	-898,
	-909,
	-1097,
	-163,
	-1272,
	-1167,
	-157,
	-1464,
	-1525,
	-389,
	-1274,
	-1188,
	-624,
	671,
	213,
	454,
	124,
	-274,
	-525,
	-729,
	-496,
	-152,
	-1344,
	122,
	135,
	-2905,
	-589,
	-394,
	-1728,
	441,
	-50,
	1476,
	904,
	787,
	316,
	236,
	-440,
	-347,
	217,
	413,
	-911,
	-917,
	121,
	-455,
	-932,
	202,
	-92,
	-465,
	-375,
	488,
	390,
	474,
	876,
	729,
	316,
	-1815,
	-1312,
	-669,
	87,
	962,
	432,
	563,
	-249,
	-1058,
	250,
	285,
	1105,
	1141,
	427,
	696,
	-1038,
	-1664,
	-1582,
	-948,
	346,
	160,
	-309,
	-272,
	-858,
	670,
	624,
	1250,
	-944,
	-408,
	-666,
	-606,
	-320,
	-384,
	-492,
	230,
	65,
	334,
	-50,
	-16,
	-16,
	-690,
	-1397,
	1791,
	1716,
	1399,
	2478,
	2063,
	1404,
	1245,
	1471,
	1426,
	-382,
	-1037,
	-2,
	173,
	-398,
	1145,
	1491,
	2024,
	1801,
	772,
	1274,
	1506,
	1429,
	1735,
	2001,
	1079,
	1218,
	1273,
	-1154,
	-1851,
	-1329,
	-808,
	-1133,
	-1096,
	-451,
	-1033,
	-1722,
	65,
	578,
	-84,
	-1476,
	-2434,
	-1778,
	-765,
	-1366,
	-494,
	-218,
	-594,
	-931,
	337,
	-236,
	562,
	2357,
	2662,
	1938,
	1489,
	1276,
	874,
	189,
	358,
	374,
	-1519,
	-2281,
	-2346,
	-967,
	-1271,
	-2095,
	-628,
	-1188,
	-1542,
	1661,
	1043,
	546,
	565,
	1061,
	732,
	-64,
	-836,
	-434,
	-436,
	-96,
	203,
	1078,
	1216,
	1636,
	907,
	1534,
	986,
	326,
	965,
	845,
	142,
	-84,
	197,
	470,
	2379,
	1570,
	1133,
	470,
	1214,
	395,
	1376,
	1200,
	1125,
	1042,
	348,
	-543,
	-1234,
	-376,
	-215,
	-181,
	481,
	-1947,
	-1621,
	-210,
	-750,
	-1185,
	390,
	29,
	-399,
	27,
	820,
	1236,
	755,
	695,
	979,
	409,
	-174,
	1197,
	1035,
	912,
	1356,
	1846,
	-992,
	-1437,
	484,
	-1485,
	-1700,
	208,
	-412,
	1204,
	1432,
	-271,
	896,
	1144,
	-416,
	1777,
	1434,
	-1696,
	-2644,
	-204,
	-1789,
	-1551,
	1033,
	-1656,
	-1559,
	1303,
	-1253,
	-1589,
	1081,
	-669,
	-1095,
	-66,
	-682,
	320,
	-345,
	659,
	305,
	1069,
	-1292,
	-804,
	-19,
	-1635,
	-1291,
	29,
	-1683,
	-497,
	71,
	-287,
	-7,
	-100,
	-494,
	-962,
	-237,
	852,
	1881,
	1740,
	-1217,
	-1387,
	227,
	-660,
	302,
	373,
	96,
	1087,
	1257,
	-1074,
	-1669,
	160,
	485,
	2076,
	1798,
	-934,
	-220,
	552,
	-596,
	-612,
	237,
	336,
	1720,
	879,
	643,
	629,
	434,
	1267,
	522,
	1633,
	15,
	244,
	-441,
	1475,
	717,
	184,
	1819,
	1590,
	1709,
	988,
	261,
	937,
	2093,
	2345,
	1520,
	2139,
	1858,
	1606,
	-577,
	-579,
	-1203,
	-956,
	135,
	-488,
	-464,
	51,
	-338,
	-629,
	-348,
	-723,
	1146,
	2073,
	1442,
	2192,
	1466,
	911,
	-1444,
	-1572,
	-2278,
	1400,
	710,
	1297,
	1335,
	633,
	928,
	1434,
	2194,
	2594,
	2422,
	2204,
	1881,
	982,
	2242,
	1854,
	380,
	792,
	1145,
	-63,
	-539,
	414,
	-252,
	-964,
	-314,
	-1261,
	-683,
	-780,
	-831,
	-526,
	-1005,
	-1666,
	-1135,
	-424,
	-1611,
	-452,
	-299,
	1268,
	1048,
	642,
	1147,
	853,
	856,
	-675,
	-336,
	139,
	2268,
	1343,
	1418,
	29,
	768,
	797,
	-1224,
	423,
	564,
	-1318,
	-1082,
	245,
	-1302,
	-812,
	573,
	-1298,
	-1617,
	646,
	-968,
	834,
	723,
	993,
	1652,
	2027,
	-191,
	-817,
	432,
	662,
	60,
	198,
	626,
	997,
	1330,
	1648,
	1963,
	1289,
	-1597,
	-93,
	-45,
	-1088,
	37,
	-84,
	1653,
	2607,
	2337,
	1065,
	2040,
	2377,
	1139,
	2326,
	2118,
	859,
	357,
	1510,
	664,
	1227,
	1099,
	479,
	1360,
	912,
	1897,
	1754,
	2019,
	1168,
	1909,
	1784,
	399,
	34,
	256,
	-593,
	-304,
	-1053,
	547,
	1694,
	1407,
	647,
	-99,
	-341,
	1492,
	1647,
	1190,
	38,
	-644,
	-212,
	395,
	846,
	222,
	-704,
	-765,
	-716,
	-724,
	-1964,
	-2804,
	-150,
	291,
	-82,
	1233,
	1459,
	1007,
	-140,
	-155,
	153,
	439,
	297,
	1568,
	-1529,
	-410,
	-636,
	1536,
	455,
	-237,
	-1328,
	-139,
	-260,
	531,
	554,
	868,
	269,
	1264,
	606,
	-233,
	883,
	463,
	742,
	600,
	-120,
	-73,
	421,
	212,
	-439,
	-58,
	804,
	-1286,
	-1241,
	728,
	294,
	-490,
	50,
	-591,
	-905,
	-1254,
	42,
	-687,
	147,
	-25,
	273,
	596,
	-311,
	1213,
	601,
	-754,
	849,
	584,
	429,
	607,
	587,
	-602,
	-166,
	461,
	-796,
	-823,
	777,
	1380,
	910,
	1755,
	119,
	1417,
	972,
	-219,
	-880,
	-1596,
	-1049,
	-1010,
	438,
	-713,
	-1379,
	78,
	0,
	-447,
	-1179,
	-1136,
	-1319,
	-1573,
	2248,
	1767,
	1309,
	946,
	1583,
	1432,
	1150,
	482,
	436,
	-469,
	-1108,
	618,
	-447,
	-966,
	1088,
	-1252,
	-1515,
	-114,
	-1104,
	-2008,
	-579,
	210,
	613,
	497,
	-1975,
	-1437,
	642,
	-1269,
	-856,
	1011,
	-1646,
	-1185,
	1063,
	-1555,
	-672,
	1204,
	-1692,
	-1114,
	623,
	-979,
	-1326,
	-1277,
	539,
	-147,
	894,
	-1354,
	-897,
	-434,
	888,
	475,
	428,
	153,
	-384,
	338,
	-1492,
	-511,
	359,
	-974,
	-1115,
	-470,
	105,
	-550,
	677,
	-937,
	-1145,
	877,
	380,
	-260,
	210,
	1685,
	924,
	1256,
	1775,
	1190,
	1095,
	1419,
	631,
	533,
	627,
	299,
	-347,
	-411,
	-534,
	647,
	-650,
	29,
	-595,
	-378,
	-1367,
	1563,
	1402,
	1121,
	1465,
	1089,
	1410,
	648,
	-2096,
	-1090,
	-6,
	311,
	-194,
	-869,
	-639,
	-831,
	416,
	-1162,
	-1224,
	1349,
	-1247,
	-941,
	1813,
	-2193,
	-1987,
	453,
	-619,
	-1367,
	-956,
	-1606,
	-1972,
	-1507,
	-1175,
	-1057,
	-1104,
	-377,
	601,
	201,
	1876,
	825,
	374,
	-430,
	-1323,
	29,
	-1397,
	-1249,
	-1331,
	-1007,
	-1504,
	960,
	-1401,
	-2009,
	197,
	-1379,
	-1949,
	-236,
	-1077,
	123,
	422,
	615,
	1269,
	546,
	-306,
	1526,
	904,
	1194,
	1788,
	1177,
	-626,
	-884,
	-1526,
	199,
	766,
	1504,
	-1065,
	862,
	197,
	-1034,
	-1773,
	-887,
	-800,
	145,
	599,
	-1134,
	-519,
	626,
	-1205,
	-1926,
	500,
	-910,
	-1041,
	-1395,
	-1476,
	-1567,
	-969,
	-523,
	842,
	34,
	1794,
	646,
	862,
	-1207,
	-1888,
	-1002,
	-78,
	-9,
	-672,
	1044,
	759,
	80,
	-600,
	1139,
	1019,
	57,
	2000,
	1422,
	-833,
	1414,
	1121,
	-1202,
	1630,
	1260,
	-461,
	1420,
	1244,
	1537,
	975,
	253,
	-283,
	324,
	-359,
	599,
	-195,
	106,
	588,
	62,
	-587,
	-757,
	645,
	205,
	51,
	1201,
	758,
	-1209,
	673,
	-390,
	-624,
	1581,
	941,
	-151,
	1023,
	735,
	2820,
	1301,
	690,
	-302,
	524,
	-99,
	-900,
	-1588,
	-1189,
	1084,
	251,
	238,
	2014,
	1792,
	1010,
	1245,
	1633,
	1741,
	-1227,
	-1540,
	-1208,
	-621,
	456,
	-109,
	40,
	-65,
	788,
	-805,
	-699,
	-1350,
	-583,
	904,
	832,
	-801,
	532,
	594,
	1972,
	1408,
	1351,
	-1177,
	-1880,
	-2114,
	-773,
	568,
	948,
	-1015,
	1079,
	1260,
	-1111,
	482,
	-130,
	1778,
	1044,
	780,
	-1491,
	245,
	912,
	-316,
	-1141,
	-917,
	-536,
	-1442,
	-2346,
	-785,
	-1546,
	-1988,
	-2003,
	257,
	909,
	-1849,
	-633,
	-1209,
	-1538,
	-1918,
	-1054,
	1606,
	2239,
	1576,
	-567,
	-1500,
	-1544,
	-1279,
	195,
	1369,
	-817,
	293,
	1219,
	-525,
	630,
	1197,
	-1698,
	-2425,
	-1840,
	-303,
	731,
	747,
	-1169,
	-251,
	269,
	-950,
	-75,
	1684,
	-1182,
	-453,
	1005,
	-1599,
	585,
	378,
	-2075,
	-571,
	-427,
	-529,
	-1159,
	-1171,
	-283,
	-205,
	-564,
	-796,
	1246,
	717,
	2277,
	927,
	539,
	-454,
	559,
	440,
	-717,
	1460,
	1615,
	-1030,
	1052,
	1610,
	-1169,
	-138,
	847,
	226,
	39,
	-612,
	-1251,
	-106,
	-729,
	-651,
	968,
	1302,
	-714,
	-636,
	1727,
	353,
	1069,
	410,
	-798,
	-156,
	1099,
	-574,
	918,
	446,
	-1310,
	1012,
	466,
	1408,
	1591,
	765,
	1429,
	1380,
	1757,
	1949,
	1956,
	2378,
	1578,
	2047,
	2148,
	916,
	98,
	-7,
	1893,
	1418,
	2141,
	348,
	1405,
	1579,
	152,
	1134,
	1801,
	-267,
	154,
	1395,
	-1166,
	469,
	1054,
	-1142,
	-405,
	-1073,
	-1341,
	-2264,
	-1581,
	-364,
	869,
	1706,
	-1162,
	549,
	1550,
	-1225,
	-1932,
	-1666,
	-1485,
	-1977,
	-2055,
	-1727,
	-906,
	-98,
	-1897,
	233,
	1492,
	892,
	108,
	-331,
	-1728,
	-1170,
	-1700,
	-1060,
	1980,
	1790,
	-1070,
	-1741,
	-1909,
	-11,
	1539,
	1317,
	-1600,
	94,
	497,
	421,
	443,
	-197,
	-1578,
	-349,
	-994,
	-599,
	-539,
	1140,
	-965,
	-1419,
	-129,
	-1341,
	175,
	-447,
	-375,
	1311,
	2055,
	-371,
	-650,
	-307,
	-1073,
	605,
	365,
	-2057,
	-113,
	430,
	652,
	914,
	967,
	-1012,
	-1586,
	-2323,
	1505,
	1248,
	559,
	262,
	-486,
	-401,
	-1727,
	1342,
	1546,
	50,
	56,
	432,
	-330,
	119,
	-604,
	-1517,
	-1080,
	-810,
	946,
	1127,
	1055,
	-1400,
	-1703,
	-1712,
	-1270,
	-704,
	-1317,
	807,
	1821,
	1143,
	2760,
	1606,
	2171,
	1120,
	409,
	-150,
	-147,
	404,
	959,
	2439,
	1911,
	2189,
	-906,
	-141,
	-866,
	-904,
	-142,
	-458,
	-557,
	-708,
	-1679,
	-830,
	-1431,
	-1583,
	-1842,
	-1346,
	-1086,
	-1604,
	-272,
	915,
	-1196,
	772,
	1056,
	-638,
	-1234,
	-1897,
	-500,
	-81,
	-822,
	-1289,
	-1613,
	-735,
	-117,
	785,
	168,
	-1090,
	1133,
	922,
	-1096,
	-746,
	1384,
	287,
	-547,
	-1063,
	-1376,
	-2201,
	-1204,
	-2176,
	-1570,
	-1757,
	-1511,
	-2241,
	-771,
	-1737,
	1099,
	830,
	-1588,
	724,
	1243,
	-1542,
	693,
	805,
	-1690,
	-240,
	1665,
	-1700,
	-4,
	-668,
	2149,
	816,
	1042,
	-818,
	-1841,
	22,
	-764,
	-507,
	449,
	-1151,
	-617,
	289,
	-843,
	-1596,
	-240,
	498,
	-234,
	-657,
	-752,
	480,
	1678,
	-319,
	-481,
	193,
	-811,
	171,
	-119,
	-2128,
	-202,
	-848,
	1717,
	1140,
	1700
};

/* 3rd LSF quantizer (not in MR122, MR515 and MR475) */
__device__ static const Word32 dico3_lsf_3[] =
{
	67,
	-17,
	66,
	-12,
	-1690,
	-581,
	-104,
	-272,
	-1076,
	-1186,
	-1845,
	-376,
	-1140,
	-926,
	-420,
	-58,
	-259,
	-656,
	-1134,
	-553,
	1788,
	1227,
	455,
	129,
	462,
	441,
	-240,
	-528,
	840,
	514,
	130,
	-75,
	1114,
	623,
	153,
	216,
	1068,
	564,
	-6,
	-276,
	1119,
	727,
	190,
	-68,
	704,
	306,
	119,
	-264,
	329,
	61,
	-100,
	156,
	364,
	123,
	183,
	-208,
	-171,
	-123,
	220,
	-65,
	-306,
	-62,
	402,
	17,
	-660,
	-938,
	-266,
	0,
	385,
	235,
	276,
	285,
	320,
	268,
	-336,
	-200,
	-724,
	17,
	-84,
	381,
	-544,
	429,
	494,
	519,
	-117,
	288,
	304,
	329,
	643,
	157,
	701,
	508,
	1200,
	625,
	796,
	608,
	998,
	421,
	492,
	632,
	1204,
	780,
	446,
	132,
	1257,
	844,
	547,
	449,
	829,
	658,
	541,
	470,
	1132,
	1258,
	918,
	639,
	547,
	51,
	423,
	279,
	9,
	392,
	83,
	94,
	542,
	543,
	229,
	-147,
	-198,
	129,
	194,
	-185,
	-863,
	-1321,
	-302,
	30,
	-597,
	-629,
	-19,
	114,
	-900,
	-1081,
	466,
	353,
	-1483,
	-1573,
	15,
	-143,
	-1708,
	-2059,
	-751,
	196,
	-1876,
	-2067,
	-642,
	-258,
	-2335,
	-1470,
	-450,
	-564,
	-584,
	-186,
	-872,
	-414,
	-1805,
	-988,
	-1125,
	-1310,
	-726,
	-1129,
	28,
	169,
	-1039,
	-864,
	-718,
	-246,
	484,
	36,
	-233,
	-49,
	265,
	67,
	289,
	467,
	178,
	543,
	810,
	540,
	84,
	282,
	672,
	703,
	-975,
	-777,
	129,
	287,
	-938,
	-227,
	955,
	595,
	-1617,
	-289,
	836,
	649,
	-1847,
	-215,
	1106,
	718,
	-2034,
	-1085,
	650,
	440,
	-2101,
	-529,
	907,
	575,
	-2011,
	-336,
	670,
	204,
	-2389,
	-692,
	360,
	137,
	-2156,
	-2204,
	-9,
	280,
	-266,
	119,
	39,
	193,
	78,
	-59,
	-120,
	226,
	-975,
	-858,
	-781,
	-1095,
	-619,
	-413,
	-451,
	-842,
	-1216,
	-1321,
	-813,
	-883,
	-1376,
	-1615,
	-394,
	-428,
	-737,
	-1113,
	-549,
	-790,
	-880,
	-975,
	-967,
	-642,
	-985,
	-886,
	-1273,
	-1361,
	-473,
	-804,
	-1401,
	-1407,
	160,
	-265,
	-919,
	-275,
	-248,
	-250,
	-718,
	-380,
	97,
	-103,
	-375,
	-229,
	-415,
	-193,
	-135,
	-555,
	628,
	361,
	119,
	216,
	579,
	364,
	391,
	209,
	634,
	522,
	-154,
	-148,
	526,
	389,
	170,
	33,
	105,
	267,
	64,
	380,
	-1503,
	-1000,
	-30,
	-369,
	-1070,
	58,
	647,
	223,
	-1520,
	-291,
	621,
	307,
	-1531,
	156,
	762,
	404,
	-2029,
	141,
	734,
	499,
	-1849,
	-650,
	306,
	512,
	-187,
	-104,
	-59,
	438,
	134,
	-230,
	156,
	-186,
	-61,
	-260,
	-16,
	10,
	-569,
	-3,
	-421,
	-297,
	-1725,
	-521,
	-346,
	178,
	-1362,
	-59,
	-44,
	157,
	-2146,
	-461,
	-470,
	-349,
	-2170,
	-1,
	-369,
	-121,
	-1579,
	-373,
	-900,
	-1015,
	-1117,
	-591,
	-613,
	-784,
	-561,
	122,
	-75,
	-449,
	-4,
	-171,
	-123,
	-372,
	192,
	168,
	-76,
	-132,
	252,
	-107,
	340,
	210,
	392,
	509,
	272,
	181,
	-109,
	145,
	218,
	119,
	-416,
	-263,
	485,
	265,
	-181,
	-8,
	-286,
	226,
	-244,
	-218,
	69,
	-290,
	-158,
	191,
	-1,
	-64,
	-592,
	-90,
	213,
	-96,
	255,
	435,
	178,
	-80,
	-369,
	-18,
	-33,
	-80,
	-42,
	415,
	140,
	-222,
	1143,
	651,
	649,
	329,
	767,
	556,
	249,
	235,
	948,
	413,
	442,
	279,
	141,
	339,
	356,
	557,
	-470,
	-170,
	99,
	237,
	-569,
	-800,
	352,
	565,
	282,
	473,
	470,
	332,
	-199,
	-690,
	-1284,
	-917,
	-193,
	-426,
	-800,
	-1122,
	-26,
	-371,
	-490,
	-193,
	637,
	595,
	519,
	330,
	408,
	-115,
	79,
	12,
	477,
	87,
	-103,
	-376,
	-666,
	-347,
	-277,
	-291,
	-510,
	-481,
	169,
	297,
	-829,
	-738,
	-205,
	-171,
	-320,
	-540,
	328,
	283,
	-859,
	-958,
	442,
	-2,
	556,
	686,
	130,
	56,
	1383,
	1012,
	755,
	427,
	612,
	741,
	628,
	553,
	-339,
	-796,
	134,
	277,
	-633,
	-1085,
	-2,
	-246,
	-880,
	-1035,
	-1607,
	-1064,
	-994,
	-474,
	-1138,
	-488,
	-414,
	-795,
	73,
	-206,
	-8,
	-139,
	439,
	204,
	-176,
	-578,
	23,
	131,
	-269,
	-757,
	-191,
	245,
	-109,
	-338,
	112,
	316,
	120,
	-406,
	-118,
	611,
	-180,
	-186,
	-645,
	115,
	-173,
	34,
	-518,
	-489,
	-151,
	61,
	-583,
	-844,
	220,
	-138,
	-681,
	-1020,
	391,
	-17,
	-598,
	-321,
	157,
	-295,
	129,
	155,
	-926,
	-875,
	-987,
	285,
	241,
	-83,
	-125,
	-125,
	620,
	597,
	432,
	92,
	393,
	78,
	409,
	61,
	-393,
	-739,
	-413,
	-748,
	83,
	54,
	361,
	27,
	-1084,
	130,
	-337,
	-694,
	-1565,
	297,
	318,
	-19,
	-1873,
	36,
	51,
	-317,
	-2323,
	-246,
	231,
	-84,
	-2306,
	-783,
	40,
	-179,
	-2233,
	-930,
	-474,
	-462,
	-754,
	-86,
	-288,
	-626,
	-2411,
	-455,
	-63,
	171,
	-1099,
	-1094,
	-26,
	-143,
	-1193,
	-455,
	-406,
	-381,
	-605,
	-210,
	-96,
	-51,
	-580,
	-476,
	-276,
	-15,
	-1195,
	-634,
	-1203,
	-881,
	-378,
	-221,
	-669,
	-952,
	594,
	178,
	-403,
	-676,
	763,
	327,
	601,
	290,
	172,
	300,
	203,
	157,
	-56,
	-336,
	356,
	24,
	-228,
	-296,
	-259,
	-29,
	-186,
	263,
	416,
	14,
	-353,
	373,
	-12,
	-216,
	257,
	96,
	174,
	57,
	-1526,
	-616,
	-954,
	-499,
	-497,
	-152,
	-333,
	125,
	105,
	200,
	179,
	-97,
	-331,
	-224,
	765,
	697,
	760,
	256,
	301,
	59,
	455,
	-85,
	204,
	288,
	-514,
	240,
	251,
	-109,
	256,
	417,
	-34,
	-413,
	101,
	430,
	384,
	156,
	-31,
	-10,
	206,
	426,
	589,
	145,
	143,
	71,
	808,
	906,
	333,
	349,
	986,
	938,
	589,
	331,
	1300,
	824,
	187,
	509,
	1062,
	653,
	379,
	466,
	1462,
	937,
	401,
	274,
	787,
	861,
	265,
	2,
	609,
	553,
	28,
	305,
	926,
	340,
	106,
	386,
	241,
	-267,
	-147,
	225,
	-178,
	-534,
	347,
	502,
	-643,
	-381,
	397,
	30,
	-651,
	-733,
	-435,
	398,
	-407,
	-726,
	-484,
	-248,
	-789,
	-914,
	-438,
	-476,
	-498,
	-390,
	75,
	-295,
	-964,
	-590,
	-606,
	150,
	-121,
	-49,
	-155,
	-78,
	935,
	550,
	389,
	38,
	-321,
	127,
	424,
	315,
	-285,
	-113,
	283,
	259,
	658,
	203,
	322,
	486,
	903,
	505,
	748,
	417,
	611,
	423,
	555,
	512,
	239,
	-83,
	-578,
	-19,
	-339,
	-731,
	349,
	13,
	-934,
	-1399,
	-114,
	-360,
	107,
	692,
	182,
	90,
	-1243,
	-1538,
	-1551,
	-725,
	-568,
	-903,
	-1363,
	-525,
	-517,
	-853,
	-861,
	-1004,
	-168,
	-690,
	-835,
	63,
	-137,
	-556,
	-547,
	144,
	-286,
	-817,
	485,
	319,
	-147,
	-408,
	526,
	246,
	-347,
	-434,
	297,
	-28,
	-290,
	-471,
	-1110,
	-1285,
	-460,
	-359,
	-988,
	-794,
	1347,
	1299,
	690,
	523,
	1216,
	1068,
	1094,
	757,
	825,
	1140,
	752,
	494,
	1252,
	1365,
	1195,
	898,
	521,
	1053,
	532,
	432,
	-334,
	-216,
	-313,
	-263,
	-160,
	52,
	-472,
	-155,
	127,
	136,
	-380,
	44,
	851,
	410,
	-162,
	-489,
	123,
	-255,
	-796,
	-667,
	1090,
	917,
	789,
	493,
	1397,
	1197,
	558,
	202,
	-51,
	-118,
	-342,
	-701,
	83,
	108,
	-42,
	-441,
	61,
	95,
	287,
	256,
	-27,
	89,
	524,
	531,
	351,
	227,
	592,
	545,
	697,
	155,
	-164,
	307,
	638,
	274,
	-489,
	-50,
	754,
	240,
	-166,
	-124,
	-116,
	-579,
	-1212,
	-63,
	190,
	-295,
	-1040,
	-1296,
	147,
	-376,
	-177,
	-113,
	841,
	1241,
	1051,
	668,
	2,
	293,
	551,
	304,
	-1096,
	-953,
	-248,
	376,
	-750,
	-965,
	87,
	516,
	-275,
	-516,
	689,
	391,
	-379,
	-643,
	876,
	594,
	-390,
	-1013,
	-645,
	573,
	-107,
	-568,
	-689,
	-826,
	-1025,
	-27,
	-328,
	-203,
	861,
	749,
	548,
	233,
	-1660,
	-1043,
	451,
	108,
	-660,
	-620,
	430,
	236,
	21,
	-396,
	-1158,
	-631,
	1372,
	1298,
	967,
	577,
	1125,
	1125,
	589,
	454,
	-323,
	-865,
	-467,
	153,
	-468,
	-699,
	-804,
	-509,
	-392,
	-718,
	-204,
	-35,
	-603,
	-1093,
	-567,
	-162,
	-505,
	-1004,
	-102,
	350,
	219,
	224,
	423,
	252,
	395,
	591,
	608,
	363,
	-746,
	-96,
	373,
	172,
	171,
	295,
	714,
	339,
	233,
	77,
	107,
	277,
	157,
	153,
	-499,
	-356,
	1547,
	1073,
	576,
	494,
	-292,
	-339,
	-504,
	-592,
	-903,
	-72,
	-619,
	-481,
	-1594,
	-1117,
	-567,
	-254,
	-793,
	-507,
	-564,
	-291,
	-492,
	-532,
	502,
	560,
	-382,
	427,
	600,
	230,
	-227,
	477,
	251,
	75,
	285,
	842,
	813,
	476,
	-1310,
	-1333,
	186,
	377,
	-587,
	-917,
	643,
	381,
	-1186,
	-553,
	411,
	82,
	-1127,
	-820,
	-174,
	-540,
	-604,
	119,
	543,
	205,
	-380,
	657,
	909,
	567,
	112,
	-298,
	-374,
	114,
	-857,
	-251,
	56,
	159,
	401,
	345,
	-34,
	-140,
	-111,
	-607,
	41,
	614,
	355,
	-114,
	-77,
	474,
	578,
	56,
	1450,
	924,
	1098,
	1420,
	741,
	400,
	246,
	22,
	588,
	313,
	-121,
	327,
	831,
	472,
	-1138,
	-608,
	856,
	552,
	-1241,
	-1072,
	638,
	600,
	-358,
	254,
	-333,
	-303,
	-646,
	739,
	358,
	74,
	1226,
	1671,
	1221,
	849,
	2241,
	1624,
	983,
	636,
	1841,
	1477,
	749,
	384,
	350,
	263,
	87,
	128,
	-1902,
	-941,
	-144,
	-64,
	-1734,
	-255,
	288,
	-31,
	-2644,
	-1238,
	366,
	235,
	-1643,
	-1092,
	-1344,
	-304,
	-541,
	-1075,
	-1116,
	123,
	-1178,
	-252,
	-816,
	-180,
	-1016,
	533,
	565,
	233,
	-487,
	-430,
	-188,
	334,
	867,
	1236,
	534,
	171,
	-1590,
	-1607,
	635,
	630,
	-2196,
	310,
	924,
	412,
	-2358,
	-328,
	956,
	529,
	-2639,
	-377,
	630,
	278,
	-2602,
	317,
	799,
	299,
	-2406,
	133,
	340,
	31,
	-2156,
	-1468,
	131,
	125,
	-1184,
	-490,
	-139,
	46,
	-744,
	447,
	891,
	564,
	67,
	-451,
	646,
	604,
	-553,
	-429,
	-876,
	396,
	162,
	-66,
	1305,
	915,
	479,
	579,
	1088,
	794,
	450,
	278,
	566,
	324,
	-1057,
	-154,
	148,
	-177,
	-2545,
	168,
	1070,
	592,
	-2351,
	-42,
	819,
	345,
	-2344,
	-707,
	721,
	250,
	-2175,
	-1497,
	-309,
	122,
	-78,
	-73,
	120,
	173,
	-4,
	262,
	-263,
	-261,
	-431,
	-64,
	-405,
	-732,
	-2609,
	116,
	-83,
	-193,
	-1525,
	-944,
	-477,
	-725,
	-508,
	307,
	170,
	172,
	832,
	417,
	832,
	686,
	-225,
	177,
	894,
	818,
	-482,
	-389,
	1279,
	1039,
	-383,
	201,
	-350,
	40,
	730,
	635,
	226,
	526,
	503,
	462,
	338,
	398,
	535,
	714,
	40,
	-282,
	1482,
	1471,
	1085,
	731,
	1561,
	1072,
	909,
	693,
	1419,
	1282,
	889,
	879,
	1153,
	728,
	1186,
	840,
	-226,
	1130,
	949,
	689,
	-494,
	-986,
	-1556,
	-128,
	-568,
	-721,
	-713,
	-26,
	317,
	524,
	70,
	135,
	-405,
	-865,
	-1766,
	-652,
	-174,
	-801,
	885,
	773,
	-153,
	-91,
	1099,
	751,
	-506,
	-1149,
	853,
	646,
	241,
	782,
	519,
	539,
	1853,
	1700,
	1101,
	684,
	-1249,
	-1486,
	-464,
	188,
	-893,
	-1409,
	-1312,
	-341,
	-135,
	438,
	-175,
	18,
	1111,
	976,
	319,
	208,
	-1430,
	-1768,
	83,
	458,
	-530,
	-1000,
	307,
	129,
	-840,
	-15,
	-29,
	-356,
	-911,
	-924,
	-1147,
	-242,
	-119,
	-528,
	127,
	-133,
	-761,
	-765,
	190,
	-83,
	-315,
	895,
	522,
	231,
	-222,
	102,
	-63,
	-428,
	316,
	699,
	379,
	70,
	25,
	716,
	314,
	-108,
	507,
	874,
	566,
	238,
	108,
	941,
	519,
	195,
	425,
	-60,
	-427,
	257,
	139,
	-103,
	-630,
	446,
	334,
	370,
	412,
	48,
	-172,
	-690,
	-283,
	557,
	187,
	-286,
	158,
	483,
	140,
	270,
	-344,
	-631,
	924,
	579,
	-116,
	132,
	142,
	466,
	-68,
	-64,
	230,
	-145,
	-302,
	-542,
	-803,
	-912,
	1018,
	737,
	-773,
	1015,
	630,
	297,
	-2596,
	95,
	445,
	336,
	-2122,
	491,
	510,
	191,
	-1253,
	161,
	-2,
	-324,
	-1450,
	-633,
	-712,
	-105,
	-842,
	-254,
	-411,
	100,
	-640,
	-290,
	1010,
	763,
	-650,
	313,
	1169,
	730,
	140,
	505,
	1030,
	766,
	772,
	287,
	1067,
	823,
	495,
	749,
	305,
	323,
	-164,
	462,
	78,
	399,
	-342,
	-874,
	69,
	597,
	-16,
	620,
	621,
	337,
	-138,
	-444,
	-265,
	218,
	84,
	-450,
	953,
	666,
	-222,
	-803,
	541,
	604,
	-921,
	-1376,
	244,
	116,
	-841,
	-723,
	630,
	588,
	140,
	663,
	294,
	368,
	935,
	1046,
	881,
	759,
	1746,
	1464,
	916,
	628,
	436,
	963,
	281,
	1,
	-119,
	74,
	542,
	213,
	1,
	-567,
	301,
	241,
	260,
	435,
	222,
	396,
	936,
	957,
	1108,
	703,
	510,
	506,
	808,
	478,
	601,
	694,
	960,
	620,
	972,
	741,
	980,
	600,
	834,
	717,
	767,
	684,
	643,
	972,
	935,
	638,
	501,
	661,
	720,
	851,
	-105,
	-632,
	-303,
	-117,
	-429,
	130,
	789,
	442,
	-522,
	-188,
	704,
	373,
	-759,
	42,
	814,
	523,
	-531,
	-1137,
	373,
	578,
	-682,
	-1203,
	-455,
	285,
	-1163,
	-1577,
	-1098,
	44,
	81,
	-82,
	712,
	363,
	477,
	246,
	954,
	622,
	1604,
	1622,
	1277,
	891,
	1409,
	859,
	924,
	892,
	774,
	1041,
	947,
	1142,
	40,
	-546,
	-75,
	288,
	-616,
	-106,
	-697,
	-26,
	-169,
	-160,
	-891,
	-739,
	-279,
	-384,
	-1029,
	-350,
	1781,
	1308,
	1046,
	816,
	1580,
	1533,
	1472,
	1178,
	1505,
	1076,
	1216,
	899,
	890,
	904,
	564,
	654,
	920,
	692,
	1021,
	856,
	-493,
	132,
	177,
	505,
	71,
	195,
	-28,
	97,
	456,
	351,
	-164,
	88,
	439,
	278,
	-40,
	350,
	1395,
	949,
	234,
	-95,
	-805,
	-472,
	38,
	-163,
	367,
	-98,
	489,
	523,
	1025,
	1178,
	1212,
	906,
	319,
	1314,
	814,
	461,
	-123,
	-543,
	-804,
	447,
	-748,
	-324,
	-897,
	-1127,
	-737,
	-501,
	-789,
	-713,
	715,
	777,
	1239,
	922,
	1949,
	1939,
	1368,
	865,
	730,
	880,
	758,
	388,
	-871,
	454,
	17,
	-251,
	-381,
	-810,
	-1583,
	239,
	-521,
	-966,
	-792,
	259,
	-890,
	-1358,
	-770,
	-73,
	166,
	349,
	-212,
	323,
	-840,
	-301,
	473,
	435,
	-679,
	-464,
	728,
	351,
	-156,
	-199,
	667,
	432,
	29,
	-252,
	415,
	480,
	-731,
	-379,
	145,
	559,
	-528,
	-631,
	-1158,
	-159,
	445,
	273,
	123,
	639,
	373,
	-126,
	800,
	568,
	84,
	-162,
	720,
	712,
	-830,
	-536,
	-185,
	222,
	408,
	452,
	501,
	771,
	-897,
	-1355,
	-67,
	442,
	-792,
	-1406,
	566,
	602,
	167,
	-326,
	509,
	330,
	-95,
	-626,
	-730,
	-344,
	1668,
	1217,
	779,
	455,
	1316,
	828,
	584,
	719,
	404,
	-31,
	1013,
	789,
	89,
	107,
	891,
	549,
	871,
	1581,
	917,
	671,
	866,
	1479,
	1289,
	854,
	391,
	1068,
	1122,
	812,
	78,
	-562,
	345,
	563,
	429,
	-103,
	417,
	787,
	-122,
	-437,
	411,
	788,
	-913,
	-417,
	602,
	754,
	-226,
	-16,
	151,
	760,
	-700,
	118,
	-104,
	-14,
	-1128,
	48,
	284,
	393,
	-390,
	-419,
	-639,
	-116,
	-910,
	306,
	316,
	-13,
	1207,
	984,
	821,
	669,
	-1195,
	-693,
	140,
	-213,
	-884,
	-416,
	-199,
	-558,
	-616,
	245,
	-404,
	-664,
	262,
	56,
	-617,
	-724,
	-85,
	-491,
	-320,
	-656,
	-570,
	-831,
	-129,
	-528,
	-1506,
	-63,
	-367,
	-385,
	-358,
	-321,
	4,
	51,
	-366,
	-214,
	319,
	511,
	146,
	671,
	-17,
	-291,
	-110,
	464,
	-139,
	-496,
	-202,
	220,
	-312,
	-631,
	-660,
	-73,
	-655,
	-820,
	-662,
	-653,
	-1288,
	-857,
	-430,
	-953,
	-959,
	-264,
	-49,
	-468,
	-72,
	-381,
	-350,
	-563,
	-193,
	-407,
	55,
	-408,
	-803,
	11,
	-309,
	649,
	188,
	-198,
	-512,
	461,
	-79,
	-458,
	-1318,
	-263,
	-134,
	-523,
	-1657,
	-435,
	-495,
	-765,
	57,
	-347,
	-414,
	434,
	-1141,
	-242,
	-664,
	-857,
	34,
	-68,
	-707,
	-338
};
#define MR515_3_SIZE  128

/* 3rd LSF quantizer (MR515 and MR475) */
__device__ static const Word32 mr515_3_lsf[] =
{
	419,
	163,
	-30,
	-262,
	-455,
	-789,
	-1430,
	-721,
	1006,
	664,
	269,
	25,
	619,
	260,
	183,
	96,
	-968,
	-1358,
	-388,
	135,
	-693,
	835,
	456,
	154,
	1105,
	703,
	569,
	363,
	1625,
	1326,
	985,
	748,
	-220,
	219,
	76,
	-208,
	-1455,
	-1662,
	49,
	149,
	-964,
	-172,
	-752,
	-336,
	625,
	209,
	-250,
	-66,
	-1017,
	-838,
	-2,
	317,
	-2168,
	-1485,
	-138,
	123,
	-1876,
	-2099,
	-521,
	85,
	-967,
	-366,
	-695,
	-881,
	-921,
	-1011,
	-763,
	-949,
	-124,
	-256,
	-352,
	-660,
	178,
	463,
	354,
	304,
	-1744,
	-591,
	-282,
	79,
	-2249,
	175,
	867,
	499,
	-138,
	-180,
	-181,
	-21,
	-2291,
	-1241,
	-460,
	-520,
	-771,
	451,
	-10,
	-308,
	271,
	-65,
	4,
	214,
	-279,
	-435,
	-43,
	-348,
	-670,
	35,
	-65,
	-211,
	806,
	535,
	85,
	297,
	57,
	239,
	722,
	493,
	225,
	661,
	840,
	547,
	-540,
	-376,
	14,
	349,
	469,
	721,
	331,
	162,
	-544,
	-752,
	-62,
	-10,
	398,
	-88,
	724,
	701,
	-19,
	-533,
	-94,
	601,
	136,
	-71,
	-681,
	-747,
	-166,
	-344,
	261,
	-50,
	161,
	-52,
	485,
	337,
	-1675,
	50,
	190,
	-93,
	-2282,
	-231,
	-194,
	-82,
	-95,
	-595,
	-154,
	128,
	894,
	501,
	588,
	457,
	-345,
	206,
	122,
	110,
	-631,
	-227,
	-569,
	3,
	408,
	239,
	397,
	226,
	-197,
	-2,
	128,
	491,
	1281,
	904,
	292,
	215,
	538,
	306,
	259,
	509,
	-677,
	-1047,
	13,
	321,
	-679,
	-588,
	-358,
	-212,
	-558,
	243,
	646,
	479,
	486,
	342,
	634,
	532,
	107,
	802,
	331,
	136,
	-112,
	-398,
	-1031,
	-286,
	-326,
	-705,
	288,
	272,
	1299,
	1144,
	1178,
	860,
	-423,
	121,
	-385,
	-148,
	-295,
	-302,
	-834,
	-819,
	16,
	-24,
	-201,
	-476,
	555,
	91,
	-245,
	294,
	-38,
	-379,
	-962,
	-1221,
	-1191,
	-1518,
	-273,
	-395,
	-390,
	-1013,
	-645,
	573,
	-1843,
	-1030,
	505,
	468,
	744,
	947,
	609,
	493,
	-689,
	-1172,
	-628,
	-135,
	-1026,
	195,
	411,
	196,
	1582,
	1147,
	575,
	337,
	-1239,
	-777,
	-648,
	-142,
	595,
	825,
	967,
	735,
	-1206,
	-970,
	-81,
	-342,
	-745,
	13,
	-72,
	375,
	454,
	19,
	1407,
	921,
	-1647,
	-172,
	861,
	562,
	928,
	1537,
	1063,
	740,
	-2472,
	-952,
	264,
	82,
	-502,
	-965,
	-1334,
	123,
	867,
	1236,
	534,
	171,
	-2320,
	-460,
	780,
	363,
	-1190,
	-617,
	252,
	-61,
	-174,
	34,
	1011,
	788,
	-2333,
	247,
	423,
	153,
	-16,
	-355,
	262,
	449,
	-1576,
	-1073,
	-544,
	-371,
	-615,
	-305,
	1051,
	805,
	687,
	528,
	6,
	-182,
	935,
	875,
	1002,
	809,
	199,
	257,
	126,
	76,
	-584,
	-1138,
	599,
	556,
	-1105,
	-1391,
	-1591,
	-519,
	-977,
	-1325,
	108,
	347,
	-722,
	-975,
	365,
	101,
	-145,
	681,
	249,
	-153,
	0,
	-334,
	-570,
	159,
	412,
	285,
	-336,
	-617,
	-953,
	-966,
	887,
	689,
	-1251,
	84,
	-185,
	-398,
	-592,
	433,
	1044,
	653,
	85,
	329,
	-40,
	361,
	-433,
	-705,
	466,
	574,
	-154,
	654,
	592,
	290,
	-167,
	72,
	349,
	175,
	674,
	297,
	977,
	720,
	1235,
	1204,
	757,
	488,
	-400,
	-269,
	538,
	372,
	-1350,
	-1387,
	-1194,
	-91,
	1262,
	876,
	775,
	700,
	-599,
	-38,
	-430,
	-722,
	1976,
	1630,
	991,
	608,
	111,
	276,
	-226,
	-96,
	-947,
	-388,
	-11,
	-7,
	-303,
	-531,
	-839,
	338,
	1734,
	1710,
	1405,
	1013,
	-516,
	-855,
	-645,
	210,
	-688,
	-416,
	513,
	230,
	-822,
	-637,
	-1146,
	-320,
	-952,
	-658,
	-694,
	183,
	-114,
	-623,
	818,
	674,
	-191,
	-204,
	731,
	635,
	51,
	1221,
	883,
	576,
	-954,
	-431,
	826,
	598,
	-342,
	-755,
	-900,
	-407,
	-1126,
	-354,
	-206,
	-512,
	-547,
	-810,
	-357,
	-620,
	66,
	515,
	-73,
	-410,
	-872,
	-945,
	-1444,
	-1227,
	191,
	-17,
	-544,
	-231,
	-1540,
	-544,
	-901,
	-886
};
#define MR795_1_SIZE  512

/* 1st LSF quantizer (MR795) */
__device__ static const Word32 mr795_1_lsf[] =
{
	-890,
	-1550,
	-2541,
	-819,
	-970,
	175,
	-826,
	-1234,
	-762,
	-599,
	-22,
	634,
	-811,
	-987,
	-902,
	-323,
	203,
	26,
	-383,
	-235,
	-781,
	-399,
	1262,
	906,
	-932,
	-1399,
	-1380,
	-624,
	93,
	87,
	-414,
	-539,
	-691,
	37,
	633,
	510,
	-387,
	-476,
	-1330,
	399,
	66,
	263,
	-407,
	-49,
	-335,
	-417,
	1041,
	1865,
	-779,
	-1089,
	-1440,
	-746,
	-858,
	832,
	-581,
	-759,
	-371,
	-673,
	-506,
	2088,
	-560,
	-634,
	-1179,
	271,
	241,
	14,
	-438,
	-244,
	-397,
	463,
	1202,
	1047,
	-606,
	-797,
	-1438,
	-51,
	-323,
	481,
	-224,
	-584,
	-527,
	494,
	881,
	682,
	-433,
	-306,
	-1002,
	554,
	659,
	222,
	171,
	-160,
	-353,
	681,
	1798,
	1565,
	-852,
	-1181,
	-1695,
	-336,
	-666,
	114,
	-581,
	-756,
	-744,
	-195,
	375,
	497,
	-465,
	-804,
	-1098,
	154,
	282,
	-131,
	-50,
	-191,
	-719,
	323,
	732,
	1542,
	-722,
	-819,
	-1404,
	105,
	-250,
	185,
	-178,
	-502,
	-742,
	321,
	510,
	1111,
	-323,
	-567,
	-966,
	127,
	484,
	338,
	-160,
	52,
	-338,
	732,
	1367,
	1554,
	-626,
	-802,
	-1696,
	-286,
	-586,
	676,
	-695,
	-343,
	-370,
	-490,
	295,
	1893,
	-630,
	-574,
	-1014,
	-80,
	645,
	-69,
	-6,
	-318,
	-364,
	782,
	1450,
	1038,
	-313,
	-733,
	-1395,
	120,
	60,
	477,
	-264,
	-585,
	-123,
	711,
	1245,
	633,
	-91,
	-355,
	-1016,
	771,
	758,
	261,
	253,
	81,
	-474,
	930,
	2215,
	1720,
	-808,
	-1099,
	-1925,
	-560,
	-782,
	169,
	-804,
	-1074,
	-188,
	-626,
	-55,
	1405,
	-694,
	-716,
	-1194,
	-660,
	354,
	329,
	-514,
	-55,
	-543,
	366,
	1033,
	1182,
	-658,
	-959,
	-1357,
	-55,
	-184,
	93,
	-605,
	-286,
	-662,
	404,
	449,
	827,
	-286,
	-350,
	-1263,
	628,
	306,
	227,
	-16,
	147,
	-623,
	186,
	923,
	2146,
	-674,
	-890,
	-1606,
	-443,
	-228,
	339,
	-369,
	-790,
	-409,
	231,
	86,
	1469,
	-448,
	-581,
	-1061,
	594,
	450,
	-177,
	-124,
	-170,
	-447,
	671,
	1159,
	1404,
	-476,
	-667,
	-1511,
	-77,
	-138,
	716,
	-177,
	-372,
	-381,
	451,
	934,
	915,
	-250,
	-432,
	-822,
	272,
	828,
	446,
	26,
	19,
	-31,
	698,
	1692,
	2168,
	-646,
	-977,
	-1924,
	-179,
	-473,
	268,
	-379,
	-745,
	-691,
	11,
	127,
	1033,
	-488,
	-917,
	-825,
	61,
	323,
	135,
	147,
	-145,
	-686,
	685,
	786,
	1682,
	-506,
	-848,
	-1297,
	35,
	90,
	222,
	-23,
	-346,
	-670,
	455,
	591,
	1287,
	-203,
	-593,
	-1086,
	652,
	352,
	437,
	39,
	63,
	-457,
	841,
	1265,
	2105,
	-520,
	-882,
	-1584,
	-328,
	-711,
	1421,
	-596,
	-342,
	-70,
	209,
	173,
	1928,
	-423,
	-598,
	-921,
	421,
	605,
	-38,
	-2,
	-245,
	-127,
	896,
	1969,
	1135,
	-379,
	-518,
	-1579,
	173,
	118,
	753,
	-55,
	-381,
	-52,
	985,
	1021,
	753,
	-2,
	-291,
	-891,
	753,
	992,
	423,
	264,
	131,
	-196,
	895,
	2274,
	2543,
	-635,
	-1088,
	-2499,
	-529,
	-982,
	526,
	-764,
	-830,
	-548,
	-436,
	316,
	599,
	-675,
	-940,
	-746,
	-57,
	236,
	-11,
	-201,
	-81,
	-798,
	16,
	845,
	1558,
	-737,
	-985,
	-1212,
	-468,
	17,
	290,
	-279,
	-584,
	-700,
	183,
	822,
	705,
	-265,
	-492,
	-1187,
	421,
	152,
	468,
	-390,
	166,
	-268,
	39,
	1550,
	1868,
	-635,
	-966,
	-1571,
	-453,
	-492,
	910,
	-284,
	-1027,
	-75,
	-181,
	-133,
	1852,
	-445,
	-624,
	-1174,
	420,
	367,
	-49,
	-389,
	-212,
	-169,
	707,
	1073,
	1208,
	-539,
	-710,
	-1449,
	83,
	-163,
	484,
	-236,
	-543,
	-355,
	338,
	1175,
	814,
	-246,
	-309,
	-958,
	606,
	760,
	60,
	166,
	-8,
	-163,
	-306,
	1849,
	2563,
	-747,
	-1025,
	-1783,
	-419,
	-446,
	209,
	-718,
	-566,
	-534,
	-506,
	693,
	857,
	-463,
	-697,
	-1082,
	325,
	431,
	-206,
	-15,
	-8,
	-763,
	545,
	919,
	1518,
	-611,
	-783,
	-1313,
	256,
	-55,
	208,
	-165,
	-348,
	-662,
	321,
	680,
	930,
	-326,
	-429,
	-951,
	484,
	446,
	570,
	-197,
	72,
	-73,
	909,
	1455,
	1741,
	-563,
	-737,
	-1974,
	-124,
	-416,
	718,
	-478,
	-404,
	-314,
	-16,
	446,
	1636,
	-551,
	-537,
	-750,
	-58,
	638,
	214,
	55,
	-185,
	-271,
	1148,
	1301,
	1212,
	-483,
	-671,
	-1264,
	117,
	285,
	543,
	-204,
	-391,
	-111,
	513,
	1538,
	854,
	-114,
	-190,
	-978,
	877,
	595,
	464,
	260,
	260,
	-311,
	748,
	2283,
	2216,
	-517,
	-945,
	-2171,
	-326,
	-708,
	378,
	-812,
	-691,
	-232,
	-560,
	687,
	1409,
	-732,
	-690,
	-836,
	-359,
	645,
	386,
	-265,
	62,
	-678,
	145,
	1644,
	1208,
	-555,
	-988,
	-1233,
	-78,
	14,
	114,
	-327,
	-358,
	-489,
	392,
	677,
	697,
	-201,
	-236,
	-1140,
	693,
	449,
	178,
	-243,
	256,
	-433,
	611,
	1385,
	2456,
	-612,
	-901,
	-1464,
	-307,
	-17,
	499,
	-315,
	-667,
	-254,
	256,
	428,
	1463,
	-486,
	-422,
	-1056,
	655,
	370,
	18,
	-102,
	-185,
	-276,
	755,
	1578,
	1335,
	-488,
	-603,
	-1418,
	182,
	-93,
	870,
	-73,
	-458,
	-348,
	835,
	862,
	957,
	-282,
	-333,
	-746,
	547,
	839,
	428,
	273,
	-89,
	13,
	940,
	1708,
	2576,
	-418,
	-1084,
	-1758,
	-44,
	-358,
	259,
	-497,
	-643,
	-560,
	99,
	557,
	961,
	-421,
	-766,
	-917,
	295,
	326,
	184,
	175,
	15,
	-626,
	532,
	878,
	1981,
	-443,
	-768,
	-1275,
	221,
	156,
	268,
	39,
	-363,
	-505,
	695,
	772,
	1140,
	-162,
	-459,
	-912,
	709,
	444,
	658,
	25,
	303,
	-312,
	1268,
	1410,
	1715,
	-297,
	-766,
	-1836,
	-263,
	-108,
	1070,
	-406,
	-13,
	-129,
	57,
	438,
	2734,
	-374,
	-487,
	-835,
	304,
	696,
	164,
	104,
	-235,
	5,
	1611,
	1900,
	1399,
	-229,
	-582,
	-1325,
	405,
	192,
	817,
	-87,
	-438,
	111,
	1028,
	1199,
	993,
	68,
	-175,
	-934,
	1033,
	1117,
	451,
	478,
	200,
	-248,
	2127,
	2696,
	2042,
	-835,
	-1323,
	-2131,
	-799,
	-692,
	466,
	-812,
	-1032,
	-469,
	-622,
	288,
	920,
	-701,
	-841,
	-1070,
	-411,
	512,
	8,
	-390,
	-91,
	-744,
	-30,
	1043,
	1161,
	-822,
	-1148,
	-1156,
	-294,
	-46,
	110,
	-411,
	-374,
	-678,
	214,
	531,
	668,
	-406,
	-420,
	-1194,
	487,
	232,
	303,
	-318,
	91,
	-472,
	123,
	1232,
	2445,
	-722,
	-952,
	-1495,
	-738,
	-675,
	1332,
	-543,
	-606,
	-211,
	-95,
	-98,
	1508,
	-549,
	-514,
	-1193,
	473,
	211,
	73,
	-288,
	-112,
	-389,
	537,
	1332,
	1258,
	-567,
	-755,
	-1545,
	71,
	-283,
	632,
	-170,
	-481,
	-493,
	681,
	1002,
	817,
	-356,
	-331,
	-877,
	419,
	706,
	346,
	241,
	-34,
	-326,
	377,
	1950,
	1883,
	-727,
	-1075,
	-1625,
	-233,
	-543,
	116,
	-524,
	-806,
	-585,
	-73,
	478,
	729,
	-288,
	-925,
	-1143,
	173,
	447,
	-52,
	68,
	-229,
	-606,
	449,
	529,
	1797,
	-591,
	-875,
	-1363,
	183,
	-144,
	324,
	-103,
	-452,
	-666,
	623,
	488,
	1176,
	-238,
	-511,
	-1004,
	326,
	552,
	458,
	136,
	108,
	-319,
	626,
	1343,
	1883,
	-490,
	-646,
	-1730,
	-186,
	-449,
	984,
	-738,
	-76,
	-170,
	-550,
	755,
	2560,
	-496,
	-510,
	-947,
	210,
	694,
	-52,
	84,
	-322,
	-199,
	1090,
	1625,
	1224,
	-376,
	-603,
	-1396,
	343,
	74,
	632,
	-175,
	-502,
	-32,
	972,
	1332,
	734,
	52,
	-295,
	-1113,
	1065,
	918,
	160,
	393,
	107,
	-397,
	1214,
	2649,
	1741,
	-632,
	-1201,
	-1891,
	-719,
	-277,
	353,
	-651,
	-880,
	-122,
	-211,
	209,
	1338,
	-562,
	-714,
	-1059,
	-208,
	388,
	159,
	-320,
	-61,
	-551,
	293,
	1092,
	1443,
	-648,
	-865,
	-1253,
	-49,
	-143,
	305,
	-401,
	-227,
	-585,
	561,
	532,
	927,
	-117,
	-443,
	-1188,
	507,
	436,
	292,
	-79,
	233,
	-458,
	671,
	1025,
	2396,
	-633,
	-842,
	-1525,
	-308,
	-286,
	640,
	-373,
	-621,
	-407,
	418,
	253,
	1305,
	-315,
	-581,
	-1137,
	572,
	685,
	-281,
	61,
	-68,
	-371,
	991,
	1101,
	1498,
	-493,
	-683,
	-1362,
	-47,
	164,
	704,
	-256,
	-314,
	-268,
	631,
	949,
	1052,
	-118,
	-348,
	-833,
	68,
	1180,
	568,
	152,
	117,
	34,
	1113,
	1902,
	2239,
	-601,
	-959,
	-1706,
	-143,
	-489,
	480,
	-332,
	-655,
	-574,
	54,
	353,
	1192,
	-462,
	-652,
	-796,
	150,
	549,
	112,
	195,
	-111,
	-515,
	679,
	1108,
	1647,
	-558,
	-749,
	-1217,
	-9,
	272,
	341,
	-53,
	-265,
	-535,
	489,
	843,
	1298,
	-120,
	-482,
	-1032,
	632,
	543,
	408,
	179,
	306,
	-526,
	1124,
	1464,
	2244,
	-417,
	-786,
	-1562,
	-224,
	-384,
	1364,
	-377,
	-459,
	-25,
	385,
	489,
	2174,
	-332,
	-651,
	-829,
	544,
	553,
	61,
	22,
	-113,
	-89,
	1128,
	1725,
	1524,
	-216,
	-373,
	-1653,
	161,
	316,
	908,
	-165,
	-222,
	-67,
	1362,
	1175,
	789,
	73,
	-252,
	-767,
	738,
	932,
	616,
	362,
	246,
	-126,
	787,
	2654,
	3027,
	-691,
	-1106,
	-2190,
	-565,
	-588,
	524,
	-590,
	-979,
	-490,
	-263,
	397,
	982,
	-577,
	-837,
	-945,
	-22,
	435,
	-49,
	-190,
	-118,
	-629,
	-88,
	1240,
	1513,
	-636,
	-1051,
	-1019,
	-291,
	189,
	259,
	-257,
	-470,
	-629,
	145,
	945,
	894,
	-326,
	-364,
	-1094,
	543,
	260,
	630,
	-202,
	189,
	-209,
	357,
	1379,
	2091,
	-569,
	-1075,
	-1449,
	-714,
	-239,
	919,
	-420,
	-705,
	-84,
	-109,
	-114,
	2407,
	-413,
	-529,
	-1177,
	482,
	368,
	131,
	-186,
	-72,
	-131,
	861,
	1255,
	1220,
	-611,
	-658,
	-1341,
	227,
	-121,
	631,
	-176,
	-489,
	-218,
	745,
	1175,
	957,
	-321,
	-148,
	-936,
	671,
	966,
	216,
	340,
	-3,
	-143,
	469,
	1848,
	2437,
	-729,
	-961,
	-1683,
	-213,
	-254,
	321,
	-511,
	-438,
	-521,
	-126,
	725,
	903,
	-340,
	-685,
	-1032,
	316,
	480,
	20,
	23,
	-89,
	-551,
	353,
	1051,
	1789,
	-544,
	-757,
	-1364,
	298,
	-25,
	436,
	-100,
	-392,
	-519,
	467,
	754,
	1078,
	-210,
	-398,
	-1078,
	620,
	658,
	630,
	33,
	147,
	-178,
	921,
	1687,
	1921,
	-325,
	-528,
	-1978,
	2,
	-285,
	910,
	-371,
	-490,
	-230,
	0,
	597,
	2010,
	-496,
	-395,
	-834,
	37,
	945,
	245,
	181,
	-160,
	-144,
	1481,
	1373,
	1357,
	-355,
	-601,
	-1270,
	298,
	322,
	672,
	-193,
	-336,
	77,
	1089,
	1533,
	922,
	177,
	-39,
	-1125,
	996,
	781,
	536,
	456,
	366,
	-432,
	1415,
	2440,
	2279,
	-466,
	-758,
	-2325,
	-303,
	-509,
	387,
	-727,
	-557,
	66,
	-145,
	643,
	1248,
	-544,
	-676,
	-916,
	-225,
	862,
	588,
	-152,
	40,
	-533,
	423,
	1423,
	1558,
	-572,
	-843,
	-1145,
	-128,
	85,
	461,
	-238,
	-257,
	-584,
	605,
	748,
	861,
	24,
	-202,
	-1409,
	797,
	487,
	303,
	-181,
	364,
	-182,
	616,
	1378,
	2942,
	-494,
	-852,
	-1441,
	-292,
	61,
	812,
	-84,
	-723,
	-182,
	555,
	532,
	1506,
	-365,
	-493,
	-1057,
	822,
	588,
	11,
	-14,
	-18,
	-230,
	1001,
	1401,
	1451,
	-474,
	-569,
	-1292,
	302,
	62,
	1062,
	-70,
	-376,
	-222,
	982,
	974,
	1149,
	-196,
	-234,
	-795,
	479,
	1098,
	499,
	362,
	58,
	70,
	1147,
	2069,
	2857,
	-487,
	-878,
	-1824,
	73,
	-288,
	348,
	-358,
	-500,
	-508,
	199,
	721,
	1242,
	-78,
	-697,
	-795,
	361,
	536,
	196,
	374,
	110,
	-735,
	847,
	1051,
	1896,
	-366,
	-713,
	-1182,
	315,
	320,
	429,
	72,
	-215,
	-450,
	759,
	886,
	1363,
	-30,
	-428,
	-834,
	861,
	627,
	796,
	118,
	468,
	-279,
	1355,
	1883,
	1893,
	-188,
	-642,
	-1612,
	63,
	-175,
	1198,
	-418,
	-211,
	51,
	414,
	587,
	2601,
	-234,
	-557,
	-858,
	424,
	889,
	222,
	136,
	-101,
	83,
	1413,
	2278,
	1383,
	-84,
	-445,
	-1389,
	414,
	313,
	1045,
	29,
	-343,
	65,
	1552,
	1647,
	980,
	183,
	-91,
	-829,
	1273,
	1413,
	360,
	553,
	272,
	-107,
	1587,
	3149,
	2603
};
#define DICO1_SIZE_5  128
#define DICO2_SIZE_5  256
#define DICO3_SIZE_5  256
#define DICO4_SIZE_5  256
#define DICO5_SIZE_5  64

/* 1st LSF quantizer (MR122) */
__device__ static const Word32 dico1_lsf_5[DICO1_SIZE_5 * 4] =
{
	-451,
	-1065,
	-529,
	-1305,
	-450,
	-756,
	-497,
	-863,
	-384,
	-619,
	-413,
	-669,
	-317,
	-538,
	-331,
	-556,
	-414,
	-508,
	-424,
	-378,
	-274,
	-324,
	-434,
	-614,
	-226,
	-500,
	-232,
	-514,
	-263,
	-377,
	-298,
	-410,
	-151,
	-710,
	-174,
	-818,
	-149,
	-412,
	-156,
	-429,
	-288,
	-462,
	-186,
	-203,
	-170,
	-302,
	-191,
	-321,
	-131,
	-147,
	-297,
	-395,
	-228,
	-214,
	-245,
	-192,
	-67,
	-316,
	-71,
	-327,
	-104,
	-205,
	-94,
	-183,
	-143,
	-38,
	-193,
	-95,
	16,
	-76,
	-124,
	-248,
	23,
	-237,
	24,
	-244,
	18,
	-136,
	44,
	-111,
	-33,
	-24,
	-25,
	0,
	149,
	19,
	23,
	-143,
	158,
	-169,
	174,
	-181,
	133,
	-55,
	165,
	-26,
	111,
	84,
	98,
	75,
	87,
	183,
	-115,
	-11,
	-8,
	130,
	11,
	170,
	254,
	77,
	205,
	17,
	183,
	112,
	262,
	194,
	202,
	287,
	95,
	189,
	-42,
	-105,
	234,
	179,
	39,
	186,
	163,
	345,
	332,
	199,
	299,
	161,
	-54,
	285,
	-78,
	281,
	-133,
	141,
	-182,
	111,
	249,
	341,
	271,
	364,
	93,
	403,
	75,
	391,
	92,
	510,
	-138,
	220,
	-185,
	-29,
	-34,
	361,
	-115,
	320,
	3,
	554,
	99,
	286,
	218,
	591,
	-245,
	406,
	-268,
	453,
	0,
	580,
	25,
	606,
	275,
	532,
	148,
	450,
	-73,
	739,
	-285,
	518,
	-288,
	94,
	-203,
	674,
	-140,
	-74,
	205,
	714,
	-114,
	299,
	176,
	923,
	182,
	557,
	240,
	705,
	-16,
	513,
	485,
	593,
	293,
	384,
	451,
	617,
	-38,
	50,
	563,
	529,
	303,
	209,
	459,
	363,
	433,
	452,
	450,
	454,
	367,
	606,
	477,
	741,
	432,
	353,
	368,
	267,
	361,
	716,
	273,
	583,
	453,
	166,
	510,
	172,
	201,
	629,
	274,
	191,
	568,
	639,
	302,
	298,
	634,
	387,
	643,
	350,
	587,
	560,
	612,
	565,
	600,
	788,
	487,
	672,
	512,
	1015,
	321,
	333,
	357,
	854,
	-125,
	413,
	474,
	712,
	17,
	-151,
	564,
	285,
	270,
	-241,
	971,
	889,
	489,
	220,
	510,
	896,
	549,
	924,
	327,
	825,
	290,
	911,
	540,
	1108,
	158,
	805,
	199,
	957,
	511,
	730,
	100,
	874,
	13,
	791,
	435,
	632,
	676,
	972,
	249,
	900,
	467,
	1218,
	781,
	1074,
	585,
	785,
	-23,
	669,
	267,
	1043,
	619,
	1084,
	615,
	1145,
	622,
	905,
	916,
	1049,
	80,
	331,
	584,
	1075,
	89,
	639,
	988,
	961,
	770,
	720,
	798,
	699,
	492,
	447,
	899,
	627,
	271,
	1188,
	725,
	1333,
	87,
	603,
	832,
	1603,
	616,
	1127,
	890,
	1505,
	1000,
	1156,
	866,
	1009,
	995,
	827,
	1149,
	858,
	817,
	1450,
	773,
	1320,
	500,
	1389,
	312,
	1153,
	-20,
	1084,
	64,
	1283,
	2,
	1172,
	399,
	1869,
	514,
	1706,
	502,
	1636,
	886,
	1522,
	416,
	600,
	1131,
	1350,
	1275,
	1390,
	889,
	1795,
	914,
	1766,
	227,
	1183,
	1250,
	1826,
	505,
	1854,
	919,
	2353,
	-199,
	431,
	152,
	1735,
	-213,
	-28,
	392,
	1334,
	-153,
	-52,
	978,
	1151,
	-323,
	-400,
	813,
	1703,
	-136,
	84,
	1449,
	2015,
	-331,
	-143,
	-137,
	1192,
	-256,
	534,
	-157,
	1031,
	-307,
	-439,
	542,
	731,
	-329,
	-420,
	-97,
	616,
	-362,
	-168,
	-322,
	366,
	-247,
	-110,
	-211,
	89,
	-196,
	-309,
	20,
	59,
	-364,
	-463,
	-286,
	89,
	-336,
	175,
	-432,
	141,
	-379,
	-190,
	-434,
	-196,
	-79,
	150,
	-278,
	-227,
	-280,
	166,
	-555,
	-422,
	-155,
	541,
	-366,
	54,
	-29,
	-83,
	-301,
	-774,
	186,
	628,
	-397,
	-264,
	242,
	293,
	-197,
	-585,
	124,
	410,
	53,
	-133,
	10,
	340,
	-570,
	-1065,
	65,
	-446,
	68,
	-493,
	383,
	937,
	-357,
	-711,
	-359,
	-250,
	-677,
	-1068,
	292,
	-26,
	363,
	6,
	607,
	1313,
	-127,
	-10,
	1513,
	1886,
	713,
	972,
	1469,
	2181,
	1443,
	2016
};

/* 2nd LSF quantizer (MR122) */
__device__ static const Word32 dico2_lsf_5[DICO2_SIZE_5 * 4] =
{
	-1631,
	-1600,
	-1796,
	-2290,
	-1027,
	-1770,
	-1100,
	-2025,
	-1277,
	-1388,
	-1367,
	-1534,
	-947,
	-1461,
	-972,
	-1524,
	-999,
	-1222,
	-1020,
	-1172,
	-815,
	-987,
	-992,
	-1371,
	-1216,
	-1006,
	-1289,
	-1094,
	-744,
	-1268,
	-755,
	-1293,
	-862,
	-923,
	-905,
	-984,
	-678,
	-1051,
	-685,
	-1050,
	-1087,
	-985,
	-1062,
	-679,
	-989,
	-641,
	-1127,
	-976,
	-762,
	-654,
	-890,
	-806,
	-833,
	-1091,
	-706,
	-629,
	-621,
	-806,
	-640,
	-812,
	-775,
	-634,
	-779,
	-543,
	-996,
	-565,
	-1075,
	-580,
	-546,
	-611,
	-572,
	-619,
	-760,
	-290,
	-879,
	-526,
	-823,
	-462,
	-795,
	-253,
	-553,
	-415,
	-589,
	-439,
	-533,
	-340,
	-692,
	-935,
	-505,
	-772,
	-702,
	-1131,
	-263,
	-306,
	-971,
	-483,
	-445,
	-74,
	-555,
	-548,
	-614,
	-129,
	-693,
	-234,
	-396,
	-246,
	-475,
	-250,
	-265,
	-404,
	-376,
	-514,
	-417,
	-510,
	-300,
	-313,
	-334,
	-664,
	-463,
	-814,
	-386,
	-704,
	-337,
	-615,
	-234,
	-201,
	-233,
	-239,
	-167,
	-567,
	-203,
	-619,
	-147,
	-415,
	-115,
	-352,
	-166,
	-750,
	-171,
	-761,
	-270,
	-879,
	-264,
	-903,
	-367,
	-744,
	43,
	-475,
	14,
	-653,
	43,
	-670,
	11,
	-448,
	-59,
	-521,
	-126,
	-119,
	-155,
	-613,
	-42,
	-863,
	-27,
	-931,
	136,
	-483,
	183,
	-468,
	55,
	-298,
	55,
	-304,
	313,
	-609,
	313,
	-720,
	322,
	-167,
	100,
	-541,
	-3,
	-119,
	-111,
	-187,
	233,
	-236,
	260,
	-234,
	26,
	-165,
	134,
	-45,
	-40,
	-549,
	360,
	-203,
	378,
	-388,
	450,
	-383,
	275,
	20,
	182,
	-103,
	246,
	-111,
	431,
	37,
	462,
	-146,
	487,
	-157,
	-284,
	-59,
	503,
	-184,
	24,
	53,
	-3,
	54,
	122,
	259,
	333,
	66,
	484,
	104,
	436,
	68,
	195,
	116,
	190,
	206,
	269,
	-9,
	482,
	352,
	382,
	285,
	399,
	277,
	452,
	256,
	69,
	186,
	13,
	297,
	-13,
	259,
	-95,
	30,
	56,
	394,
	196,
	425,
	205,
	456,
	281,
	577,
	15,
	191,
	375,
	290,
	407,
	576,
	-56,
	227,
	544,
	405,
	0,
	549,
	-92,
	528,
	-229,
	351,
	-245,
	338,
	-362,
	435,
	167,
	527,
	-75,
	302,
	91,
	824,
	129,
	599,
	496,
	679,
	186,
	749,
	153,
	737,
	-281,
	600,
	-348,
	615,
	-236,
	769,
	41,
	881,
	38,
	890,
	-220,
	841,
	-357,
	883,
	-393,
	903,
	-634,
	474,
	-444,
	850,
	-175,
	678,
	-493,
	242,
	-519,
	785,
	-714,
	582,
	-541,
	366,
	-543,
	434,
	-597,
	500,
	-765,
	222,
	-702,
	917,
	-743,
	962,
	-869,
	501,
	-899,
	548,
	-379,
	200,
	-435,
	157,
	-819,
	214,
	-861,
	157,
	-614,
	40,
	-632,
	94,
	-883,
	-54,
	-741,
	516,
	-501,
	298,
	-614,
	-171,
	-870,
	-161,
	-865,
	-23,
	-818,
	93,
	-1015,
	-267,
	-662,
	-359,
	-549,
	2,
	-442,
	-121,
	-377,
	0,
	-227,
	33,
	-414,
	-126,
	-129,
	212,
	-934,
	34,
	-1082,
	-282,
	-1119,
	-268,
	-710,
	-825,
	-420,
	-191,
	-1076,
	-928,
	-917,
	-93,
	-628,
	-358,
	97,
	7,
	-206,
	-393,
	-101,
	24,
	-203,
	38,
	-168,
	83,
	-599,
	-423,
	-279,
	426,
	-700,
	118,
	-75,
	206,
	-981,
	-673,
	-680,
	417,
	-367,
	37,
	-279,
	474,
	-129,
	-318,
	319,
	296,
	-626,
	-39,
	343,
	602,
	-696,
	-39,
	-303,
	940,
	104,
	233,
	-380,
	137,
	-36,
	269,
	-75,
	-214,
	120,
	43,
	-529,
	-477,
	459,
	164,
	-202,
	-229,
	-49,
	-167,
	609,
	792,
	98,
	-220,
	915,
	148,
	293,
	283,
	869,
	91,
	575,
	394,
	326,
	-78,
	717,
	67,
	365,
	-323,
	616,
	-36,
	731,
	27,
	619,
	238,
	632,
	273,
	448,
	99,
	801,
	476,
	869,
	273,
	685,
	64,
	789,
	72,
	1021,
	217,
	793,
	459,
	734,
	360,
	646,
	480,
	360,
	322,
	429,
	464,
	638,
	430,
	756,
	363,
	1000,
	404,
	683,
	528,
	602,
	615,
	655,
	413,
	946,
	687,
	937,
	602,
	904,
	604,
	555,
	737,
	786,
	662,
	467,
	654,
	362,
	589,
	929,
	710,
	498,
	478,
	415,
	420,
	693,
	883,
	813,
	683,
	781,
	925,
	913,
	939,
	726,
	732,
	491,
	853,
	531,
	948,
	734,
	963,
	315,
	808,
	761,
	755,
	1144,
	760,
	655,
	1076,
	826,
	1057,
	1091,
	838,
	1003,
	808,
	1047,
	1133,
	659,
	1101,
	992,
	1050,
	1074,
	1075,
	971,
	694,
	1226,
	1054,
	571,
	841,
	884,
	1404,
	1379,
	1096,
	1080,
	861,
	1231,
	735,
	1284,
	760,
	1272,
	991,
	1367,
	1053,
	1257,
	700,
	1050,
	534,
	988,
	453,
	1264,
	599,
	1140,
	679,
	1621,
	815,
	1384,
	521,
	1317,
	393,
	1564,
	805,
	1448,
	686,
	1068,
	648,
	875,
	307,
	1083,
	361,
	1047,
	317,
	1417,
	964,
	675,
	571,
	1152,
	79,
	1114,
	-47,
	1530,
	311,
	1721,
	314,
	1166,
	689,
	514,
	-94,
	349,
	282,
	1412,
	328,
	1025,
	487,
	-65,
	57,
	805,
	970,
	36,
	62,
	769,
	-263,
	791,
	-346,
	637,
	699,
	-137,
	620,
	534,
	541,
	-735,
	194,
	711,
	300,
	-268,
	-863,
	926,
	769,
	-708,
	-428,
	506,
	174,
	-892,
	-630,
	435,
	547,
	-1435,
	-258,
	621,
	471,
	-1018,
	-1368,
	-393,
	521,
	-920,
	-686,
	-25,
	20,
	-982,
	-1156,
	340,
	9,
	-1558,
	-1135,
	-352,
	48,
	-1579,
	-402,
	-887,
	6,
	-1156,
	-888,
	-548,
	-352,
	-1643,
	-1168,
	-159,
	610,
	-2024,
	-963,
	-225,
	193,
	-1656,
	-1960,
	-245,
	-493,
	-964,
	-1680,
	-936,
	-635,
	-1299,
	-1744,
	-1388,
	-604,
	-1540,
	-835,
	-1397,
	-135,
	-1588,
	-290,
	-1670,
	-712,
	-2011,
	-1632,
	-1663,
	-27,
	-2258,
	-811,
	-1157,
	184,
	-1265,
	189,
	-1367,
	586,
	-2011,
	201,
	-790,
	712,
	-1210,
	3,
	-1033,
	808,
	-1251,
	830,
	-111,
	635,
	-1636,
	447,
	-463,
	-949,
	-445,
	-928,
	-504,
	-1162,
	-501,
	-1211,
	144,
	-351,
	-372,
	-1052,
	-283,
	-1059,
	-279,
	-1123,
	-575,
	-1438,
	-587,
	-1614,
	-935,
	-984,
	229,
	690,
	-921,
	-719,
	-403,
	1362,
	-685,
	-465,
	874,
	397,
	-509,
	-46,
	317,
	1334,
	-485,
	456,
	813,
	439,
	-411,
	339,
	898,
	1067,
	-425,
	46,
	1441,
	497,
	-909,
	-800,
	1465,
	1046,
	-254,
	-321,
	1430,
	1165,
	68,
	350,
	1034,
	666,
	370,
	11,
	1311,
	790,
	143,
	232,
	1041,
	1562,
	-114,
	663,
	1616,
	1078,
	454,
	579,
	1275,
	1040,
	-76,
	909,
	752,
	1067,
	153,
	512,
	348,
	1214,
	614,
	385,
	1843,
	808,
	269,
	1034,
	203,
	1086,
	652,
	1017,
	1783,
	1130,
	429,
	1327,
	387,
	1384,
	-49,
	1183,
	-72,
	1215,
	-416,
	1001,
	544,
	1749,
	-352,
	1223,
	-502,
	1199,
	-589,
	569,
	-227,
	1630,
	-142,
	1578,
	-230,
	1715,
	-714,
	1288,
	-838,
	1398,
	1131,
	1357,
	-208,
	1232,
	437,
	965,
	-929,
	818,
	811,
	1410,
	859,
	1507,
	164,
	1212,
	1387,
	1793,
	484,
	1874,
	456,
	2063,
	996,
	1170,
	1326,
	1402,
	1316,
	1360,
	1135,
	1262,
	1234,
	1618,
	1361,
	1768,
	1421,
	1227,
	1584,
	1347,
	854,
	672,
	1685,
	1566,
	1139,
	1270,
	2016,
	1825,
	1773,
	1581,
	1532,
	1460,
	1487,
	946,
	1659,
	1021,
	1744,
	1212,
	1392,
	977,
	1772,
	1161,
	1826,
	1164,
	1718,
	1429,
	1973,
	1591,
	1185,
	864,
	2132,
	1061,
	1799,
	814,
	1838,
	757,
	2104,
	1315,
	2054,
	1258,
	2113,
	915,
	2331,
	930,
	1467,
	1147,
	2590,
	1439,
	2245,
	1744,
	2090,
	1620,
	2358,
	1454,
	2666,
	1506,
	1876,
	1837,
	2070,
	1975,
	1739,
	1577,
	682,
	1289,
	1584,
	2045,
	1454,
	2098,
	2498,
	2004,
	2711,
	2066,
	726,
	1588,
	2756,
	2336,
	228,
	847,
	2456,
	1659,
	36,
	301,
	1942,
	1957,
	-446,
	-96,
	2154,
	1396,
	1533,
	1101,
	14,
	608,
	-923,
	-732,
	1383,
	1982,
	1345,
	952,
	-680,
	321,
	1281,
	1268,
	-1594,
	365,
	941,
	946,
	-1737,
	-822,
	2374,
	2787,
	1821,
	2788
};

/* 3rd LSF quantizer (MR122) */
__device__ static const Word32 dico3_lsf_5[DICO3_SIZE_5 * 4] =
{
	-1812,
	-2275,
	-1879,
	-2537,
	-1640,
	-1848,
	-1695,
	-2004,
	-1220,
	-1912,
	-1221,
	-2106,
	-1559,
	-1588,
	-1573,
	-1556,
	-1195,
	-1615,
	-1224,
	-1727,
	-1359,
	-1151,
	-1616,
	-1948,
	-1274,
	-1391,
	-1305,
	-1403,
	-1607,
	-1179,
	-1676,
	-1311,
	-1443,
	-1478,
	-1367,
	-898,
	-1256,
	-1059,
	-1331,
	-1134,
	-982,
	-1133,
	-1149,
	-1504,
	-1080,
	-1308,
	-1020,
	-1183,
	-980,
	-1486,
	-967,
	-1495,
	-988,
	-922,
	-1047,
	-1077,
	-838,
	-1179,
	-858,
	-1222,
	-1131,
	-1041,
	-1064,
	-767,
	-872,
	-1157,
	-701,
	-880,
	-706,
	-906,
	-774,
	-1016,
	-578,
	-1080,
	-801,
	-1478,
	-591,
	-1111,
	-592,
	-1146,
	-713,
	-1388,
	-640,
	-1376,
	-597,
	-1059,
	-416,
	-903,
	-686,
	-832,
	-661,
	-708,
	-444,
	-868,
	-490,
	-921,
	-374,
	-776,
	-619,
	-1170,
	-585,
	-549,
	-769,
	-795,
	-435,
	-659,
	-530,
	-741,
	-498,
	-837,
	-357,
	-597,
	-279,
	-871,
	-243,
	-887,
	-282,
	-665,
	-280,
	-667,
	-165,
	-560,
	-394,
	-903,
	-362,
	-410,
	-448,
	-583,
	-409,
	-574,
	-313,
	-357,
	-637,
	-548,
	-570,
	-436,
	-896,
	-504,
	-382,
	-757,
	-58,
	-481,
	-165,
	-618,
	-191,
	-374,
	-234,
	-382,
	-222,
	-683,
	-25,
	-480,
	-418,
	-359,
	-730,
	-353,
	-324,
	-157,
	-432,
	-322,
	-394,
	-303,
	-284,
	-104,
	-601,
	-289,
	-556,
	-196,
	-588,
	-150,
	-659,
	-608,
	-473,
	-24,
	-68,
	-448,
	-474,
	-8,
	-506,
	-45,
	-748,
	-184,
	-844,
	-252,
	-901,
	-91,
	-584,
	-97,
	-652,
	138,
	-764,
	-131,
	-678,
	-12,
	-670,
	165,
	-259,
	-3,
	-840,
	-107,
	-909,
	37,
	-992,
	44,
	-854,
	-415,
	-839,
	13,
	-1001,
	-271,
	-1026,
	-309,
	-798,
	-478,
	-832,
	-488,
	-943,
	168,
	-1112,
	-387,
	-1185,
	-101,
	-1183,
	-40,
	-941,
	-316,
	-1030,
	-770,
	-1044,
	-625,
	-1081,
	-538,
	-1224,
	-299,
	-1312,
	-436,
	-1197,
	-663,
	-1167,
	-161,
	-1216,
	-690,
	-1237,
	-831,
	-1432,
	-720,
	-1403,
	-493,
	-898,
	-740,
	-922,
	-801,
	-1102,
	-402,
	-1579,
	-964,
	-1061,
	-638,
	-1269,
	-1438,
	-1499,
	-934,
	-1502,
	-895,
	-1598,
	-564,
	-1723,
	-717,
	-606,
	-597,
	-1166,
	-1085,
	-1369,
	-468,
	-1946,
	-1493,
	-1838,
	-953,
	-1932,
	-931,
	-1499,
	-188,
	-1635,
	-421,
	-1457,
	-338,
	-1448,
	-22,
	-1942,
	-422,
	-2006,
	-249,
	-496,
	-114,
	-1910,
	-755,
	-1289,
	174,
	-1451,
	-109,
	-482,
	-257,
	-1221,
	-508,
	-1617,
	151,
	-1694,
	208,
	-654,
	107,
	-1651,
	29,
	-1141,
	279,
	-1215,
	306,
	-1228,
	-506,
	-730,
	-175,
	-1236,
	-101,
	-969,
	551,
	-870,
	278,
	-823,
	315,
	-563,
	376,
	-1051,
	228,
	-507,
	280,
	-599,
	281,
	-758,
	253,
	-305,
	379,
	-755,
	-134,
	-611,
	660,
	-824,
	536,
	-817,
	646,
	-413,
	49,
	-341,
	177,
	-453,
	526,
	-482,
	589,
	-71,
	339,
	-657,
	264,
	-244,
	295,
	-237,
	315,
	-387,
	569,
	-506,
	-9,
	-377,
	14,
	-160,
	661,
	-216,
	40,
	-308,
	-46,
	95,
	214,
	-242,
	167,
	-86,
	192,
	-56,
	27,
	-76,
	31,
	36,
	309,
	-106,
	-182,
	-113,
	74,
	-441,
	-22,
	23,
	139,
	81,
	-11,
	44,
	15,
	-87,
	-137,
	-118,
	-207,
	-158,
	-58,
	272,
	-92,
	-156,
	-441,
	8,
	-136,
	128,
	-221,
	101,
	-218,
	40,
	-197,
	-76,
	-456,
	9,
	-445,
	33,
	-423,
	226,
	60,
	73,
	-222,
	156,
	-399,
	280,
	-318,
	245,
	-341,
	166,
	-499,
	339,
	-190,
	327,
	-219,
	325,
	-137,
	-89,
	-596,
	100,
	-627,
	144,
	-677,
	487,
	28,
	252,
	-391,
	214,
	-41,
	282,
	-28,
	99,
	-286,
	331,
	49,
	459,
	-388,
	565,
	-369,
	436,
	28,
	336,
	-9,
	397,
	-167,
	618,
	34,
	596,
	-17,
	561,
	-140,
	299,
	79,
	522,
	125,
	203,
	2,
	244,
	288,
	255,
	211,
	175,
	82,
	596,
	187,
	517,
	108,
	381,
	255,
	365,
	297,
	497,
	352,
	327,
	-82,
	25,
	210,
	371,
	245,
	261,
	3,
	545,
	449,
	140,
	294,
	44,
	295,
	212,
	347,
	244,
	494,
	331,
	528,
	201,
	307,
	349,
	411,
	613,
	284,
	614,
	413,
	464,
	322,
	624,
	397,
	97,
	200,
	-160,
	384,
	149,
	362,
	495,
	525,
	269,
	585,
	33,
	491,
	-121,
	433,
	427,
	611,
	498,
	516,
	171,
	443,
	497,
	666,
	440,
	275,
	566,
	575,
	146,
	639,
	155,
	670,
	-33,
	173,
	212,
	696,
	-166,
	601,
	-191,
	695,
	-489,
	503,
	175,
	742,
	214,
	476,
	372,
	1083,
	578,
	530,
	586,
	777,
	425,
	874,
	315,
	841,
	374,
	848,
	-165,
	565,
	35,
	991,
	-39,
	1062,
	329,
	712,
	786,
	840,
	645,
	795,
	661,
	676,
	571,
	918,
	632,
	1079,
	673,
	817,
	318,
	388,
	874,
	1012,
	564,
	848,
	880,
	620,
	557,
	479,
	671,
	453,
	692,
	468,
	840,
	642,
	844,
	645,
	506,
	428,
	897,
	567,
	837,
	387,
	962,
	499,
	691,
	561,
	939,
	926,
	783,
	296,
	790,
	268,
	1028,
	530,
	874,
	329,
	548,
	143,
	675,
	291,
	503,
	66,
	1041,
	359,
	786,
	97,
	805,
	33,
	837,
	470,
	511,
	49,
	1092,
	327,
	1174,
	323,
	3,
	242,
	872,
	474,
	689,
	429,
	1329,
	678,
	1042,
	620,
	1109,
	664,
	321,
	193,
	889,
	950,
	1153,
	874,
	893,
	635,
	877,
	862,
	948,
	913,
	1293,
	665,
	1320,
	639,
	997,
	793,
	1402,
	1030,
	1176,
	1012,
	1110,
	959,
	1410,
	925,
	1403,
	915,
	543,
	862,
	1116,
	1222,
	835,
	1190,
	835,
	1190,
	959,
	1148,
	1147,
	1376,
	1300,
	1193,
	1415,
	1231,
	1335,
	1341,
	746,
	1092,
	1711,
	1283,
	1389,
	1073,
	1334,
	1566,
	1153,
	1475,
	1645,
	1137,
	1825,
	1220,
	1056,
	1382,
	1521,
	1730,
	1632,
	1545,
	1620,
	1542,
	855,
	1596,
	865,
	1667,
	693,
	885,
	1716,
	1519,
	1167,
	1296,
	2209,
	1760,
	1952,
	1493,
	2020,
	1482,
	1534,
	1866,
	1694,
	2008,
	1566,
	748,
	1761,
	825,
	294,
	1392,
	1084,
	2058,
	621,
	1315,
	365,
	1287,
	198,
	1028,
	488,
	1408,
	249,
	403,
	1014,
	1561,
	324,
	363,
	1645,
	1044,
	193,
	367,
	2034,
	1859,
	-251,
	579,
	750,
	994,
	-243,
	30,
	1325,
	879,
	-28,
	-169,
	624,
	917,
	-453,
	159,
	186,
	1370,
	-614,
	6,
	537,
	392,
	-94,
	-291,
	781,
	229,
	-128,
	-298,
	245,
	491,
	-701,
	-648,
	972,
	789,
	-501,
	-640,
	178,
	255,
	-365,
	-390,
	-255,
	317,
	-958,
	-294,
	-191,
	228,
	-775,
	-447,
	157,
	-237,
	-657,
	-720,
	-407,
	92,
	-117,
	-611,
	334,
	-230,
	-679,
	-1084,
	-144,
	-317,
	-901,
	-861,
	-738,
	-360,
	-85,
	-727,
	-90,
	-787,
	100,
	-22,
	-391,
	-263,
	-56,
	-73,
	-337,
	-754,
	5,
	-189,
	-706,
	-624,
	89,
	-344,
	-135,
	-1113,
	-353,
	-237,
	-684,
	-1135,
	-275,
	-1102,
	-269,
	-1203,
	152,
	145,
	-722,
	-1232,
	49,
	80,
	-1248,
	-776,
	-248,
	391,
	-732,
	-547,
	469,
	218,
	-255,
	-864,
	69,
	366,
	-166,
	-485,
	-688,
	191,
	-1212,
	-1196,
	-170,
	-169,
	-1308,
	-1631,
	321,
	470,
	-1419,
	-1243,
	-64,
	272,
	-1361,
	-248,
	492,
	565,
	-721,
	-609,
	195,
	485,
	-573,
	-133,
	427,
	202,
	-171,
	-118,
	199,
	575,
	2,
	-31,
	694,
	755,
	-1366,
	-39,
	552,
	557,
	-489,
	271,
	680,
	537,
	13,
	-453,
	855,
	954,
	-133,
	-52,
	-81,
	738,
	-1169,
	637,
	1055,
	1059,
	-95,
	676,
	1259,
	1081,
	489,
	305,
	-449,
	954,
	-534,
	996,
	-969,
	866,
	-1058,
	1059,
	-1294,
	618,
	-1416,
	617,
	-458,
	1366,
	-159,
	1821,
	-774,
	-528,
	-14,
	1110,
	-1202,
	-901,
	-772,
	433,
	-1256,
	-1255,
	-1011,
	-302,
	-602,
	-585,
	-759,
	-1618,
	-760,
	-1549,
	-840,
	-1921,
	-816,
	-539,
	-1769,
	-2235,
	-227,
	-36,
	-2034,
	-1831,
	-2107,
	-1126,
	-2471,
	-1816,
	-1470,
	252,
	-2701,
	-415,
	-571,
	-467,
	1509,
	1554,
	2180,
	1975,
	2326,
	2020
};

/* 4th LSF quantizer (MR122) */
__device__ static const Word32 dico4_lsf_5[DICO4_SIZE_5 * 4] =
{
	-1857,
	-1681,
	-1857,
	-1755,
	-2056,
	-1150,
	-2134,
	-1654,
	-1619,
	-1099,
	-1704,
	-1131,
	-1345,
	-1608,
	-1359,
	-1638,
	-1338,
	-1293,
	-1325,
	-1265,
	-1664,
	-1649,
	-1487,
	-851,
	-1346,
	-1832,
	-1413,
	-2188,
	-1282,
	-681,
	-1785,
	-1649,
	-966,
	-1082,
	-1183,
	-1676,
	-1054,
	-1073,
	-1142,
	-1158,
	-1207,
	-744,
	-1274,
	-997,
	-934,
	-1383,
	-927,
	-1416,
	-1010,
	-1305,
	-783,
	-955,
	-1049,
	-900,
	-993,
	-817,
	-737,
	-823,
	-972,
	-1189,
	-738,
	-1094,
	-738,
	-1154,
	-784,
	-801,
	-810,
	-786,
	-892,
	-520,
	-1000,
	-818,
	-644,
	-965,
	-577,
	-882,
	-541,
	-694,
	-671,
	-917,
	-595,
	-642,
	-646,
	-615,
	-956,
	-621,
	-925,
	-515,
	-727,
	-483,
	-815,
	-485,
	-840,
	-578,
	-440,
	-713,
	-578,
	-325,
	-657,
	-670,
	-386,
	-570,
	-441,
	-666,
	-514,
	-787,
	-392,
	-529,
	-522,
	-453,
	-487,
	-423,
	-616,
	-585,
	-617,
	-157,
	-662,
	-268,
	-680,
	-348,
	-322,
	-323,
	-632,
	-444,
	-304,
	-430,
	-332,
	-458,
	-277,
	-468,
	-659,
	-793,
	-319,
	-636,
	-227,
	-554,
	-373,
	-347,
	-334,
	-210,
	-456,
	-192,
	-530,
	-242,
	-216,
	-198,
	-366,
	-370,
	-338,
	-161,
	-409,
	-748,
	-107,
	-380,
	-294,
	-643,
	-223,
	-665,
	-234,
	-741,
	-141,
	-496,
	-130,
	-510,
	-139,
	-327,
	-172,
	-305,
	-306,
	-580,
	-164,
	-263,
	-262,
	-172,
	-67,
	-402,
	31,
	-366,
	-10,
	-436,
	-86,
	-527,
	71,
	-377,
	-22,
	-609,
	-12,
	-678,
	-67,
	-319,
	63,
	-191,
	35,
	-181,
	-39,
	-242,
	126,
	-167,
	-140,
	-544,
	155,
	-297,
	174,
	-297,
	38,
	-8,
	117,
	-380,
	197,
	-452,
	240,
	-522,
	223,
	-103,
	110,
	-187,
	87,
	-155,
	169,
	-47,
	157,
	26,
	-83,
	-100,
	128,
	80,
	209,
	-62,
	6,
	7,
	22,
	5,
	318,
	-20,
	248,
	-45,
	-200,
	-63,
	156,
	-69,
	250,
	-183,
	369,
	-126,
	-113,
	-76,
	-142,
	-122,
	-64,
	-254,
	-31,
	35,
	-177,
	-71,
	-7,
	171,
	93,
	27,
	108,
	212,
	-330,
	-209,
	-123,
	-70,
	-279,
	95,
	-96,
	20,
	-188,
	-61,
	-314,
	87,
	-300,
	-78,
	-354,
	-134,
	11,
	122,
	-140,
	122,
	-275,
	152,
	-293,
	140,
	-82,
	138,
	-321,
	-111,
	-480,
	-156,
	-359,
	76,
	-254,
	-40,
	-635,
	-96,
	-522,
	79,
	-507,
	8,
	-268,
	303,
	-539,
	68,
	-446,
	61,
	-522,
	306,
	111,
	189,
	-435,
	122,
	-379,
	166,
	-571,
	-398,
	-632,
	-74,
	-747,
	-95,
	-455,
	194,
	-952,
	83,
	-798,
	192,
	-755,
	192,
	-781,
	-162,
	-619,
	234,
	-663,
	-297,
	-488,
	-109,
	-964,
	-132,
	-838,
	-68,
	-843,
	58,
	-1112,
	-86,
	-805,
	-299,
	-944,
	-253,
	-778,
	-50,
	-965,
	-549,
	-352,
	-98,
	-992,
	-343,
	-1117,
	-315,
	-1117,
	-307,
	-1155,
	-374,
	-637,
	-230,
	-1166,
	-43,
	-1299,
	-100,
	-925,
	-393,
	-1274,
	-600,
	-689,
	-130,
	-1479,
	-312,
	-1321,
	-254,
	-1464,
	-442,
	-1292,
	-613,
	-1261,
	-503,
	-1501,
	-368,
	-1322,
	26,
	-1432,
	-66,
	-1743,
	-161,
	-1644,
	-467,
	-1760,
	-548,
	-1393,
	-568,
	-1556,
	-871,
	-1495,
	-1034,
	-1387,
	-571,
	-1917,
	-528,
	-1783,
	-123,
	-1897,
	-231,
	-2054,
	-323,
	-2052,
	-906,
	-1976,
	-567,
	-1917,
	-620,
	-2047,
	-989,
	-1077,
	-370,
	-2031,
	-704,
	-2355,
	-749,
	-2740,
	-1089,
	-1909,
	159,
	-2012,
	248,
	-626,
	-123,
	-2339,
	-962,
	-669,
	-408,
	-1379,
	-1174,
	-452,
	-364,
	-1044,
	-735,
	-132,
	183,
	-1620,
	-752,
	-547,
	-307,
	-777,
	-1261,
	-98,
	41,
	-880,
	-1091,
	-257,
	97,
	-1602,
	-1833,
	31,
	-26,
	-644,
	-561,
	-180,
	-546,
	-385,
	-1095,
	-410,
	-802,
	-414,
	-827,
	-457,
	-970,
	-490,
	-1109,
	-215,
	-916,
	-144,
	-937,
	-493,
	-1269,
	-517,
	-1507,
	181,
	101,
	-332,
	-889,
	-836,
	-937,
	-559,
	-429,
	-629,
	-547,
	-183,
	-337,
	-545,
	-82,
	-250,
	-286,
	5,
	-132,
	-348,
	-252,
	-293,
	-472,
	-158,
	100,
	-29,
	197,
	-236,
	-424,
	-861,
	-213,
	-140,
	-7,
	-427,
	-443,
	187,
	-97,
	-684,
	-736,
	-293,
	258,
	-368,
	-152,
	-150,
	392,
	-609,
	175,
	-142,
	299,
	-138,
	152,
	-119,
	329,
	-486,
	-52,
	293,
	198,
	-183,
	117,
	175,
	331,
	-58,
	-274,
	231,
	300,
	-288,
	330,
	-305,
	372,
	-111,
	409,
	-9,
	423,
	83,
	256,
	67,
	367,
	-19,
	248,
	91,
	113,
	-35,
	406,
	-191,
	154,
	238,
	296,
	5,
	197,
	141,
	221,
	313,
	198,
	211,
	421,
	244,
	334,
	88,
	426,
	-243,
	454,
	202,
	552,
	-5,
	403,
	291,
	185,
	219,
	301,
	251,
	138,
	128,
	69,
	197,
	288,
	-140,
	-61,
	188,
	361,
	197,
	598,
	442,
	273,
	290,
	143,
	472,
	482,
	157,
	370,
	415,
	321,
	372,
	385,
	402,
	552,
	155,
	24,
	550,
	263,
	-11,
	21,
	360,
	227,
	147,
	-254,
	424,
	97,
	366,
	-13,
	375,
	141,
	449,
	232,
	396,
	507,
	474,
	272,
	701,
	324,
	362,
	-47,
	587,
	148,
	543,
	69,
	400,
	-51,
	561,
	59,
	220,
	-10,
	352,
	147,
	206,
	211,
	653,
	185,
	563,
	297,
	565,
	284,
	594,
	121,
	766,
	192,
	398,
	118,
	642,
	434,
	233,
	264,
	481,
	467,
	129,
	-165,
	699,
	239,
	90,
	26,
	342,
	474,
	-55,
	27,
	388,
	94,
	-172,
	0,
	725,
	379,
	-60,
	337,
	370,
	465,
	95,
	319,
	806,
	595,
	78,
	260,
	497,
	851,
	210,
	560,
	458,
	574,
	-464,
	202,
	497,
	625,
	-202,
	152,
	48,
	712,
	-20,
	566,
	100,
	715,
	455,
	468,
	411,
	605,
	319,
	646,
	195,
	615,
	401,
	538,
	680,
	739,
	201,
	667,
	434,
	954,
	454,
	425,
	646,
	491,
	606,
	681,
	416,
	508,
	497,
	822,
	426,
	815,
	660,
	647,
	628,
	716,
	697,
	466,
	618,
	457,
	685,
	460,
	365,
	309,
	721,
	567,
	836,
	601,
	609,
	300,
	825,
	459,
	943,
	687,
	681,
	533,
	915,
	598,
	591,
	243,
	876,
	451,
	874,
	420,
	786,
	317,
	732,
	220,
	922,
	317,
	1108,
	367,
	531,
	466,
	1028,
	649,
	1053,
	615,
	1034,
	553,
	829,
	602,
	1021,
	799,
	927,
	803,
	878,
	763,
	799,
	496,
	1373,
	773,
	585,
	770,
	803,
	930,
	1099,
	793,
	1222,
	862,
	1209,
	895,
	1025,
	727,
	772,
	845,
	1172,
	1115,
	867,
	1021,
	830,
	1013,
	841,
	910,
	506,
	703,
	1239,
	1077,
	620,
	819,
	1196,
	1083,
	1155,
	1081,
	1142,
	907,
	1547,
	1121,
	1309,
	648,
	1343,
	612,
	1484,
	988,
	1479,
	937,
	985,
	1328,
	955,
	1341,
	429,
	910,
	841,
	1338,
	564,
	1179,
	412,
	1156,
	1427,
	1320,
	1434,
	1330,
	640,
	760,
	1726,
	1410,
	190,
	555,
	1073,
	1005,
	426,
	257,
	839,
	980,
	235,
	231,
	1520,
	1167,
	109,
	293,
	1014,
	1569,
	305,
	142,
	1148,
	539,
	-291,
	-108,
	1213,
	972,
	22,
	-216,
	667,
	828,
	-482,
	438,
	453,
	1431,
	-581,
	-422,
	789,
	387,
	-358,
	-454,
	174,
	780,
	-36,
	-372,
	390,
	-134,
	-629,
	160,
	-306,
	751,
	-1258,
	-331,
	177,
	522,
	-248,
	574,
	-251,
	639,
	-531,
	407,
	-596,
	394,
	-419,
	789,
	-617,
	801,
	-986,
	399,
	-857,
	727,
	-7,
	518,
	-703,
	310,
	-1143,
	-24,
	-1002,
	287,
	-960,
	363,
	-1299,
	312,
	-1534,
	245,
	-1557,
	305,
	28,
	153,
	-859,
	-175,
	-33,
	332,
	-1398,
	-154,
	212,
	410,
	-593,
	-197,
	-1092,
	-704,
	-904,
	-65,
	282,
	367,
	-918,
	-686,
	345,
	93,
	-258,
	-357,
	696,
	644,
	-693,
	-28,
	448,
	493,
	-273,
	193,
	527,
	546,
	-243,
	-513,
	384,
	-136,
	273,
	-353,
	512,
	-142,
	537,
	-198,
	941,
	750,
	83,
	248,
	578,
	861,
	-56,
	592,
	842,
	44,
	892,
	24,
	33,
	890,
	-16,
	982,
	831,
	1398,
	1535,
	1898,
	1716,
	1376,
	1948,
	1465
};

/* 5th LSF quantizer (MR122) */
__device__ static const Word32 dico5_lsf_5[DICO5_SIZE_5 * 4] =
{
	-1002,
	-929,
	-1096,
	-1203,
	-641,
	-931,
	-604,
	-961,
	-779,
	-673,
	-835,
	-788,
	-416,
	-664,
	-458,
	-766,
	-652,
	-521,
	-662,
	-495,
	-1023,
	-509,
	-1023,
	-428,
	-444,
	-552,
	-368,
	-449,
	-479,
	-211,
	-1054,
	-903,
	-316,
	-249,
	-569,
	-591,
	-569,
	-275,
	-541,
	-191,
	-716,
	-188,
	-842,
	-264,
	-333,
	-248,
	-318,
	-228,
	-275,
	1,
	-567,
	-228,
	-115,
	-221,
	-238,
	-374,
	-197,
	-507,
	-222,
	-579,
	-258,
	-432,
	-61,
	-244,
	-345,
	2,
	-338,
	39,
	-215,
	-169,
	-58,
	0,
	-56,
	-6,
	-203,
	-131,
	1,
	-186,
	-5,
	-211,
	6,
	-380,
	11,
	-418,
	-116,
	131,
	-134,
	113,
	89,
	-4,
	71,
	-2,
	-19,
	-192,
	262,
	24,
	189,
	151,
	-133,
	-109,
	186,
	-153,
	166,
	-219,
	37,
	139,
	193,
	171,
	337,
	124,
	158,
	-61,
	141,
	226,
	-13,
	190,
	231,
	34,
	354,
	109,
	316,
	201,
	244,
	164,
	330,
	-85,
	390,
	-84,
	254,
	327,
	257,
	335,
	491,
	147,
	476,
	105,
	54,
	77,
	437,
	370,
	421,
	314,
	449,
	342,
	329,
	126,
	673,
	292,
	571,
	388,
	243,
	193,
	653,
	320,
	621,
	280,
	194,
	380,
	517,
	581,
	45,
	323,
	111,
	422,
	489,
	395,
	734,
	534,
	622,
	546,
	486,
	502,
	318,
	572,
	189,
	550,
	385,
	422,
	-157,
	153,
	-125,
	382,
	-197,
	386,
	-263,
	334,
	228,
	697,
	-188,
	1,
	51,
	297,
	-507,
	213,
	-376,
	397,
	-24,
	255,
	-547,
	89,
	-502,
	-94,
	387,
	179,
	-620,
	68,
	-684,
	112,
	-642,
	-350,
	-260,
	172,
	-438,
	-324,
	264,
	648,
	-964,
	-4,
	-1121,
	7,
	-134,
	134,
	-1133,
	-306,
	143,
	96,
	-420,
	-497,
	-1221,
	-350,
	-1527,
	-685,
	-161,
	72,
	873,
	691,
	732,
	283,
	921,
	353,
	334,
	475,
	1095,
	821,
	864,
	524,
	843,
	497,
	714,
	711,
	788,
	750,
	1076,
	714,
	1204,
	753
};



/* Scaling factors for the lsp variability operation */
__device__ static const Word16 lsf_hist_mean_scale[M] =
{
	20000,
	20000,
	20000,
	20000,
	20000,
	18000,
	16384,
	8192,
	0,
	0
};

/*
* The tables contains the following data:
*
* g_pitch        (Q14),
* g_fac          (Q12), (g_code = g_code0*g_fac),
* qua_ener_MR122 (Q10), (log2(g_fac))
* qua_ener       (Q10)  (20*log10(g_fac))
*
* The log2() and log10() values are calculated on the fixed point value
* (g_fac Q12) and not on the original floating point value of g_fac
* to make the quantizer/MA predictdor use corresponding values.
*/

#define MR475_VQ_SIZE 256

/* The table contains the following data:
*
* g_pitch(0)        (Q14)  for sub-
* g_fac(0)          (Q12)  frame 0 and 2
* g_pitch(1)        (Q14)  for sub-
* g_fac(2)          (Q12)  frame 1 and 3
*
*/
__device__ static const Word32 table_gain_MR475[MR475_VQ_SIZE * 4] =
{
	/*
	* g_pit(0),
	* g_fac(0),
	* g_pit(1),
	* g_fac(1)
	*/ 812,
	128,
	542,
	140,
	2873,
	1135,
	2266,
	3402,
	2067,
	563,
	12677,
	647,
	4132,
	1798,
	5601,
	5285,
	7689,
	374,
	3735,
	441,
	10912,
	2638,
	11807,
	2494,
	20490,
	797,
	5218,
	675,
	6724,
	8354,
	5282,
	1696,
	1488,
	428,
	5882,
	452,
	5332,
	4072,
	3583,
	1268,
	2469,
	901,
	15894,
	1005,
	14982,
	3271,
	10331,
	4858,
	3635,
	2021,
	2596,
	835,
	12360,
	4892,
	12206,
	1704,
	13432,
	1604,
	9118,
	2341,
	3968,
	1538,
	5479,
	9936,
	3795,
	417,
	1359,
	414,
	3640,
	1569,
	7995,
	3541,
	11405,
	645,
	8552,
	635,
	4056,
	1377,
	16608,
	6124,
	11420,
	700,
	2007,
	607,
	12415,
	1578,
	11119,
	4654,
	13680,
	1708,
	11990,
	1229,
	7996,
	7297,
	13231,
	5715,
	2428,
	1159,
	2073,
	1941,
	6218,
	6121,
	3546,
	1804,
	8925,
	1802,
	8679,
	1580,
	13935,
	3576,
	13313,
	6237,
	6142,
	1130,
	5994,
	1734,
	14141,
	4662,
	11271,
	3321,
	12226,
	1551,
	13931,
	3015,
	5081,
	10464,
	9444,
	6706,
	1689,
	683,
	1436,
	1306,
	7212,
	3933,
	4082,
	2713,
	7793,
	704,
	15070,
	802,
	6299,
	5212,
	4337,
	5357,
	6676,
	541,
	6062,
	626,
	13651,
	3700,
	11498,
	2408,
	16156,
	716,
	12177,
	751,
	8065,
	11489,
	6314,
	2256,
	4466,
	496,
	7293,
	523,
	10213,
	3833,
	8394,
	3037,
	8403,
	966,
	14228,
	1880,
	8703,
	5409,
	16395,
	4863,
	7420,
	1979,
	6089,
	1230,
	9371,
	4398,
	14558,
	3363,
	13559,
	2873,
	13163,
	1465,
	5534,
	1678,
	13138,
	14771,
	7338,
	600,
	1318,
	548,
	4252,
	3539,
	10044,
	2364,
	10587,
	622,
	13088,
	669,
	14126,
	3526,
	5039,
	9784,
	15338,
	619,
	3115,
	590,
	16442,
	3013,
	15542,
	4168,
	15537,
	1611,
	15405,
	1228,
	16023,
	9299,
	7534,
	4976,
	1990,
	1213,
	11447,
	1157,
	12512,
	5519,
	9475,
	2644,
	7716,
	2034,
	13280,
	2239,
	16011,
	5093,
	8066,
	6761,
	10083,
	1413,
	5002,
	2347,
	12523,
	5975,
	15126,
	2899,
	18264,
	2289,
	15827,
	2527,
	16265,
	10254,
	14651,
	11319,
	1797,
	337,
	3115,
	397,
	3510,
	2928,
	4592,
	2670,
	7519,
	628,
	11415,
	656,
	5946,
	2435,
	6544,
	7367,
	8238,
	829,
	4000,
	863,
	10032,
	2492,
	16057,
	3551,
	18204,
	1054,
	6103,
	1454,
	5884,
	7900,
	18752,
	3468,
	1864,
	544,
	9198,
	683,
	11623,
	4160,
	4594,
	1644,
	3158,
	1157,
	15953,
	2560,
	12349,
	3733,
	17420,
	5260,
	6106,
	2004,
	2917,
	1742,
	16467,
	5257,
	16787,
	1680,
	17205,
	1759,
	4773,
	3231,
	7386,
	6035,
	14342,
	10012,
	4035,
	442,
	4194,
	458,
	9214,
	2242,
	7427,
	4217,
	12860,
	801,
	11186,
	825,
	12648,
	2084,
	12956,
	6554,
	9505,
	996,
	6629,
	985,
	10537,
	2502,
	15289,
	5006,
	12602,
	2055,
	15484,
	1653,
	16194,
	6921,
	14231,
	5790,
	2626,
	828,
	5615,
	1686,
	13663,
	5778,
	3668,
	1554,
	11313,
	2633,
	9770,
	1459,
	14003,
	4733,
	15897,
	6291,
	6278,
	1870,
	7910,
	2285,
	16978,
	4571,
	16576,
	3849,
	15248,
	2311,
	16023,
	3244,
	14459,
	17808,
	11847,
	2763,
	1981,
	1407,
	1400,
	876,
	4335,
	3547,
	4391,
	4210,
	5405,
	680,
	17461,
	781,
	6501,
	5118,
	8091,
	7677,
	7355,
	794,
	8333,
	1182,
	15041,
	3160,
	14928,
	3039,
	20421,
	880,
	14545,
	852,
	12337,
	14708,
	6904,
	1920,
	4225,
	933,
	8218,
	1087,
	10659,
	4084,
	10082,
	4533,
	2735,
	840,
	20657,
	1081,
	16711,
	5966,
	15873,
	4578,
	10871,
	2574,
	3773,
	1166,
	14519,
	4044,
	20699,
	2627,
	15219,
	2734,
	15274,
	2186,
	6257,
	3226,
	13125,
	19480,
	7196,
	930,
	2462,
	1618,
	4515,
	3092,
	13852,
	4277,
	10460,
	833,
	17339,
	810,
	16891,
	2289,
	15546,
	8217,
	13603,
	1684,
	3197,
	1834,
	15948,
	2820,
	15812,
	5327,
	17006,
	2438,
	16788,
	1326,
	15671,
	8156,
	11726,
	8556,
	3762,
	2053,
	9563,
	1317,
	13561,
	6790,
	12227,
	1936,
	8180,
	3550,
	13287,
	1778,
	16299,
	6599,
	16291,
	7758,
	8521,
	2551,
	7225,
	2645,
	18269,
	7489,
	16885,
	2248,
	17882,
	2884,
	17265,
	3328,
	9417,
	20162,
	11042,
	8320,
	1286,
	620,
	1431,
	583,
	5993,
	2289,
	3978,
	3626,
	5144,
	752,
	13409,
	830,
	5553,
	2860,
	11764,
	5908,
	10737,
	560,
	5446,
	564,
	13321,
	3008,
	11946,
	3683,
	19887,
	798,
	9825,
	728,
	13663,
	8748,
	7391,
	3053,
	2515,
	778,
	6050,
	833,
	6469,
	5074,
	8305,
	2463,
	6141,
	1865,
	15308,
	1262,
	14408,
	4547,
	13663,
	4515,
	3137,
	2983,
	2479,
	1259,
	15088,
	4647,
	15382,
	2607,
	14492,
	2392,
	12462,
	2537,
	7539,
	2949,
	12909,
	12060,
	5468,
	684,
	3141,
	722,
	5081,
	1274,
	12732,
	4200,
	15302,
	681,
	7819,
	592,
	6534,
	2021,
	16478,
	8737,
	13364,
	882,
	5397,
	899,
	14656,
	2178,
	14741,
	4227,
	14270,
	1298,
	13929,
	2029,
	15477,
	7482,
	15815,
	4572,
	2521,
	2013,
	5062,
	1804,
	5159,
	6582,
	7130,
	3597,
	10920,
	1611,
	11729,
	1708,
	16903,
	3455,
	16268,
	6640,
	9306,
	1007,
	9369,
	2106,
	19182,
	5037,
	12441,
	4269,
	15919,
	1332,
	15357,
	3512,
	11898,
	14141,
	16101,
	6854,
	2010,
	737,
	3779,
	861,
	11454,
	2880,
	3564,
	3540,
	9057,
	1241,
	12391,
	896,
	8546,
	4629,
	11561,
	5776,
	8129,
	589,
	8218,
	588,
	18728,
	3755,
	12973,
	3149,
	15729,
	758,
	16634,
	754,
	15222,
	11138,
	15871,
	2208,
	4673,
	610,
	10218,
	678,
	15257,
	4146,
	5729,
	3327,
	8377,
	1670,
	19862,
	2321,
	15450,
	5511,
	14054,
	5481,
	5728,
	2888,
	7580,
	1346,
	14384,
	5325,
	16236,
	3950,
	15118,
	3744,
	15306,
	1435,
	14597,
	4070,
	12301,
	15696,
	7617,
	1699,
	2170,
	884,
	4459,
	4567,
	18094,
	3306,
	12742,
	815,
	14926,
	907,
	15016,
	4281,
	15518,
	8368,
	17994,
	1087,
	2358,
	865,
	16281,
	3787,
	15679,
	4596,
	16356,
	1534,
	16584,
	2210,
	16833,
	9697,
	15929,
	4513,
	3277,
	1085,
	9643,
	2187,
	11973,
	6068,
	9199,
	4462,
	8955,
	1629,
	10289,
	3062,
	16481,
	5155,
	15466,
	7066,
	13678,
	2543,
	5273,
	2277,
	16746,
	6213,
	16655,
	3408,
	20304,
	3363,
	18688,
	1985,
	14172,
	12867,
	15154,
	15703,
	4473,
	1020,
	1681,
	886,
	4311,
	4301,
	8952,
	3657,
	5893,
	1147,
	11647,
	1452,
	15886,
	2227,
	4582,
	6644,
	6929,
	1205,
	6220,
	799,
	12415,
	3409,
	15968,
	3877,
	19859,
	2109,
	9689,
	2141,
	14742,
	8830,
	14480,
	2599,
	1817,
	1238,
	7771,
	813,
	19079,
	4410,
	5554,
	2064,
	3687,
	2844,
	17435,
	2256,
	16697,
	4486,
	16199,
	5388,
	8028,
	2763,
	3405,
	2119,
	17426,
	5477,
	13698,
	2786,
	19879,
	2720,
	9098,
	3880,
	18172,
	4833,
	17336,
	12207,
	5116,
	996,
	4935,
	988,
	9888,
	3081,
	6014,
	5371,
	15881,
	1667,
	8405,
	1183,
	15087,
	2366,
	19777,
	7002,
	11963,
	1562,
	7279,
	1128,
	16859,
	1532,
	15762,
	5381,
	14708,
	2065,
	20105,
	2155,
	17158,
	8245,
	17911,
	6318,
	5467,
	1504,
	4100,
	2574,
	17421,
	6810,
	5673,
	2888,
	16636,
	3382,
	8975,
	1831,
	20159,
	4737,
	19550,
	7294,
	6658,
	2781,
	11472,
	3321,
	19397,
	5054,
	18878,
	4722,
	16439,
	2373,
	20430,
	4386,
	11353,
	26526,
	11593,
	3068,
	2866,
	1566,
	5108,
	1070,
	9614,
	4915,
	4939,
	3536,
	7541,
	878,
	20717,
	851,
	6938,
	4395,
	16799,
	7733,
	10137,
	1019,
	9845,
	964,
	15494,
	3955,
	15459,
	3430,
	18863,
	982,
	20120,
	963,
	16876,
	12887,
	14334,
	4200,
	6599,
	1220,
	9222,
	814,
	16942,
	5134,
	5661,
	4898,
	5488,
	1798,
	20258,
	3962,
	17005,
	6178,
	17929,
	5929,
	9365,
	3420,
	7474,
	1971,
	19537,
	5177,
	19003,
	3006,
	16454,
	3788,
	16070,
	2367,
	8664,
	2743,
	9445,
	26358,
	10856,
	1287,
	3555,
	1009,
	5606,
	3622,
	19453,
	5512,
	12453,
	797,
	20634,
	911,
	15427,
	3066,
	17037,
	10275,
	18883,
	2633,
	3913,
	1268,
	19519,
	3371,
	18052,
	5230,
	19291,
	1678,
	19508,
	3172,
	18072,
	10754,
	16625,
	6845,
	3134,
	2298,
	10869,
	2437,
	15580,
	6913,
	12597,
	3381,
	11116,
	3297,
	16762,
	2424,
	18853,
	6715,
	17171,
	9887,
	12743,
	2605,
	8937,
	3140,
	19033,
	7764,
	18347,
	3880,
	20475,
	3682,
	19602,
	3380,
	13044,
	19373,
	10526,
	23124
};


/* table used in 'high' rates: MR67 MR74 */
#define VQ_SIZE_HIGHRATES 128
__device__ static const Word32 table_gain_highrates[VQ_SIZE_HIGHRATES * 4] =
{
	/*
	* Note: every 4th value (qua_ener) contains the original values from IS641
	* to ensure bit-exactness; however, they are not exactly the
	* rounded value of (20*log10(g_fac))
	*/  /*
	* g_pit,
	* g_fac,
	* qua_ener_MR122,
	* qua_ener
	*/ 577,
	662,
	-2692,
	-16214,
	806,
	1836,
	-1185,
	-7135,
	3109,
	1052,
	-2008,
	-12086,
	4181,
	1387,
	-1600,
	-9629,
	2373,
	1425,
	-1560,
	-9394,
	3248,
	1985,
	-1070,
	-6442,
	1827,
	2320,
	-840,
	-5056,
	941,
	3314,
	-313,
	-1885,
	2351,
	2977,
	-471,
	-2838,
	3616,
	2420,
	-777,
	-4681,
	3451,
	3096,
	-414,
	-2490,
	2955,
	4301,
	72,
	434,
	1848,
	4500,
	139,
	836,
	3884,
	5416,
	413,
	2484,
	1187,
	7210,
	835,
	5030,
	3083,
	9000,
	1163,
	7002,
	7384,
	883,
	-2267,
	-13647,
	5962,
	1506,
	-1478,
	-8900,
	5155,
	2134,
	-963,
	-5800,
	7944,
	2009,
	-1052,
	-6335,
	6507,
	2250,
	-885,
	-5327,
	7670,
	2752,
	-588,
	-3537,
	5952,
	3016,
	-452,
	-2724,
	4898,
	3764,
	-125,
	-751,
	6989,
	3588,
	-196,
	-1177,
	8174,
	3978,
	-43,
	-260,
	6064,
	4404,
	107,
	645,
	7709,
	5087,
	320,
	1928,
	5523,
	6021,
	569,
	3426,
	7769,
	7126,
	818,
	4926,
	6060,
	7938,
	977,
	5885,
	5594,
	11487,
	1523,
	9172,
	10581,
	1356,
	-1633,
	-9831,
	9049,
	1597,
	-1391,
	-8380,
	9794,
	2035,
	-1033,
	-6220,
	8946,
	2415,
	-780,
	-4700,
	10296,
	2584,
	-681,
	-4099,
	9407,
	2734,
	-597,
	-3595,
	8700,
	3218,
	-356,
	-2144,
	9757,
	3395,
	-277,
	-1669,
	10177,
	3892,
	-75,
	-454,
	9170,
	4528,
	148,
	891,
	10152,
	5004,
	296,
	1781,
	9114,
	5735,
	497,
	2993,
	10500,
	6266,
	628,
	3782,
	10110,
	7631,
	919,
	5534,
	8844,
	8727,
	1117,
	6728,
	8956,
	12496,
	1648,
	9921,
	12924,
	976,
	-2119,
	-12753,
	11435,
	1755,
	-1252,
	-7539,
	12138,
	2328,
	-835,
	-5024,
	11388,
	2368,
	-810,
	-4872,
	10700,
	3064,
	-429,
	-2580,
	12332,
	2861,
	-530,
	-3192,
	11722,
	3327,
	-307,
	-1848,
	11270,
	3700,
	-150,
	-904,
	10861,
	4413,
	110,
	663,
	12082,
	4533,
	150,
	902,
	11283,
	5205,
	354,
	2132,
	11960,
	6305,
	637,
	3837,
	11167,
	7534,
	900,
	5420,
	12128,
	8329,
	1049,
	6312,
	10969,
	10777,
	1429,
	8604,
	10300,
	17376,
	2135,
	12853,
	13899,
	1681,
	-1316,
	-7921,
	12580,
	2045,
	-1026,
	-6179,
	13265,
	2439,
	-766,
	-4610,
	14033,
	2989,
	-465,
	-2802,
	13452,
	3098,
	-413,
	-2482,
	12396,
	3658,
	-167,
	-1006,
	13510,
	3780,
	-119,
	-713,
	12880,
	4272,
	62,
	374,
	13533,
	4861,
	253,
	1523,
	12667,
	5457,
	424,
	2552,
	13854,
	6106,
	590,
	3551,
	13031,
	6483,
	678,
	4084,
	13557,
	7721,
	937,
	5639,
	12957,
	9311,
	1213,
	7304,
	13714,
	11551,
	1532,
	9221,
	12591,
	15206,
	1938,
	11667,
	15113,
	1540,
	-1445,
	-8700,
	15072,
	2333,
	-832,
	-5007,
	14527,
	2511,
	-723,
	-4352,
	14692,
	3199,
	-365,
	-2197,
	15382,
	3560,
	-207,
	-1247,
	14133,
	3960,
	-50,
	-300,
	15102,
	4236,
	50,
	298,
	14332,
	4824,
	242,
	1454,
	14846,
	5451,
	422,
	2542,
	15306,
	6083,
	584,
	3518,
	14329,
	6888,
	768,
	4623,
	15060,
	7689,
	930,
	5602,
	14406,
	9426,
	1231,
	7413,
	15387,
	9741,
	1280,
	7706,
	14824,
	14271,
	1844,
	11102,
	13600,
	24939,
	2669,
	16067,
	16396,
	1969,
	-1082,
	-6517,
	16817,
	2832,
	-545,
	-3283,
	15713,
	2843,
	-539,
	-3248,
	16104,
	3336,
	-303,
	-1825,
	16384,
	3963,
	-49,
	-294,
	16940,
	4579,
	165,
	992,
	15711,
	4599,
	171,
	1030,
	16222,
	5448,
	421,
	2537,
	16832,
	6382,
	655,
	3945,
	15745,
	7141,
	821,
	4944,
	16326,
	7469,
	888,
	5343,
	16611,
	8624,
	1100,
	6622,
	17028,
	10418,
	1379,
	8303,
	15905,
	11817,
	1565,
	9423,
	16878,
	14690,
	1887,
	11360,
	16515,
	20870,
	2406,
	14483,
	18142,
	2083,
	-999,
	-6013,
	19401,
	3178,
	-375,
	-2257,
	17508,
	3426,
	-264,
	-1589,
	20054,
	4027,
	-25,
	-151,
	18069,
	4249,
	54,
	326,
	18952,
	5066,
	314,
	1890,
	17711,
	5402,
	409,
	2461,
	19835,
	6192,
	610,
	3676,
	17950,
	7014,
	795,
	4784,
	21318,
	7877,
	966,
	5816,
	17910,
	9289,
	1210,
	7283,
	19144,
	9290,
	1210,
	7284,
	20517,
	11381,
	1510,
	9089,
	18075,
	14485,
	1866,
	11234,
	19999,
	17882,
	2177,
	13108,
	18842,
	32764,
	3072,
	18494
};

/* table used in 'low' rates: MR475, MR515, MR59 */
#define VQ_SIZE_LOWRATES 64
__device__ static const Word32 table_gain_lowrates[VQ_SIZE_LOWRATES * 4] =
{
	/*
	* g_pit,
	* g_fac,
	* qua_ener_MR122,
	* qua_ener
	*/ 10813,
	28753,
	2879,
	17333,
	20480,
	2785,
	-570,
	-3431,
	18841,
	6594,
	703,
	4235,
	6225,
	7413,
	876,
	5276,
	17203,
	10444,
	1383,
	8325,
	21626,
	1269,
	-1731,
	-10422,
	21135,
	4423,
	113,
	683,
	11304,
	1556,
	-1430,
	-8609,
	19005,
	12820,
	1686,
	10148,
	17367,
	2498,
	-731,
	-4398,
	17858,
	4833,
	244,
	1472,
	9994,
	2498,
	-731,
	-4398,
	17530,
	7864,
	964,
	5802,
	14254,
	1884,
	-1147,
	-6907,
	15892,
	3153,
	-387,
	-2327,
	6717,
	1802,
	-1213,
	-7303,
	18186,
	20193,
	2357,
	14189,
	18022,
	3031,
	-445,
	-2678,
	16711,
	5857,
	528,
	3181,
	8847,
	4014,
	-30,
	-180,
	15892,
	8970,
	1158,
	6972,
	18022,
	1392,
	-1594,
	-9599,
	16711,
	4096,
	0,
	0,
	8192,
	655,
	-2708,
	-16305,
	15237,
	13926,
	1808,
	10884,
	14254,
	3112,
	-406,
	-2444,
	14090,
	4669,
	193,
	1165,
	5406,
	2703,
	-614,
	-3697,
	13434,
	6553,
	694,
	4180,
	12451,
	901,
	-2237,
	-13468,
	12451,
	2662,
	-637,
	-3833,
	3768,
	655,
	-2708,
	-16305,
	14745,
	23511,
	2582,
	15543,
	19169,
	2457,
	-755,
	-4546,
	20152,
	5079,
	318,
	1913,
	6881,
	4096,
	0,
	0,
	20480,
	8560,
	1089,
	6556,
	19660,
	737,
	-2534,
	-15255,
	19005,
	4259,
	58,
	347,
	7864,
	2088,
	-995,
	-5993,
	11468,
	12288,
	1623,
	9771,
	15892,
	1474,
	-1510,
	-9090,
	15728,
	4628,
	180,
	1086,
	9175,
	1433,
	-1552,
	-9341,
	16056,
	7004,
	793,
	4772,
	14827,
	737,
	-2534,
	-15255,
	15073,
	2252,
	-884,
	-5321,
	5079,
	1228,
	-1780,
	-10714,
	13271,
	17326,
	2131,
	12827,
	16547,
	2334,
	-831,
	-5002,
	15073,
	5816,
	518,
	3118,
	3932,
	3686,
	-156,
	-938,
	14254,
	8601,
	1096,
	6598,
	16875,
	778,
	-2454,
	-14774,
	15073,
	3809,
	-107,
	-646,
	6062,
	614,
	-2804,
	-16879,
	9338,
	9256,
	1204,
	7251,
	13271,
	1761,
	-1247,
	-7508,
	13271,
	3522,
	-223,
	-1343,
	2457,
	1966,
	-1084,
	-6529,
	11468,
	5529,
	443,
	2668,
	10485,
	737,
	-2534,
	-15255,
	11632,
	3194,
	-367,
	-2212,
	1474,
	778,
	-2454,
	-14774
};

__device__ static const Word32 inter6[61] =
{
	29443,
	28346,
	25207,
	20449,
	14701,
	8693,
	3143,
	-1352,
	-4402,
	-5865,
	-5850,
	-4673,
	-2783,
	-672,
	1211,
	2536,
	3130,
	2991,
	2259,
	1170,
	0,
	-1001,
	-1652,
	-1868,
	-1666,
	-1147,
	-464,
	218,
	756,
	1060,
	1099,
	904,
	550,
	135,
	-245,
	-514,
	-634,
	-602,
	-451,
	-231,
	0,
	191,
	308,
	340,
	296,
	198,
	78,
	-36,
	-120,
	-163,
	-165,
	-132,
	-79,
	-19,
	34,
	73,
	91,
	89,
	70,
	38,
	0
};

/*
* window for non-MR122 modesm; uses 40 samples lookahead
* used only in BuildCNParam
*/
__device__ static const Word32 window_200_40[L_WINDOW] = {
	2621,  2623,  2629,  2638,  2651,  2668,  2689,  2713,  2741,  2772,
	2808,  2847,  2890,  2936,  2986,  3040,  3097,  3158,  3223,  3291,
	3363,  3438,  3517,  3599,  3685,  3774,  3867,  3963,  4063,  4166,
	4272,  4382,  4495,  4611,  4731,  4853,  4979,  5108,  5240,  5376,
	5514,  5655,  5800,  5947,  6097,  6250,  6406,  6565,  6726,  6890,
	7057,  7227,  7399,  7573,  7750,  7930,  8112,  8296,  8483,  8672,
	8863,  9057,  9252,  9450,  9650,  9852, 10055, 10261, 10468, 10677,
	10888, 11101, 11315, 11531, 11748, 11967, 12187, 12409, 12632, 12856,
	13082, 13308, 13536, 13764, 13994, 14225, 14456, 14688, 14921, 15155,
	15389, 15624, 15859, 16095, 16331, 16568, 16805, 17042, 17279, 17516,
	17754, 17991, 18228, 18465, 18702, 18939, 19175, 19411, 19647, 19882,
	20117, 20350, 20584, 20816, 21048, 21279, 21509, 21738, 21967, 22194,
	22420, 22644, 22868, 23090, 23311, 23531, 23749, 23965, 24181, 24394,
	24606, 24816, 25024, 25231, 25435, 25638, 25839, 26037, 26234, 26428,
	26621, 26811, 26999, 27184, 27368, 27548, 27727, 27903, 28076, 28247,
	28415, 28581, 28743, 28903, 29061, 29215, 29367, 29515, 29661, 29804,
	29944, 30081, 30214, 30345, 30472, 30597, 30718, 30836, 30950, 31062,
	31170, 31274, 31376, 31474, 31568, 31659, 31747, 31831, 31911, 31988,
	32062, 32132, 32198, 32261, 32320, 32376, 32428, 32476, 32521, 32561,
	32599, 32632, 32662, 32688, 32711, 32729, 32744, 32755, 32763, 32767,
	32767, 32741, 32665, 32537, 32359, 32129, 31850, 31521, 31143, 30716,
	30242, 29720, 29151, 28538, 27879, 27177, 26433, 25647, 24821, 23957,
	23055, 22117, 21145, 20139, 19102, 18036, 16941, 15820, 14674, 13505,
	12315, 11106,  9879,  8637,  7381,  6114,  4838,  3554,  2264,   971 };




/* comparision optimization tables */
/* definition of bad speech */
__device__ static const UWord8 table_speech_bad[9] = { 0, 0, 1, 1, 0, 0, 0, 1, 0 };
__device__ static const UWord8 table_SID[9] = { 0, 0, 0, 0, 1, 1, 1, 0, 0 };
__device__ static const UWord8 table_DTX[9] = { 0, 0, 0, 0, 1, 1, 1, 1, 0 };
__device__ static const UWord8 table_mute[9] = { 0, 0, 0, 0, 1, 0, 1, 1, 0 };

/* track start positions for fixed codebook routines */
__device__ static const Word8 startPos[16] =
{
	0,
	2,
	0,
	3,
	0,
	2,
	0,
	3,
	1,
	3,
	2,
	4,
	1,
	4,
	1,
	4
};


__device__ static Float64 Dotproduct40(Float32 *x, Float32 *y)
{
	Float64 acc;


	acc = x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
	acc += x[4] * y[4] + x[5] * y[5] + x[6] * y[6] + x[7] * y[7];
	acc += x[8] * y[8] + x[9] * y[9] + x[10] * y[10] + x[11] * y[11];
	acc += x[12] * y[12] + x[13] * y[13] + x[14] * y[14] + x[15] * y[15];
	acc += x[16] * y[16] + x[17] * y[17] + x[18] * y[18] + x[19] * y[19];
	acc += x[20] * y[20] + x[21] * y[21] + x[22] * y[22] + x[23] * y[23];
	acc += x[24] * y[24] + x[25] * y[25] + x[26] * y[26] + x[27] * y[27];
	acc += x[28] * y[28] + x[29] * y[29] + x[30] * y[30] + x[31] * y[31];
	acc += x[32] * y[32] + x[33] * y[33] + x[34] * y[34] + x[35] * y[35];
	acc += x[36] * y[36] + x[37] * y[37] + x[38] * y[38] + x[39] * y[39];
	return(acc);
}

/*
* CodAmrReset
*
*
* Parameters:
*    state             B: state structure
*    mode              I: AMR mode
*
* Function:
*    Resets state memory
*
* Returns:
*    void
*/
__device__ static void Decoder_amr_reset(Decoder_amrState *state, enum Mode mode)
{
	Word32 i;

	/* Cb_gain_average_reset */
	memset(state->Cb_gain_averState.cbGainHistory, 0, L_CBGAINHIST << 2);
	state->Cb_gain_averState.hangVar = 0;
	state->Cb_gain_averState.hangCount = 0;

	/* Initialize static position */
	state->exc = PIT_MAX + L_INTERPOL;

	/* Static vectors to zero */
	memset(state->old_exc, 0, (PIT_MAX + L_INTERPOL) << 2);

	if (mode != MRDTX)
		memset(state->mem_syn, 0, M << 2);

	/* initialize pitch sharpening */
	state->sharp = SHARPMIN;
	state->old_T0 = 40;

	/* Initialize state->lsp_old [] */
	if (mode != MRDTX) {
		state->lsp_old[0] = 30000;
		state->lsp_old[1] = 26000;
		state->lsp_old[2] = 21000;
		state->lsp_old[3] = 15000;
		state->lsp_old[4] = 8000;
		state->lsp_old[5] = 0;
		state->lsp_old[6] = -8000;
		state->lsp_old[7] = -15000;
		state->lsp_old[8] = -21000;
		state->lsp_old[9] = -26000;
	}

	/* Initialize memories of bad frame handling */
	state->prev_bf = 0;
	state->prev_pdf = 0;
	state->state = 0;
	state->T0_lagBuff = 40;
	state->inBackgroundNoise = 0;
	state->voicedHangover = 0;

	if (mode != MRDTX)
		memset(state->excEnergyHist, 0, 9 << 2);
	memset(state->ltpGainHistory, 0, 9 << 2);

	if (mode != MRDTX) {
		state->lsp_avg_st.lsp_meanSave[0] = 1384;
		state->lsp_avg_st.lsp_meanSave[1] = 2077;
		state->lsp_avg_st.lsp_meanSave[2] = 3420;
		state->lsp_avg_st.lsp_meanSave[3] = 5108;
		state->lsp_avg_st.lsp_meanSave[4] = 6742;
		state->lsp_avg_st.lsp_meanSave[5] = 8122;
		state->lsp_avg_st.lsp_meanSave[6] = 9863;
		state->lsp_avg_st.lsp_meanSave[7] = 11092;
		state->lsp_avg_st.lsp_meanSave[8] = 12714;
		state->lsp_avg_st.lsp_meanSave[9] = 13701;
	}
	memset(state->lsfState.past_r_q, 0, M << 2);

	/* Past dequantized lsfs */
	state->lsfState.past_lsf_q[0] = 1384;
	state->lsfState.past_lsf_q[1] = 2077;
	state->lsfState.past_lsf_q[2] = 3420;
	state->lsfState.past_lsf_q[3] = 5108;
	state->lsfState.past_lsf_q[4] = 6742;
	state->lsfState.past_lsf_q[5] = 8122;
	state->lsfState.past_lsf_q[6] = 9863;
	state->lsfState.past_lsf_q[7] = 11092;
	state->lsfState.past_lsf_q[8] = 12714;
	state->lsfState.past_lsf_q[9] = 13701;

	for (i = 0; i < 5; i++) {
		state->ec_gain_p_st.pbuf[i] = 1640;
	}
	state->ec_gain_p_st.past_gain_pit = 0;
	state->ec_gain_p_st.prev_gp = 16384;

	for (i = 0; i < 5; i++) {
		state->ec_gain_c_st.gbuf[i] = 1;
	}
	state->ec_gain_c_st.past_gain_code = 0;
	state->ec_gain_c_st.prev_gc = 1;

	if (mode != MRDTX) {
		for (i = 0; i < NPRED; i++) {
			state->pred_state.past_qua_en[i] = MIN_ENERGY;
			state->pred_state.past_qua_en_MR122[i] = MIN_ENERGY_MR122;
		}
	}
	state->nodataSeed = 21845;

	/* Static vectors to zero */
	memset(state->background_state.frameEnergyHist, 0, L_ENERGYHIST << 2);

	/* Initialize hangover handling */
	state->background_state.bgHangover = 0;

	/* phDispReset */
	memset(state->ph_disp_st.gainMem, 0, PHDGAINMEMSIZE << 2);
	state->ph_disp_st.prevState = 0;
	state->ph_disp_st.prevCbGain = 0;
	state->ph_disp_st.lockFull = 0;
	state->ph_disp_st.onset = 0;   /* assume no onset in start */

	if (mode != MRDTX) {
		state->dtxDecoderState.since_last_sid = 0;
		state->dtxDecoderState.true_sid_period_inv = 8192;
		state->dtxDecoderState.log_en = 3500;
		state->dtxDecoderState.old_log_en = 3500;

		/* low level noise for better performance in  DTX handover cases*/
		state->dtxDecoderState.pn_seed_rx = PN_INITIAL_SEED;

		/* Initialize state->lsp [] */
		state->dtxDecoderState.lsp[0] = 30000;
		state->dtxDecoderState.lsp[1] = 26000;
		state->dtxDecoderState.lsp[2] = 21000;
		state->dtxDecoderState.lsp[3] = 15000;
		state->dtxDecoderState.lsp[4] = 8000;
		state->dtxDecoderState.lsp[5] = 0;
		state->dtxDecoderState.lsp[6] = -8000;
		state->dtxDecoderState.lsp[7] = -15000;
		state->dtxDecoderState.lsp[8] = -21000;
		state->dtxDecoderState.lsp[9] = -26000;

		/* Initialize state->lsp_old [] */
		state->dtxDecoderState.lsp_old[0] = 30000;
		state->dtxDecoderState.lsp_old[1] = 26000;
		state->dtxDecoderState.lsp_old[2] = 21000;
		state->dtxDecoderState.lsp_old[3] = 15000;
		state->dtxDecoderState.lsp_old[4] = 8000;
		state->dtxDecoderState.lsp_old[5] = 0;
		state->dtxDecoderState.lsp_old[6] = -8000;
		state->dtxDecoderState.lsp_old[7] = -15000;
		state->dtxDecoderState.lsp_old[8] = -21000;
		state->dtxDecoderState.lsp_old[9] = -26000;
		state->dtxDecoderState.lsf_hist_ptr = 0;
		state->dtxDecoderState.log_pg_mean = 0;
		state->dtxDecoderState.log_en_hist_ptr = 0;

		/* initialize decoder lsf history */
		state->dtxDecoderState.lsf_hist[0] = 1384;
		state->dtxDecoderState.lsf_hist[1] = 2077;
		state->dtxDecoderState.lsf_hist[2] = 3420;
		state->dtxDecoderState.lsf_hist[3] = 5108;
		state->dtxDecoderState.lsf_hist[4] = 6742;
		state->dtxDecoderState.lsf_hist[5] = 8122;
		state->dtxDecoderState.lsf_hist[6] = 9863;
		state->dtxDecoderState.lsf_hist[7] = 11092;
		state->dtxDecoderState.lsf_hist[8] = 12714;
		state->dtxDecoderState.lsf_hist[9] = 13701;

		for (i = 1; i < DTX_HIST_SIZE; i++) {
			memcpy(&state->dtxDecoderState.lsf_hist[M * i], &state->
				dtxDecoderState.lsf_hist[0], M << 2);
		}
		memset(state->dtxDecoderState.lsf_hist_mean, 0, M * DTX_HIST_SIZE << 2);

		/* initialize decoder log frame energy */
		for (i = 0; i < DTX_HIST_SIZE; i++) {
			state->dtxDecoderState.log_en_hist[i] = state->dtxDecoderState.log_en;
		}
		state->dtxDecoderState.log_en_adjust = 0;
		state->dtxDecoderState.dtxHangoverCount = DTX_HANG_CONST;
		state->dtxDecoderState.decAnaElapsedCount = 31;
		state->dtxDecoderState.sid_frame = 0;
		state->dtxDecoderState.valid_data = 0;
		state->dtxDecoderState.dtxHangoverAdded = 0;
		state->dtxDecoderState.dtxGlobalState = DTX;
		state->dtxDecoderState.data_updated = 0;
	}
	return;
}


/*
* rx_dtx_handler
*
*
* Parameters:
*    st->dtxGlobalState      I: DTX state
*    st->since_last_sid      B: Frames after last SID frame
*    st->data_updated        I: SID update flag
*    st->decAnaElapsedCount  B: state machine that synch with the GSMEFR txDtx machine
*    st->dtxHangoverAdded    B: DTX hangover
*    st->sid_frame           O: SID frame indicator
*    st->valid_data          O: Vaild data indicator
*    frame_type              O: Frame type
*
* Function:
*    Find the new DTX state
*
* Returns:
*    DTXStateType            DTX, DTX_MUTE or SPEECH
*/
__device__ static enum DTXStateType rx_dtx_handler(dtx_decState *st, enum RXFrameType frame_type)
{
	enum DTXStateType newState;
	enum DTXStateType encState;

	/* DTX if SID frame or previously in DTX{_MUTE} and (NO_RX OR BAD_SPEECH) */
	if (table_SID[frame_type] | ((st->dtxGlobalState != SPEECH) &
		table_speech_bad[frame_type])) {
		newState = DTX;

		/* stay in mute for these input types */
		if ((st->dtxGlobalState == DTX_MUTE) & table_mute[frame_type]) {
			newState = DTX_MUTE;
		}

		/*
		* evaluate if noise parameters are too old
		* since_last_sid is reset when CN parameters have been updated
		*/
		st->since_last_sid += 1;

		/* no update of sid parameters in DTX for a long while */
		if ((frame_type != RX_SID_UPDATE) & (st->since_last_sid > DTX_MAX_EMPTY_THRESH)) {
			newState = DTX_MUTE;
		}
	}
	else {
		newState = SPEECH;
		st->since_last_sid = 0;
	}

	/*
	* reset the decAnaElapsed Counter when receiving CNI data the first
	* time, to robustify counter missmatch after handover
	* this might delay the bwd CNI analysis in the new decoder slightly.
	*/
	if ((st->data_updated == 0) & (frame_type == RX_SID_UPDATE)) {
		st->decAnaElapsedCount = 0;
	}

	/*
	* update the SPE-SPD DTX hangover synchronization
	* to know when SPE has added dtx hangover
	*/
	st->decAnaElapsedCount += 1;
	st->dtxHangoverAdded = 0;
	encState = SPEECH;

	if (table_DTX[frame_type]) {
		encState = DTX;
		if ((frame_type == RX_NO_DATA) & (newState == SPEECH)) {
			encState = SPEECH;
		}
	}

	if (encState == SPEECH) {
		st->dtxHangoverCount = DTX_HANG_CONST;
	}
	else {
		if (st->decAnaElapsedCount > DTX_ELAPSED_FRAMES_THRESH) {
			st->dtxHangoverAdded = 1;
			st->decAnaElapsedCount = 0;
			st->dtxHangoverCount = 0;
		}
		else if (st->dtxHangoverCount == 0) {
			st->decAnaElapsedCount = 0;
		}
		else {
			st->dtxHangoverCount -= 1;
		}
	}

	if (newState != SPEECH) {
		/*
		* DTX or DTX_MUTE
		* CN data is not in a first SID, first SIDs are marked as SID_BAD
		* but will do backwards analysis if a hangover period has been added
		* according to the state machine above
		*/
		st->sid_frame = 0;
		st->valid_data = 0;

		if (frame_type == RX_SID_FIRST) {
			st->sid_frame = 1;
		}
		else if (frame_type == RX_SID_UPDATE) {
			st->sid_frame = 1;
			st->valid_data = 1;
		}
		else if (frame_type == RX_SID_BAD) {
			st->sid_frame = 1;

			/* use old data */
			st->dtxHangoverAdded = 0;
		}
	}

	/* newState is used by both SPEECH AND DTX synthesis routines */
	return newState;
}


/*
* Lsf_lsp
*
*
* Parameters:
*    lsf               I: vector of LSFs
*    lsp               O: vector of LSPs
*
* Function:
*    Transformation lsf to lsp, order M
*
* Returns:
*    void
*/
__device__ static void Lsf_lsp(Word32 lsf[], Word32 lsp[])
{
	Word32 i, ind, offset, tmp;


	for (i = 0; i < M; i++) {
		/* ind = b8-b15 of lsf[i] */
		ind = lsf[i] >> 8;

		/* offset = b0-b7  of lsf[i] */
		offset = lsf[i] & 0x00ff;

		/* lsp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 256 */
		tmp = ((cos_table[ind + 1] - cos_table[ind])*offset) << 1;
		lsp[i] = cos_table[ind] + (tmp >> 9);
	}
	return;
}


/*
* D_plsf_3
*
*
* Parameters:
*    st->past_lsf_q    I: Past dequantized LFSs
*    st->past_r_q      B: past quantized residual
*    mode              I: AMR mode
*    bfi               B: bad frame indicator
*    indice            I: quantization indices of 3 submatrices, Q0
*    lsp1_q            O: quantized 1st LSP vector
*
* Function:
*    Decodes the LSP parameters using the received quantization indices.
*    1st order MA prediction and split by 3 vector quantization (split-VQ)
*
* Returns:
*    void
*/
__device__ static void D_plsf_3(D_plsfState *st, enum Mode mode, Word16 bfi, Word16 *
	indice, Word32 *lsp1_q)
{
	Word32 lsf1_r[M], lsf1_q[M];
	Word32 i, index, temp;
	const Word32 *p_cb1, *p_cb2, *p_cb3, *p_dico;


	/* if bad frame */
	if (bfi != 0) {
		/* use the past LSFs slightly shifted towards their mean */
		for (i = 0; i < M; i++) {
			/* lsfi_q[i] = ALPHA*past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
			lsf1_q[i] = ((st->past_lsf_q[i] * ALPHA) >> 15) + ((mean_lsf_3[i]
				* ONE_ALPHA) >> 15);
		}

		/* estimate past quantized residual to be used in next frame */
		if (mode != MRDTX) {
			for (i = 0; i < M; i++) {
				/* temp  = meanLsf[i] +  pastR2_q[i] * pred_fac; */
				temp = mean_lsf_3[i] + ((st->past_r_q[i] * pred_fac[i]) >> 15);
				st->past_r_q[i] = lsf1_q[i] - temp;
			}
		}
		else {
			for (i = 0; i < M; i++) {
				/* temp  = meanLsf[i] +  pastR2_q[i]; */
				temp = mean_lsf_3[i] + st->past_r_q[i];
				st->past_r_q[i] = lsf1_q[i] - temp;
			}
		}
	}

	/* if good LSFs received */
	else {
		if ((mode == MR475) | (mode == MR515)) {
			/* MR475, MR515 */
			p_cb1 = dico1_lsf_3;
			p_cb2 = dico2_lsf_3;
			p_cb3 = mr515_3_lsf;
		}
		else if (mode == MR795) {
			/* MR795 */
			p_cb1 = mr795_1_lsf;
			p_cb2 = dico2_lsf_3;
			p_cb3 = dico3_lsf_3;
		}
		else {
			/* MR59, MR67, MR74, MR102, MRDTX */
			p_cb1 = dico1_lsf_3;
			p_cb2 = dico2_lsf_3;
			p_cb3 = dico3_lsf_3;
		}

		/* decode prediction residuals from 3 received indices */
		index = *indice++;
		p_dico = &p_cb1[index + index + index];
		index = *indice++;
		lsf1_r[0] = *p_dico++;
		lsf1_r[1] = *p_dico++;
		lsf1_r[2] = *p_dico++;

		if ((mode == MR475) | (mode == MR515)) {
			/* MR475, MR515 only using every second entry */
			index = index << 1;
		}
		p_dico = &p_cb2[index + index + index];
		index = *indice++;
		lsf1_r[3] = *p_dico++;
		lsf1_r[4] = *p_dico++;
		lsf1_r[5] = *p_dico++;
		p_dico = &p_cb3[index << 2];
		lsf1_r[6] = *p_dico++;
		lsf1_r[7] = *p_dico++;
		lsf1_r[8] = *p_dico++;
		lsf1_r[9] = *p_dico++;

		/* Compute quantized LSFs and update the past quantized residual */
		if (mode != MRDTX) {
			for (i = 0; i < M; i++) {
				lsf1_q[i] = lsf1_r[i] + (mean_lsf_3[i] + ((st->past_r_q[i] *
					pred_fac[i]) >> 15));
			}
			memcpy(st->past_r_q, lsf1_r, M << 2);
		}
		else {
			for (i = 0; i < M; i++) {
				lsf1_q[i] = lsf1_r[i] + (mean_lsf_3[i] + st->past_r_q[i]);
			}
			memcpy(st->past_r_q, lsf1_r, M << 2);
		}
	}

	/* verification that LSFs has minimum distance of LSF_GAP Hz */
	temp = LSF_GAP;

	for (i = 0; i < M; i++) {
		if (lsf1_q[i] < temp) {
			lsf1_q[i] = temp;
		}
		temp = lsf1_q[i] + LSF_GAP;
	}
	memcpy(st->past_lsf_q, lsf1_q, M << 2);

	/*  convert LSFs to the cosine domain */
	Lsf_lsp(lsf1_q, lsp1_q);
	return;
}


/*
* pseudonoise
*
*
* Parameters:
*    shift_reg         B: Old CN generator shift register state
*    no_bits           I: Number of bits
*
* Function:
*    pseudonoise
*
* Returns:
*    noise_bits
*/
__device__ static Word32 pseudonoise(Word32 *shift_reg, Word32 no_bits)
{
	Word32 noise_bits, Sn, i;
	Word32 s_reg;


	s_reg = *shift_reg;
	noise_bits = 0;

	for (i = 0; i < no_bits; i++) {
		/* State n == 31 */
		Sn = s_reg & 0x00000001L;

		/* State n == 3 */
		if (s_reg & 0x10000000L) {
			Sn = Sn ^ 0x1L;
		}
		else {
			Sn = Sn ^ 0x0L;
		}
		noise_bits = (noise_bits << 1) | (s_reg & 1);
		s_reg = s_reg >> 1;

		if (Sn & 1) {
			s_reg = s_reg | 0x40000000L;
		}
	}
	*shift_reg = s_reg;
	return noise_bits;
}


/*
* Lsp_lsf
*
*
* Parameters:
*    lsp               I: LSP vector (range: -1<=val<1)
*    lsf               O: LSF vector Old CN generator shift register state
*
* Function:
*    Transformation lsp to lsf, LPC order M
*    lsf[i] = arccos(lsp[i])/(2*pi)
*
* Returns:
*    void
*/
__device__ static void Lsp_lsf(Word32 lsp[], Word32 lsf[])
{
	Word32 i, ind = 63;   /* begin at end of table -1 */


	for (i = M - 1; i >= 0; i--) {
		/* find value in table that is just greater than lsp[i] */
		while (cos_table[ind] < lsp[i]) {
			ind--;
		}
		lsf[i] = ((((lsp[i] - cos_table[ind]) * acos_slope[ind]) + 0x800)
			>> 12) + (ind << 8);
	}
	return;
}


/*
* Reorder_lsf
*
*
* Parameters:
*    lsf            B: vector of LSFs (range: 0<=val<=0.5)
*    min_dist       I: minimum required distance
*
* Function:
*    Make sure that the LSFs are properly ordered and to keep a certain minimum
*    distance between adjacent LSFs. LPC order = M.
*
* Returns:
*    void
*/
__device__ static void Reorder_lsf(Word32 *lsf, Word32 min_dist)
{
	Word32 lsf_min, i;


	lsf_min = min_dist;

	for (i = 0; i < M; i++) {
		if (lsf[i] < lsf_min) {
			lsf[i] = lsf_min;
		}
		lsf_min = lsf[i] + min_dist;
	}
}

/* VC5.0 Global optimization does not work with this function */
#if _MSC_VER == 1100
#pragma optimize( "g", off )
#endif
/*
* Get_lsp_pol
*
*
* Parameters:
*    lsp               I: line spectral frequencies
*    f                 O: polynomial F1(z) or F2(z)
*
* Function:
*    Find the polynomial F1(z) or F2(z) from the LSPs.
*
*    F1(z) = product ( 1 - 2 lsp[i] z^-1 + z^-2 )
*             i=0,2,4,6,8
*    F2(z) = product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
*             i=1,3,5,7,9
*
*    where lsp[] is the LSP vector in the cosine domain.
*
*    The expansion is performed using the following recursion:
*
*    f[0] = 1
*    b = -2.0 * lsp[0]
*    f[1] = b
*    for i=2 to 5 do
*       b = -2.0 * lsp[2*i-2];
*       f[i] = b*f[i-1] + 2.0*f[i-2];
*       for j=i-1 down to 2 do
*          f[j] = f[j] + b*f[j-1] + f[j-2];
*       f[1] = f[1] + b;
*
* Returns:
*    void
*/
__device__ static void Get_lsp_pol(Word32 *lsp, Word32 *f)
{
	volatile Word32 f0, f1, f2, f3, f4, f5;
	Word32 l1, l2, l3, l4;


	/* f[0] = 1.0; */
	f0 = 16777216L;

	/* f1 = *lsp * -1024; */
	f1 = -lsp[0] << 10;
	l1 = lsp[2];
	l2 = lsp[4];
	l3 = lsp[6];
	l4 = lsp[8];
	f2 = f0 << 1;
	f2 -= (((f1 >> 16) * l1) + (((f1 & 0xFFFE) * l1) >> 16)) << 2;
	f1 -= l1 << 10;
	f3 = f1 << 1;
	f3 -= (((f2 >> 16) * l2) + (((f2 & 0xFFFE) * l2) >> 16)) << 2;
	f2 += f0;
	f2 -= (((f1 >> 16) * l2) + (((f1 & 0xFFFE) * l2) >> 16)) << 2;
	f1 -= l2 << 10;
	f4 = f2 << 1;
	f4 -= (((f3 >> 16) * l3) + (((f3 & 0xFFFE) * l3) >> 16)) << 2;
	f3 += f1;
	f3 -= (((f2 >> 16) * l3) + (((f2 & 0xFFFE) * l3) >> 16)) << 2;
	f2 += f0;
	f2 -= (((f1 >> 16) * l3) + (((f1 & 0xFFFE) * l3) >> 16)) << 2;
	f1 -= l3 << 10;
	f5 = f3 << 1;
	f5 -= (((f4 >> 16) * l4) + (((f4 & 0xFFFE) * l4) >> 16)) << 2;
	f4 += f2;
	f4 -= (((f3 >> 16) * l4) + (((f3 & 0xFFFE) * l4) >> 16)) << 2;
	f3 += f1;
	f3 -= (((f2 >> 16) * l4) + (((f2 & 0xFFFE) * l4) >> 16)) << 2;
	f2 += f0;
	f2 -= (((f1 >> 16) * l4) + (((f1 & 0xFFFE) * l4) >> 16)) << 2;
	f1 -= l4 << 10;
	f[0] = f0;
	f[1] = f1;
	f[2] = f2;
	f[3] = f3;
	f[4] = f4;
	f[5] = f5;
	return;
}
#if _MSC_VER == 1100
#pragma optimize( "", on )
#endif


/*
* Lsp_Az
*
*
* Parameters:
*    lsp                 I: Line spectral frequencies
*    a                   O: Predictor coefficients
*
* Function:
*    Converts from the line spectral pairs (LSP) to LP coefficients,
*    for a 10th order filter.
*
*    Find the coefficients of F1(z) and F2(z)
*    Multiply F1(z) by 1+z^{-1} and F2(z) by 1-z^{-1}
*    A(z) = ( F1(z) + F2(z) ) / 2
*
* Returns:
*    void
*/
__device__ static void Lsp_Az(Word32 lsp[], Word32 a[])
{
	Word32 f1[6], f2[6];
	Word32 T0, i, j;


	Get_lsp_pol(&lsp[0], f1);
	Get_lsp_pol(&lsp[1], f2);

	for (i = 5; i > 0; i--) {
		f1[i] += f1[i - 1];
		f2[i] -= f2[i - 1];
	}
	a[0] = 4096;

	for (i = 1, j = 10; i <= 5; i++, j--) {
		T0 = f1[i] + f2[i];
		a[i] = (Word16)(T0 >> 13);  /* emulate fixed point bug */
		if ((T0 & 4096) != 0) {
			a[i]++;
		}
		T0 = f1[i] - f2[i];
		a[j] = (Word16)(T0 >> 13);   /* emulate fixed point bug */

		if ((T0 & 4096) != 0) {
			a[j]++;
		}
	}
	return;
}


/*
* A_Refl
*
*
* Parameters:
*    a                 I: Directform coefficients
*    refl              O: Reflection coefficients
*
* Function:
*    Converts from the directform coefficients to reflection coefficients
*
* Returns:
*    void
*/
__device__ static void A_Refl(Word32 a[], Word32 refl[])
{
	/* local variables */
	int normShift;
	Word32 aState[M], bState[M];
	Word32 normProd, acc, temp, mult, scale, i, j;


	/* initialize states */
	memcpy(aState, a, M << 2);

	/* backward Levinson recursion */
	for (i = M - 1; i >= 0; i--) {
		if (labs(aState[i]) >= 4096) {
			goto ExitRefl;
		}
		refl[i] = aState[i] << 3;
		temp = (refl[i] * refl[i]) << 1;
		acc = (MAX_32 - temp);
		normShift = 0;
		if (acc != 0) {
			temp = acc;
			while (!(temp & 0x40000000))
			{
				normShift++;
				temp = temp << 1;
			}
		}
		else {
			normShift = 0;
		}
		scale = 15 - normShift;
		acc = (acc << normShift);
		temp = (acc + (Word32)0x00008000L);

		if (temp > 0) {
			normProd = temp >> 16;
			mult = 0x20000000L / normProd;
		}
		else
			mult = 16384;

		for (j = 0; j < i; j++) {
			acc = aState[j] << 16;
			acc -= (refl[i] * aState[i - j - 1]) << 1;
			temp = (acc + (Word32)0x00008000L) >> 16;
			temp = (mult * temp) << 1;

			if (scale > 0) {
				if ((temp & ((Word32)1 << (scale - 1))) != 0) {
					temp = (temp >> scale) + 1;
				}
				else
					temp = (temp >> scale);
			}
			else
				temp = (temp >> scale);

			if (labs(temp) > 32767) {
				goto ExitRefl;
			}
			bState[j] = temp;
		}
		memcpy(aState, bState, i << 2);
	}
	return;
ExitRefl:
	memset(refl, 0, M << 2);
}


/*
* Log2_norm
*
*
* Parameters:
*    x                 I: input value
*    exp               I: exponent
*    exponent          O: Integer part of Log2. (range: 0<=val<=30)
*    fraction          O: Fractional part of Log2. (range: 0<=val<1)
*
* Function:
*    Computes log2
*
*    Computes log2(L_x, exp),  where   L_x is positive and
*    normalized, and exp is the normalisation exponent
*    If L_x is negative or zero, the result is 0.
*
*    The function Log2(L_x) is approximated by a table and linear
*    interpolation. The following steps are used to compute Log2(L_x)
*
*    exponent = 30-normExponent
*    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
*    a = bit10-b24
*    i -=32
*    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
*
* Returns:
*    void
*/
__device__ static void Log2_norm(Word32 x, Word32 exp, Word32 *exponent, Word32 *
	fraction)
{
	Word32 y, i, a;


	if (x <= 0) {
		*exponent = 0;
		*fraction = 0;
		return;
	}

	/* Extract b25-b31 */
	i = x >> 25;
	i = i - 32;

	/* Extract b10-b24 of fraction */
	a = x >> 9;
	a = a & 0xFFFE;   /* 2a */

					  /* fraction */
	y = (log2_table[i] << 16) - a * (log2_table[i] - log2_table[i + 1]);
	*fraction = y >> 16;
	*exponent = 30 - exp;
	return;
}


/*
* Log2
*
*
* Parameters:
*    x                 I: input value
*    exponent          O: Integer part of Log2. (range: 0<=val<=30)
*    fraction          O: Fractional part of Log2. (range: 0<=val<1)
*
* Function:
*    Computes log2(L_x)
*    If x is negative or zero, the result is 0.
*
* Returns:
*    void
*/
__device__ static void Log2(Word32 x, Word32 *exponent, Word32 *fraction)
{
	int tmp, exp = 0;

	if (x != 0) {
		tmp = x;
		while (!((tmp & 0x80000000) ^ ((tmp & 0x40000000) << 1)))
		{
			exp++;
			tmp = tmp << 1;
		}
	}
	Log2_norm(x << exp, exp, exponent, fraction);
}


/*
* Pow2
*
*
* Parameters:
*    exponent          I: Integer part. (range: 0<=val<=30)
*    fraction          O: Fractional part. (range: 0.0<=val<1.0)
*
* Function:
*    pow(2.0, exponent.fraction)
*
*    The function Pow2(L_x) is approximated by a table and linear interpolation.
*
*    i = bit10-b15 of fraction, 0 <= i <= 31
*    a = biT0-b9   of fraction
*    x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
*    x = L_x >> (30-exponent) (with rounding)
*
* Returns:
*    result (range: 0<=val<=0x7fffffff)
*/
__device__ static Word32 Pow2(Word32 exponent, Word32 fraction)
{
	Word32 i, a, tmp, x, exp;


	/* Extract b10-b16 of fraction */
	i = fraction >> 10;

	/* Extract b0-b9 of fraction */
	a = (fraction << 5) & 0x7fff;

	/* table[i] << 16 */
	x = pow2_table[i] << 16;

	/* table[i] - table[i+1] */
	tmp = pow2_table[i] - pow2_table[i + 1];

	/* L_x -= tmp*a*2 */
	x -= (tmp * a) << 1;

	if (exponent >= -1) {
		exp = (30 - exponent);

		/* Rounding */
		if ((x & ((Word32)1 << (exp - 1))) != 0) {
			x = (x >> exp) + 1;
		}
		else
			x = x >> exp;
	}
	else
		x = 0;
	return(x);
}


/*
* Build_CN_code
*
*
* Parameters:
*    seed              B: Old CN generator shift register state
*    cod               O: Generated CN fixed codebook vector
*
* Function:
*    Generate CN fixed codebook vector
*
* Returns:
*    void
*/
__device__ static void Build_CN_code(Word32 *seed, Word32 cod[])
{
	Word32 i, j, k;


	memset(cod, 0, L_SUBFR << 2);

	for (k = 0; k < 10; k++) {
		i = pseudonoise(seed, 2);   /* generate pulse position */
		i = (i * 20) >> 1;
		i = (i + k);
		j = pseudonoise(seed, 1);   /* generate sign           */

		if (j > 0) {
			cod[i] = 4096;
		}
		else {
			cod[i] = -4096;
		}
	}
	return;
}


/*
* Build_CN_param
*
*
* Parameters:
*    seed              B: Old CN generator shift register state
*    nParam            I: number of params
*    paramSizeTable    I: size of params
*    parm              O: CN Generated params
*
* Function:
*    Generate parameters for comfort noise generation
*
* Returns:
*    void
*/
__device__ static void Build_CN_param(Word16 *seed, enum Mode mode, Word16 parm[])
{
	Word32 i;
	const Word32 *p;


	*seed = (Word16)((*seed * 31821) + 13849L);
	p = &window_200_40[*seed & 0x7F];

	switch (mode) {
	case MR122:
		for (i = 0; i < PRMNO_MR122; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR122[i]));
		}
		break;

	case MR102:
		for (i = 0; i < PRMNO_MR102; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR102[i]));
		}
		break;

	case MR795:
		for (i = 0; i < PRMNO_MR795; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR795[i]));
		}
		break;

	case MR74:
		for (i = 0; i < PRMNO_MR74; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR74[i]));
		}
		break;

	case MR67:
		for (i = 0; i < PRMNO_MR67; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR67[i]));
		}
		break;

	case MR59:
		for (i = 0; i < PRMNO_MR59; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR59[i]));
		}
		break;

	case MR515:
		for (i = 0; i < PRMNO_MR515; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR515[i]));
		}
		break;

	case MR475:
		for (i = 0; i < PRMNO_MR475; i++) {
			parm[i] = (Word16)(*p++ & ~(0xFFFF << bitno_MR475[i]));
		}
		break;
	}
}


/*
* Syn_filt
*
*
* Parameters:
*    a                 I: prediction coefficients [M+1]
*    x                 I: input signal
*    y                 O: output signal
*    lg                I: size of filtering
*    mem               B: memory associated with this filtering
*    update            I: 0=no update, 1=update of memory.
*
* Function:
*    Perform synthesis filtering through 1/A(z).
*
* Returns:
*    void
*/
__device__ static Word32 Syn_filt(Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
	, Word32 update)
{
	Word32 tmp[50];   /* malloc is slow */
	Word32 s, a0, overflow = 0;
	Word32 *yy, *yy_limit;


	/* Copy mem[] to yy[] */
	memcpy(tmp, mem, 40);
	yy = tmp + M;
	yy_limit = yy + lg;
	a0 = a[0];

	/* Do the filtering. */
	while (yy < yy_limit) {

		s = *x++ * a0;
		s -= yy[-1] * a[1];
		s -= yy[-2] * a[2];
		s -= yy[-3] * a[3];
		s -= yy[-4] * a[4];
		s -= yy[-5] * a[5];
		s -= yy[-6] * a[6];
		s -= yy[-7] * a[7];
		s -= yy[-8] * a[8];
		s -= yy[-9] * a[9];
		s -= yy[-10] * a[10];
		if (labs(s) < 0x7ffffff)
			*yy = (s + 0x800L) >> 12;
		else if (s > 0) {
			*yy = 32767;
			overflow = 1;
		}
		else {
			*yy = -32768;
			overflow = 1;
		}
		yy++;
	}
	memcpy(y, &tmp[M], lg << 2);

	/* Update of memory if update==1 */
	if (update) {
		memcpy(mem, &y[lg - M], 40);
	}
	return overflow;
}

/*
* Syn_filt_overflow
*
*
* Parameters:
*    a                 I: prediction coefficients [M+1]
*    x                 I: input signal
*    y                 O: output signal
*    lg                I: size of filtering
*    mem               B: memory associated with this filtering
*    update            I: 0=no update, 1=update of memory.
*
* Function:
*    Perform synthesis filtering through 1/A(z).
*    Saturate after every multiplication.
* Returns:
*    void
*/
__device__ static void Syn_filt_overflow(Word32 a[], Word32 x[], Word32 y[], Word32 lg, Word32 mem[]
	, Word32 update)
{
	Word32 tmp[50];   /* malloc is slow */
	Word32 i, j, s, a0;
	Word32 *yy;


	/* Copy mem[] to yy[] */
	memcpy(tmp, mem, 40);
	yy = tmp + M;
	a0 = a[0];

	/* Do the filtering. */
	for (i = 0; i < lg; i++) {
		s = x[i] * a0;

		for (j = 1; j <= M; j++) {
			s -= a[j] * yy[-j];
			if (s > 1073741823) {
				s = 1073741823;
			}
			else if (s < -1073741824) {
				s = -1073741824;
			}
		}

		if (labs(s) < 0x7FFE800)
			*yy = (s + 0x800L) >> 12;
		else if (s > 0) {
			*yy = 32767;
		}
		else {
			*yy = -32768;
		}
		yy++;
	}
	memcpy(y, &tmp[M], lg << 2);

	/* Update of memory if update==1 */
	if (update) {
		memcpy(mem, &y[lg - M], 40);
	}
	return;
}

/*
* dtx_dec
*
*
* Parameters:
*    st                            B: DTX state struct
*    mem_syn                       I: AMR decoder state
*    lsfState                      B: LSF state struct
*    pred_state->past_qua_en       O: table of past quantized energies
*    pred_state->past_qua_en_MR122 O: table of past quantized energies MR122
*    averState->hangVar            O:
*    averState->hangCount          O: hangover variable
*    new_state                     I: new DTX state
*    mode                          I: AMR mode
*    parm                          I: vector of synthesis parameters
*    synth                         O: synthesised speech
*    A_t                           O: decoded LP filter in 4 subframes
*
* Function:
*    DTX
*
* Returns:
*    void
*/
__device__ static void dtx_dec(dtx_decState *st, Word32 *mem_syn, D_plsfState *lsfState,
	dec_gc_predState *pred_state, Cb_gain_averageState *averState, enum
	DTXStateType new_state, enum Mode mode, Word16 parm[], Word32 synth[],
	Word32 A_t[])
{
	Word32 ex[L_SUBFR], acoeff[11], acoeff_variab[M + 1], lsp_int[M];
	Word32 refl[M], lsf[M], lsf_int[M], lsf_int_variab[M], lsp_int_variab[M];
	Word32 i, j, int_fac, log_en_int, pred_err, log_pg_e, log_pg_m, log_pg;
	Word32 negative, lsf_mean, lsf_variab_index, lsf_variab_factor, ptr;
	Word16 log_en_index, log_en_int_e, log_en_int_m, level, ma_pred_init,
		tmp_int_length;


	if ((st->dtxHangoverAdded != 0) & (st->sid_frame != 0)) {
		/*
		* sidFirst after dtx hangover period
		* or sidUpd after dtxhangover
		*/
		/* set log_en_adjust to correct value */
		st->log_en_adjust = dtx_log_en_adjust[mode];
		ptr = st->lsf_hist_ptr + M;

		if (ptr == 80) {
			ptr = 0;
		}
		memcpy(&st->lsf_hist[ptr], &st->lsf_hist[st->lsf_hist_ptr], M << 2);
		ptr = st->log_en_hist_ptr + 1;

		if (ptr == DTX_HIST_SIZE) {
			ptr = 0;
		}
		st->log_en_hist[ptr] = st->log_en_hist[st->log_en_hist_ptr];   /* Q11 */

																	   /*
																	   * compute mean log energy and lsp
																	   * from decoded signal (SID_FIRST)
																	   */
		st->log_en = 0;
		memset(lsf, 0, M << 2);

		/* average energy and lsp */
		for (i = 0; i < DTX_HIST_SIZE; i++) {
			st->log_en = st->log_en + (st->log_en_hist[i] >> 3);

			for (j = 0; j < M; j++) {
				lsf[j] += st->lsf_hist[i * M + j];
			}
		}

		for (j = 0; j < M; j++) {
			lsf[j] = lsf[j] >> 3;   /* divide by 8 */
		}
		Lsf_lsp(lsf, st->lsp);

		/*
		* make log_en speech coder mode independent
		* added again later before synthesis
		*/
		st->log_en = st->log_en - st->log_en_adjust;

		/* compute lsf variability vector */
		memcpy(st->lsf_hist_mean, st->lsf_hist, 80 << 2);

		for (i = 0; i < M; i++) {
			lsf_mean = 0;

			/* compute mean lsf */
			for (j = 0; j < 8; j++) {
				lsf_mean += st->lsf_hist_mean[i + j * M];
			}
			lsf_mean = lsf_mean >> 3;

			/*
			* subtract mean and limit to within reasonable limits
			* moreover the upper lsf's are attenuated
			*/
			for (j = 0; j < 8; j++) {
				/* subtract mean */
				st->lsf_hist_mean[i + j * M] = st->lsf_hist_mean[i + j * M] -
					lsf_mean;

				/* attenuate deviation from mean, especially for upper lsf's */
				st->lsf_hist_mean[i + j * M] = (st->lsf_hist_mean[i + j * M] *
					lsf_hist_mean_scale[i]) >> 15;

				/* limit the deviation */
				if (st->lsf_hist_mean[i + j * M] < 0) {
					negative = 1;
				}
				else {
					negative = 0;
				}
				st->lsf_hist_mean[i + j * M] = labs(st->lsf_hist_mean[i + j * M]);

				/* apply soft limit */
				if (st->lsf_hist_mean[i + j * M] > 655) {
					st->lsf_hist_mean[i + j * M] = 655 + ((st->lsf_hist_mean[i + j
						* M] - 655) >> 2);
				}

				/* apply hard limit */
				if (st->lsf_hist_mean[i + j * M] > 1310) {
					st->lsf_hist_mean[i + j * M] = 1310;
				}

				if (negative != 0) {
					st->lsf_hist_mean[i + j * M] = -st->lsf_hist_mean[i + j * M];
				}
			}
		}
	}

	if (st->sid_frame != 0) {
		/*
		* Set old SID parameters, always shift
		* even if there is no new valid_data
		*/
		memcpy(st->lsp_old, st->lsp, M << 2);
		st->old_log_en = st->log_en;

		if (st->valid_data != 0) /* new data available (no CRC) */ {
			/* Compute interpolation factor, since the division only works
			* for values of since_last_sid < 32 we have to limit the
			* interpolation to 32 frames
			*/
			tmp_int_length = st->since_last_sid;
			st->since_last_sid = 0;

			if (tmp_int_length > 32) {
				tmp_int_length = 32;
			}

			if (tmp_int_length >= 2) {
				st->true_sid_period_inv = 0x2000000 / (tmp_int_length
					<< 10);
			}
			else {
				st->true_sid_period_inv = 16384;   /* 0.5 it Q15 */
			}
			memcpy(lsfState->past_r_q, &past_rq_init[parm[0] * M], M << 2);
			D_plsf_3(lsfState, MRDTX, 0, &parm[1], st->lsp);

			/* reset for next speech frame */
			memset(lsfState->past_r_q, 0, M << 2);
			log_en_index = parm[4];

			/* Q11 and divide by 4 */
			st->log_en = (Word16)(log_en_index << 9);

			/* Subtract 2.5 in Q11 */
			st->log_en = (Word16)(st->log_en - 5120);

			/* Index 0 is reserved for silence */
			if (log_en_index == 0) {
				st->log_en = MIN_16;
			}

			/*
			* no interpolation at startup after coder reset
			* or when SID_UPD has been received right after SPEECH
			*/
			if ((st->data_updated == 0) || (st->dtxGlobalState == SPEECH)) {
				memcpy(st->lsp_old, st->lsp, M << 2);
				st->old_log_en = st->log_en;
			}
		}   /* endif valid_data */

			/* initialize gain predictor memory of other modes */
		ma_pred_init = (Word16)((st->log_en >> 1) - 9000);

		if (ma_pred_init > 0) {
			ma_pred_init = 0;
		}

		if (ma_pred_init < -14436) {
			ma_pred_init = -14436;
		}
		pred_state->past_qua_en[0] = ma_pred_init;
		pred_state->past_qua_en[1] = ma_pred_init;
		pred_state->past_qua_en[2] = ma_pred_init;
		pred_state->past_qua_en[3] = ma_pred_init;

		/* past_qua_en for other modes than MR122 */
		ma_pred_init = (Word16)((5443 * ma_pred_init) >> 15);

		/* scale down by factor 20*log10(2) in Q15 */
		pred_state->past_qua_en_MR122[0] = ma_pred_init;
		pred_state->past_qua_en_MR122[1] = ma_pred_init;
		pred_state->past_qua_en_MR122[2] = ma_pred_init;
		pred_state->past_qua_en_MR122[3] = ma_pred_init;
	}   /* endif sid_frame */

		/*
		* CN generation
		* recompute level adjustment factor Q11
		* st->log_en_adjust = 0.9*st->log_en_adjust +
		*                     0.1*dtx_log_en_adjust[mode]);
		*/
	st->log_en_adjust = (Word16)(((st->log_en_adjust * 29491) >> 15) + ((
		(dtx_log_en_adjust[mode] << 5) * 3277) >> 20));

	/* Interpolate SID info */
	/* Q10 */
	if (st->since_last_sid > 30)
		int_fac = 32767;
	else
		int_fac = (Word16)((st->since_last_sid + 1) << 10);

	/* Q10 * Q15 -> Q10 */
	int_fac = (int_fac * st->true_sid_period_inv) >> 15;

	/* Maximize to 1.0 in Q10 */
	if (int_fac > 1024) {
		int_fac = 1024;
	}

	/* Q10 -> Q14 */
	int_fac = (Word16)(int_fac << 4);

	/* Q14 * Q11->Q26 */
	log_en_int = (int_fac * st->log_en) << 1;

	for (i = 0; i < M; i++) {
		/* Q14 * Q15 -> Q14 */
		lsp_int[i] = (int_fac * st->lsp[i]) >> 15;
	}

	/* 1-k in Q14 */
	int_fac = 16384 - int_fac;

	/* (Q14 * Q11 -> Q26) + Q26 -> Q26 */
	log_en_int += (int_fac * st->old_log_en) << 1;

	for (i = 0; i < M; i++) {
		/* Q14 + (Q14 * Q15 -> Q14) -> Q14 */
		lsp_int[i] = lsp_int[i] + ((int_fac * st->lsp_old[i]) >> 15);

		/* Q14 -> Q15 */
		lsp_int[i] = lsp_int[i] << 1;
	}

	/* compute the amount of lsf variability */
	/* -0.6 in Q12 */
	lsf_variab_factor = st->log_pg_mean - 2457;

	/* *0.3 Q12*Q15 -> Q12 */
	lsf_variab_factor = 4096 - ((lsf_variab_factor * 9830) >> 15);

	/* limit to values between 0..1 in Q12 */
	if (lsf_variab_factor >= 4096) {
		lsf_variab_factor = 32767;
	}
	else if (lsf_variab_factor < 0) {
		lsf_variab_factor = 0;
	}
	else
		lsf_variab_factor = lsf_variab_factor << 3;   /* -> Q15 */

													  /* get index of vector to do variability with */
	lsf_variab_index = pseudonoise(&st->pn_seed_rx, 3);

	/* convert to lsf */
	Lsp_lsf(lsp_int, lsf_int);

	/* apply lsf variability */
	memcpy(lsf_int_variab, lsf_int, M << 2);

	for (i = 0; i < M; i++) {
		lsf_int_variab[i] = lsf_int_variab[i] + ((lsf_variab_factor * st->
			lsf_hist_mean[i + lsf_variab_index * M]) >> 15);
	}

	/* make sure that LSP's are ordered */
	Reorder_lsf(lsf_int, LSF_GAP);
	Reorder_lsf(lsf_int_variab, LSF_GAP);

	/* copy lsf to speech decoders lsf state */
	memcpy(lsfState->past_lsf_q, lsf_int, M << 2);

	/* convert to lsp */
	Lsf_lsp(lsf_int, lsp_int);
	Lsf_lsp(lsf_int_variab, lsp_int_variab);

	/* Compute acoeffs Q12 acoeff is used for level
	* normalization and Post_Filter, acoeff_variab is
	* used for synthesis filter
	* by doing this we make sure that the level
	* in high frequenncies does not jump up and down
	*/
	Lsp_Az(lsp_int, acoeff);
	Lsp_Az(lsp_int_variab, acoeff_variab);

	/* For use in Post_Filter */
	memcpy(&A_t[0], acoeff, MP1 << 2);
	memcpy(&A_t[MP1], acoeff, MP1 << 2);
	memcpy(&A_t[MP1 << 1], acoeff, MP1 << 2);
	memcpy(&A_t[MP1 + MP1 + MP1], acoeff, MP1 << 2);

	/* Compute reflection coefficients Q15 */
	A_Refl(&acoeff[1], refl);

	/* Compute prediction error in Q15 */
	/* 0.99997 in Q15 */
	pred_err = MAX_16;

	for (i = 0; i < M; i++) {
		pred_err = (pred_err * (MAX_16 - ((refl[i] * refl[i]) >> 15))) >>
			15;
	}

	/* compute logarithm of prediction gain */
	Log2(pred_err, &log_pg_e, &log_pg_m);

	/* convert exponent and mantissa to Word16 Q12 */
	/* Q12 */
	log_pg = (log_pg_e - 15) << 12;
	/* saturate */
	if (log_pg < -32768) {
		log_pg = -32768;
	}
	log_pg = (-(log_pg + (log_pg_m >> 3))) >> 1;
	st->log_pg_mean = (Word16)(((29491 * st->log_pg_mean) >> 15) + ((3277
		* log_pg) >> 15));

	/* Compute interpolated log energy */
	/* Q26 -> Q16 */
	log_en_int = log_en_int >> 10;

	/* Add 4 in Q16 */
	log_en_int += 262144L;

	/* subtract prediction gain */
	log_en_int = log_en_int - (log_pg << 4);

	/* adjust level to speech coder mode */
	log_en_int += st->log_en_adjust << 5;
	log_en_int_e = (Word16)(log_en_int >> 16);
	log_en_int_m = (Word16)((log_en_int - (log_en_int_e << 16)) >> 1);

	/* Q4 */
	level = (Word16)(Pow2(log_en_int_e, log_en_int_m));

	for (i = 0; i < 4; i++) {
		/* Compute innovation vector */
		Build_CN_code(&st->pn_seed_rx, ex);

		for (j = 0; j < L_SUBFR; j++) {
			ex[j] = (level * ex[j]) >> 15;
		}

		/* Synthesize */
		Syn_filt(acoeff_variab, ex, &synth[i * L_SUBFR], L_SUBFR, mem_syn, 1);
	}   /* next i */

		/* reset codebook averaging variables */
	averState->hangVar = 20;
	averState->hangCount = 0;

	if (new_state == DTX_MUTE) {
		/*
		* mute comfort noise as it has been quite a long time since
		* last SID update  was performed
		*/
		Word32 num, denom;


		tmp_int_length = st->since_last_sid;

		if (tmp_int_length > 32) {
			tmp_int_length = 32;
		}

		if (tmp_int_length == 1) {
			st->true_sid_period_inv = MAX_16;
		}
		else {
			num = 1024;
			denom = (tmp_int_length << 10);
			st->true_sid_period_inv = 0;

			for (i = 0; i < 15; i++) {
				st->true_sid_period_inv <<= 1;
				num <<= 1;

				if (num >= denom) {
					num = num - denom;
					st->true_sid_period_inv += 1;
				}
			}
		}
		st->since_last_sid = 0;
		memcpy(st->lsp_old, st->lsp, M << 2);
		st->old_log_en = st->log_en;

		/* subtract 1/8 in Q11 i.e -6/8 dB */
		st->log_en = st->log_en - 256;
		if (st->log_en < -32768) st->log_en = -32768;
	}

	/*
	* reset interpolation length timer
	* if data has been updated.
	*/
	if ((st->sid_frame != 0) & ((st->valid_data != 0) || ((st->valid_data
		== 0) & (st->dtxHangoverAdded != 0)))) {
		st->since_last_sid = 0;
		st->data_updated = 1;
	}
	return;
}


/*
* lsp_avg
*
*
* Parameters:
*    st->lsp_meanSave  B: LSP averages
*    lsp               I: LSPs
*
* Function:
*    Calculate the LSP averages
*
* Returns:
*    void
*/
__device__ static void lsp_avg(lsp_avgState *st, Word32 *lsp)
{
	Word32 i, tmp;


	for (i = 0; i < M; i++) {
		/* mean = 0.84*mean */
		tmp = (st->lsp_meanSave[i] << 16);
		tmp -= (EXPCONST * st->lsp_meanSave[i]) << 1;

		/* Add 0.16 of newest LSPs to mean */
		tmp += (EXPCONST * lsp[i]) << 1;

		/* Save means */
		tmp += 0x00008000L;
		st->lsp_meanSave[i] = tmp >> 16;
	}
	return;
}


/*
* Int_lpc_1and3
*
*
* Parameters:
*    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
*    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
*    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
*    Az             O: interpolated LP parameters in subframes 1 and 3
*                                                                   [AZ_SIZE]
*
* Function:
*    Interpolates the LSPs and converts to LPC parameters
*    to get a different LP filter in each subframe.
*
*    The 20 ms speech frame is divided into 4 subframes.
*    The LSPs are quantized and transmitted at the 2nd and
*    4th subframes (twice per frame) and interpolated at the
*    1st and 3rd subframe.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1and3(Word32 lsp_old[], Word32 lsp_mid[], Word32 lsp_new[],
	Word32 Az[])
{
	Word32 lsp[M];
	Word32 i;


	/* lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
	for (i = 0; i < 10; i++) {
		lsp[i] = (lsp_mid[i] >> 1) + (lsp_old[i] >> 1);
	}

	/* Subframe 1 */
	Lsp_Az(lsp, Az);
	Az += MP1;

	/* Subframe 2 */
	Lsp_Az(lsp_mid, Az);
	Az += MP1;

	for (i = 0; i < 10; i++) {
		lsp[i] = (lsp_mid[i] >> 1) + (lsp_new[i] >> 1);
	}

	/* Subframe 3 */
	Lsp_Az(lsp, Az);
	Az += MP1;

	/* Subframe 4 */
	Lsp_Az(lsp_new, Az);
	return;
}


/*
* Int_lpc_1to3
*
*
* Parameters:
*    lsp_old           I: LSP vector at the 4th subframe of past frame    [M]
*    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
*    Az                O: interpolated LP parameters in all subframes
*                                                                   [AZ_SIZE]
*
* Function:
*    Interpolates the LSPs and converts to LPC parameters to get a different
*    LP filter in each subframe.
*
*    The 20 ms speech frame is divided into 4 subframes.
*    The LSPs are quantized and transmitted at the 4th
*    subframes (once per frame) and interpolated at the
*    1st, 2nd and 3rd subframe.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1to3(Word32 lsp_old[], Word32 lsp_new[], Word32 Az[])
{
	Word32 lsp[M];
	Word32 i;


	for (i = 0; i < 10; i++) {
		lsp[i] = (lsp_new[i] >> 2) + (lsp_old[i] - (lsp_old[i] >> 2));
	}

	/* Subframe 1 */
	Lsp_Az(lsp, Az);
	Az += MP1;

	for (i = 0; i < 10; i++) {
		lsp[i] = (lsp_old[i] >> 1) + (lsp_new[i] >> 1);
	}

	/* Subframe 2 */
	Lsp_Az(lsp, Az);
	Az += MP1;

	for (i = 0; i < 10; i++) {
		lsp[i] = (lsp_old[i] >> 2) + (lsp_new[i] - (lsp_new[i] >> 2));
	}

	/* Subframe 3 */
	Lsp_Az(lsp, Az);
	Az += MP1;

	/* Subframe 4 */
	Lsp_Az(lsp_new, Az);
	return;
}


/*
* D_plsf_5
*
*
* Parameters:
*    st->past_lsf_q I: Past dequantized LFSs
*    st->past_r_q      B: past quantized residual
*    bfi               B: bad frame indicator
*    indice            I: quantization indices of 3 submatrices, Q0
*    lsp1_q            O: quantized 1st LSP vector
*    lsp2_q            O: quantized 2nd LSP vector
*
* Function:
*    Decodes the 2 sets of LSP parameters in a frame
*    using the received quantization indices.
*
* Returns:
*    void
*/
__device__ static void D_plsf_5(D_plsfState *st, Word16 bfi, Word16 *indice, Word32 *lsp1_q
	, Word32 *lsp2_q)
{
	Word32 lsf1_r[M], lsf2_r[M], lsf1_q[M], lsf2_q[M];
	Word32 i, temp1, temp2, sign;
	const Word32 *p_dico;


	/* if bad frame */
	if (bfi != 0) {
		/* use the past LSFs slightly shifted towards their mean */
		for (i = 0; i < M; i += 2) {
			/* lsfi_q[i] = ALPHA*st->past_lsf_q[i] + ONE_ALPHA*meanLsf[i]; */
			lsf1_q[i] = ((st->past_lsf_q[i] * ALPHA_122) >> 15) + ((mean_lsf_5[i]
				* ONE_ALPHA_122) >> 15);
			lsf1_q[i + 1] = ((st->past_lsf_q[i + 1] * ALPHA_122) >> 15) + ((
				mean_lsf_5[i + 1] * ONE_ALPHA_122) >> 15);
		}
		memcpy(lsf2_q, lsf1_q, M << 2);

		/* estimate past quantized residual to be used in next frame */
		for (i = 0; i < M; i += 2) {
			/* temp  = meanLsf[i] +  st->past_r_q[i] * LSPPpred_facMR122; */
			temp1 = mean_lsf_5[i] + ((st->past_r_q[i] * LSP_PRED_FAC_MR122) >>
				15);
			temp2 = mean_lsf_5[i + 1] + ((st->past_r_q[i + 1] * LSP_PRED_FAC_MR122
				) >> 15);
			st->past_r_q[i] = lsf2_q[i] - temp1;
			st->past_r_q[i + 1] = lsf2_q[i + 1] - temp2;
		}
	}

	/* if good LSFs received */
	else {
		/* decode prediction residuals from 5 received indices */
		p_dico = &dico1_lsf_5[indice[0] << 2];
		lsf1_r[0] = *p_dico++;
		lsf1_r[1] = *p_dico++;
		lsf2_r[0] = *p_dico++;
		lsf2_r[1] = *p_dico++;
		p_dico = &dico2_lsf_5[indice[1] << 2];
		lsf1_r[2] = *p_dico++;
		lsf1_r[3] = *p_dico++;
		lsf2_r[2] = *p_dico++;
		lsf2_r[3] = *p_dico++;
		sign = (Word16)(indice[2] & 1);
		i = indice[2] >> 1;
		p_dico = &dico3_lsf_5[i << 2];

		if (sign == 0) {
			lsf1_r[4] = *p_dico++;
			lsf1_r[5] = *p_dico++;
			lsf2_r[4] = *p_dico++;
			lsf2_r[5] = *p_dico++;
		}
		else {
			lsf1_r[4] = (Word16)(-(*p_dico++));
			lsf1_r[5] = (Word16)(-(*p_dico++));
			lsf2_r[4] = (Word16)(-(*p_dico++));
			lsf2_r[5] = (Word16)(-(*p_dico++));
		}
		p_dico = &dico4_lsf_5[(indice[3] << 2)];
		lsf1_r[6] = *p_dico++;
		lsf1_r[7] = *p_dico++;
		lsf2_r[6] = *p_dico++;
		lsf2_r[7] = *p_dico++;
		p_dico = &dico5_lsf_5[(indice[4] << 2)];
		lsf1_r[8] = *p_dico++;
		lsf1_r[9] = *p_dico++;
		lsf2_r[8] = *p_dico++;
		lsf2_r[9] = *p_dico++;

		/* Compute quantized LSFs and update the past quantized residual */
		for (i = 0; i < M; i++) {
			temp1 = mean_lsf_5[i] + ((st->past_r_q[i] * LSP_PRED_FAC_MR122) >>
				15);
			lsf1_q[i] = lsf1_r[i] + temp1;
			lsf2_q[i] = lsf2_r[i] + temp1;
			st->past_r_q[i] = lsf2_r[i];
		}
	}

	/* verification that LSFs have minimum distance of LSF_GAP Hz */
	Reorder_lsf(lsf1_q, LSF_GAP);
	Reorder_lsf(lsf2_q, LSF_GAP);
	memcpy(st->past_lsf_q, lsf2_q, M << 2);

	/*  convert LSFs to the cosine domain */
	Lsf_lsp(lsf1_q, lsp1_q);
	Lsf_lsp(lsf2_q, lsp2_q);
	return;
}


/*
* Dec_lag3
*
*
* Parameters:
*    index             I: received pitch index
*    t0_min            I: minimum of search range
*    t0_max            I: maximum of search range
*    i_subfr           I: subframe flag
*    T0_prev           I: integer pitch delay of last subframe used
*                         in 2nd and 4th subframes
*    T0                O: integer part of pitch lag
*    T0_frac           O : fractional part of pitch lag
*    flag4             I : flag for encoding with 4 bits
* Function:
*    Decoding of fractional pitch lag with 1/3 resolution.
*    Extract the integer and fraction parts of the pitch lag from
*    the received adaptive codebook index.
*
*    The fractional lag in 1st and 3rd subframes is encoded with 8 bits
*    while that in 2nd and 4th subframes is relatively encoded with 4, 5
*    and 6 bits depending on the mode.
*
* Returns:
*    void
*/
__device__ static void Dec_lag3(Word32 index, Word32 t0_min, Word32 t0_max, Word32 i_subfr
	, Word32 T0_prev, Word32 *T0, Word32 *T0_frac, Word32 flag4)
{
	Word32 i, tmp_lag;


	/* if 1st or 3rd subframe */
	if (i_subfr == 0) {
		if (index < 197) {
			*T0 = (((index + 2) * 10923) >> 15) + 19;
			i = *T0 + *T0 + *T0;
			*T0_frac = (index - i) + 58;
		}
		else {
			*T0 = index - 112;
			*T0_frac = 0;
		}
	}

	/* 2nd or 4th subframe */
	else {
		if (flag4 == 0) {
			/* 'normal' decoding: either with 5 or 6 bit resolution */
			i = (((index + 2) * 10923) >> 15) - 1;
			*T0 = i + t0_min;
			i = i + i + i;
			*T0_frac = (index - 2) - i;
		}
		else {
			/* decoding with 4 bit resolution */
			tmp_lag = T0_prev;

			if ((tmp_lag - t0_min) > 5)
				tmp_lag = t0_min + 5;

			if ((t0_max - tmp_lag) > 4)
				tmp_lag = t0_max - 4;

			if (index < 4) {
				i = (tmp_lag - 5);
				*T0 = i + index;
				*T0_frac = 0;
			}
			else {
				if (index < 12) {
					i = (((index - 5) * 10923) >> 15) - 1;
					*T0 = i + tmp_lag;
					i = i + i + i;
					*T0_frac = (index - 9) - i;
				}
				else {
					i = (index - 12) + tmp_lag;
					*T0 = i + 1;
					*T0_frac = 0;
				}
			}
		}   /* end if (decoding with 4 bit resolution) */
	}
	return;
}


/*
* Pred_lt_3or6_40
*
*
* Parameters:
*    exc               B: excitation buffer
*    T0                I: integer pitch lag
*    frac              I: fraction of lag
*    flag3             I: if set, upsampling rate = 3 (6 otherwise)
*
* Function:
*    Compute the result of long term prediction with fractional
*    interpolation of resolution 1/3 or 1/6. (Interpolated past excitation).
*
*    Once the fractional pitch lag is determined,
*    the adaptive codebook vector v(n) is computed by interpolating
*    the past excitation signal u(n) at the given integer delay k
*    and phase (fraction)  :
*
*          9                       9
*    v(n) = SUM[ u(n-k-i) * b60(t+i*6) ] + SUM[ u(n-k+1+i) * b60(6-t+i*6) ],
*          i=0                       i=0
*    n = 0, ...,39, t = 0, ...,5.
*
*    The interpolation filter b60 is based on a Hamming windowed sin(x)/x
*    function truncated at \A1\C0 59 and padded with zeros at \A1\C0 60 (b60(60)=0)).
*    The filter has a cut-off frequency (-3 dB) at 3 600 Hz in
*    the over-sampled domain.
*
* Returns:
*    void
*/
__device__ static void Pred_lt_3or6_40(Word32 exc[], Word32 T0, Word32 frac, Word32 flag3)
{
	Word32 s, i;
	Word32 *x0, *x1, *x2;
	const Word32 *c1, *c2;


	x0 = &exc[-T0];
	frac = -frac;

	if (flag3 != 0) {
		frac <<= 1;   /* inter_3l[k] = inter6[2*k] -> k' = 2*k */
	}

	if (frac < 0) {
		frac += 6;
		x0--;
	}
	c1 = &inter6[frac];
	c2 = &inter6[6 - frac];

	for (i = 0; i < 40; i++) {
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0];
		s += x1[-1] * c1[6];
		s += x1[-2] * c1[12];
		s += x1[-3] * c1[18];
		s += x1[-4] * c1[24];
		s += x1[-5] * c1[30];
		s += x1[-6] * c1[36];
		s += x1[-7] * c1[42];
		s += x1[-8] * c1[48];
		s += x1[-9] * c1[54];
		s += x2[0] * c2[0];
		s += x2[1] * c2[6];
		s += x2[2] * c2[12];
		s += x2[3] * c2[18];
		s += x2[4] * c2[24];
		s += x2[5] * c2[30];
		s += x2[6] * c2[36];
		s += x2[7] * c2[42];
		s += x2[8] * c2[48];
		s += x2[9] * c2[54];
		exc[i] = (s + 0x4000) >> 15;

	}
}


/*
* Dec_lag6
*
*
* Parameters:
*    index             I: received pitch index
*    pit_min           I: minimum pitch lag
*    pit_max           I: maximum pitch lag
*    i_subfr           I: subframe flag
*    T0                B: integer part of pitch lag
*    T0_frac           O : fractional part of pitch lag
*
* Function:
*    Decoding of fractional pitch lag with 1/6 resolution.
*    Extract the integer and fraction parts of the pitch lag from
*    the received adaptive codebook index.
*
*    The fractional lag in 1st and 3rd subframes is encoded with 9 bits
*    while that in 2nd and 4th subframes is relatively encoded with 6 bits.
*    Note that in relative encoding only 61 values are used. If the
*    decoder receives 61, 62, or 63 as the relative pitch index, it means
*    that a transmission error occurred. In this case, the pitch lag from
*    previous subframe (actually from previous frame) is used.
*
* Returns:
*    void
*/
__device__ static void Dec_lag6(Word32 index, Word32 pit_min, Word32 pit_max, Word32
	i_subfr, Word32 *T0, Word32 *T0_frac)
{
	Word32 t0_min, t0_max, i;


	/* if 1st or 3rd subframe */
	if (i_subfr == 0) {
		if (index < 463) {
			/* T0 = (index+5)/6 + 17 */
			*T0 = (index + 5) / 6 + 17;
			i = *T0 + *T0 + *T0;

			/* *T0_frac = index - T0*6 + 105 */
			*T0_frac = (index - (i + i)) + 105;
		}
		else {
			*T0 = index - 368;
			*T0_frac = 0;
		}
	}

	/* second or fourth subframe */
	else {
		/* find t0_min and t0_max for 2nd (or 4th) subframe */
		t0_min = *T0 - 5;

		if (t0_min < pit_min) {
			t0_min = pit_min;
		}
		t0_max = t0_min + 9;

		if (t0_max > pit_max) {
			t0_max = pit_max;
			t0_min = t0_max - 9;
		}

		/* i = (index+5)/6 - 1 */
		i = (index + 5) / 6 - 1;
		*T0 = i + t0_min;
		i = i + i + i;
		*T0_frac = (index - 3) - (i + i);
	}
}


/*
* decompress10
*
*
* Parameters:
*    MSBs              I: MSB part of the index
*    LSBs              I: LSB part of the index
*    index1            I: index for first pos in posIndex
*    index2            I: index for second pos in posIndex
*    index3            I: index for third pos in posIndex
*    pos_indx          O: position of 3 pulses (decompressed)
* Function:
*    Decompression of the linear codeword
*
* Returns:
*    void
*/
__device__ static void decompress10(Word32 MSBs, Word32 LSBs, Word32 index1, Word32 index2
	, Word32 index3, Word32 pos_indx[])
{
	Word32 divMSB;

	if (MSBs > 124)
	{
		MSBs = 124;
	}
	/*
	* pos_indx[index1] = ((MSBs-25*(MSBs/25))%5)*2 + (LSBs-4*(LSBs/4))%2;
	* pos_indx[index2] = ((MSBs-25*(MSBs/25))/5)*2 + (LSBs-4*(LSBs/4))/2;
	* pos_indx[index3] = (MSBs/25)*2 + LSBs/4;
	*/
	divMSB = MSBs / 25;
	pos_indx[index1] = (((MSBs - 25 * (divMSB)) % 5) << 1) + (LSBs & 0x1
		);
	pos_indx[index2] = (((MSBs - 25 * (divMSB)) / 5) << 1) + ((LSBs &
		0x2) >> 1);
	pos_indx[index3] = (divMSB << 1) + (LSBs >> 2);
	return;
}


/*
* decompress_codewords
*
*
* Parameters:
*    indx              I: position of 8 pulses (compressed)
*    pos_indx          O: position index of 8 pulses (position only)
*
* Function:
*    Decompression of the linear codewords to 4+three indeces
*    one bit from each pulse is made robust to errors by
*    minimizing the phase shift of a bit error.
*
*    i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
*    i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
*    i3,i7    => one index (5+2) bits, 2-3 LSbs more robust
*
* Returns:
*    void
*/
__device__ static void decompress_codewords(Word16 indx[], Word32 pos_indx[])
{
	Word32 ia, ib, MSBs, LSBs, MSBs0_24, tmp;


	/*
	* First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
	* MSBs = indx[NB_TRACK]/8;
	* LSBs = indx[NB_TRACK]%8;
	*/
	MSBs = *indx >> 3;
	LSBs = *indx & 0x7;
	decompress10(MSBs, LSBs, 0, 4, 1, pos_indx);

	/*
	* Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits
	* MSBs = indx[NB_TRACK+1]/8;
	* LSBs = indx[NB_TRACK+1]%8;
	*/
	MSBs = indx[1] >> 3;
	LSBs = indx[1] & 0x7;
	decompress10(MSBs, LSBs, 2, 6, 5, pos_indx);

	/*
	* Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits
	* MSBs = indx[NB_TRACK+2]/4;
	* LSBs = indx[NB_TRACK+2]%4;
	* MSBs0_24 = (MSBs*25+12)/32;
	* if ((MSBs0_24/5)%2==1)
	*    pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
	* else
	*    pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
	* pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
	*/
	MSBs = indx[2] >> 2;
	LSBs = indx[2] & 0x3;
	MSBs0_24 = (((MSBs * 25) + 12) >> 5);
	tmp = (MSBs0_24 * 6554) >> 15;
	ia = tmp & 0x1;
	ib = (MSBs0_24 - (tmp * 5));

	if (ia == 1) {
		ib = 4 - ib;
	}
	pos_indx[3] = (ib << 1) + (LSBs & 0x1);
	pos_indx[7] = (tmp << 1) + (LSBs >> 1);
}


/*
* decode_2i40_9bits
*
*
* Parameters:
*    subNr             I: subframe number
*    sign              I: signs of 2 pulses
*    index             I: Positions of the 2 pulses
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_2i40_9bits(Word32 subNr, Word32 sign, Word32 index, Word32
	cod[])
{
	Word32 pos[2];
	Word32 i, j, k;


	/* Decode the positions */
	/* table bit  is the MSB */
	j = (index & 64) >> 6;
	i = index & 7;

	/* pos0 =i*5+startPos[j*8+subNr*2] */
	i = (i + (i << 2));
	k = startPos[(j << 3) + (subNr << 1)];
	pos[0] = i + k;
	index = index >> 3;
	i = index & 7;

	/* pos1 =i*5+startPos[j*8+subNr*2+1] */
	i = (i + (i << 2));
	k = startPos[((j << 3) + (subNr << 1)) + 1];
	pos[1] = (Word16)(i + k);

	/* decode the signs  and build the codeword */
	memset(cod, 0, L_SUBFR << 2);

	for (j = 0; j < 2; j++) {
		i = sign & 1;
		sign = sign >> 1;

		if (i != 0) {
			cod[pos[j]] = 8191;   /* +1.0 */
		}
		else {
			cod[pos[j]] = -8192;   /* -1.0 */
		}
	}
	return;
}


/*
* decode_2i40_11bits
*
*
* Parameters:
*    sign              I: signs of 2 pulses
*    index             I: Positions of the 2 pulses
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_2i40_11bits(Word32 sign, Word32 index, Word32 cod[])
{
	Word32 pos[2];
	Word32 i, j;


	/* Decode the positions */
	j = index & 1;
	index = index >> 1;
	i = index & 7;

	/* pos0 =i*5+1+j*2 */
	i = (i + (i << 2));
	i = (i + 1);
	j = (j << 1);
	pos[0] = i + j;
	index = index >> 3;
	j = index & 3;
	index = index >> 2;
	i = index & 7;

	if (j == 3) {
		/* pos1 =i*5+4 */
		i = (i + (i << 2));
		pos[1] = i + 4;
	}
	else {
		/* pos1 =i*5+j */
		i = (i + (i << 2));
		pos[1] = i + j;
	}

	/* decode the signs  and build the codeword */
	memset(cod, 0, L_SUBFR << 2);

	for (j = 0; j < 2; j++) {
		i = sign & 1;
		sign = sign >> 1;

		if (i != 0) {
			cod[pos[j]] = 8191;   /* +1.0 */
		}
		else {
			cod[pos[j]] = -8192;   /* -1.0 */
		}
	}
	return;
}


/*
* decode_3i40_14bits
*
*
* Parameters:
*    sign              I: signs of 3 pulses
*    index             I: Positions of the 3 pulses
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_3i40_14bits(Word32 sign, Word32 index, Word32 cod[])
{
	Word32 pos[3];
	Word32 i, j;


	/* Decode the positions */
	i = index & 7;

	/* pos0 =i*5 */
	pos[0] = i + (i << 2);
	index = index >> 3;
	j = index & 1;
	index = index >> 1;
	i = index & 7;

	/* pos1 =i*5+1+j*2 */
	i = (i + (i << 2));
	i = (i + 1);
	j = (j << 1);
	pos[1] = i + j;
	index = index >> 3;
	j = index & 1;
	index = index >> 1;
	i = index & 7;

	/* pos2 =i*5+2+j*2 */
	i = (i + (i << 2));
	i = (i + 2);
	j = (j << 1);
	pos[2] = i + j;

	/* decode the signs  and build the codeword */
	memset(cod, 0, L_SUBFR << 2);

	for (j = 0; j < 3; j++) {
		i = sign & 1;
		sign = sign >> 1;

		if (i > 0) {
			cod[pos[j]] = 8191;   /* +1.0 */
		}
		else {
			cod[pos[j]] = -8192;   /* -1.0 */
		}
	}
	return;
}


/*
* decode_3i40_14bits
*
*
* Parameters:
*    sign              I: signs of 4 pulses
*    index             I: Positions of the 4 pulses
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_4i40_17bits(Word32 sign, Word32 index, Word32 cod[])
{
	Word32 pos[4];
	Word32 i, j;


	/* Decode the positions */
	i = index & 7;
	i = dgray[i];

	/* pos0 =i*5 */
	pos[0] = i + (i << 2);
	index = index >> 3;
	i = index & 7;
	i = dgray[i];

	/* pos1 =i*5+1 */
	i = (i + (i << 2));
	pos[1] = i + 1;
	index = index >> 3;
	i = index & 7;
	i = dgray[i];

	/* pos2 =i*5+1 */
	i = (i + (i << 2));
	pos[2] = i + 2;
	index = index >> 3;
	j = index & 1;
	index = index >> 1;
	i = index & 7;
	i = dgray[i];

	/* pos3 =i*5+3+j */
	i = (i + (i << 2));
	i = (i + 3);
	pos[3] = i + j;

	/* decode the signs  and build the codeword */
	memset(cod, 0, L_SUBFR << 2);

	for (j = 0; j < 4; j++) {
		i = sign & 1;
		sign = sign >> 1;

		if (i != 0) {
			cod[pos[j]] = 8191;
		}
		else {
			cod[pos[j]] = -8192;
		}
	}
	return;
}


/*
* decode_8i40_31bits
*
*
* Parameters:
*    index             I: index of 8 pulses (sign+position)
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_8i40_31bits(Word16 index[], Word32 cod[])
{
	Word32 linear_codewords[8];
	Word32 i, j, pos1, pos2, sign;


	memset(cod, 0, L_CODE << 2);
	decompress_codewords(&index[NB_TRACK_MR102], linear_codewords);

	/* decode the positions and signs of pulses and build the codeword */
	for (j = 0; j < NB_TRACK_MR102; j++) {
		/* compute index i */
		i = linear_codewords[j];
		i <<= 2;

		/* position of pulse "j" */
		pos1 = i + j;

		if (index[j] == 0) {
			sign = POS_CODE;   /* +1.0 */
		}
		else {
			sign = -NEG_CODE;   /* -1.0 */
		}

		/* compute index i */
		i = linear_codewords[j + 4];
		i = i << 2;

		/* position of pulse "j+4" */
		pos2 = i + j;
		cod[pos1] = sign;

		if (pos2 < pos1) {
			sign = -(sign);
		}
		cod[pos2] = cod[pos2] + sign;
	}
	return;
}


/*
* decode_10i40_35bits
*
*
* Parameters:
*    index             I: index of 10 pulses (sign+position)
*    cod               O: algebraic (fixed) codebook excitation
*
* Function:
*    Algebraic codebook decoder
*
* Returns:
*    void
*/
__device__ static void decode_10i40_35bits(Word16 index[], Word32 cod[])
{
	Word32 i, j, pos1, pos2, sign, tmp;


	memset(cod, 0, L_CODE << 2);

	/* decode the positions and signs of pulses and build the codeword */
	for (j = 0; j < 5; j++) {
		/* compute index i */
		tmp = index[j];
		i = tmp & 7;
		i = dgray[i];
		i = (i * 5);

		/* position of pulse "j" */
		pos1 = (i + j);
		i = (tmp >> 3) & 1;

		if (i == 0) {
			sign = 4096;   /* +1.0 */
		}
		else {
			sign = -4096;   /* -1.0 */
		}

		/* compute index i */
		i = index[j + 5] & 7;
		i = dgray[i];
		i = i * 5;

		/* position of pulse "j+5" */
		pos2 = (i + j);
		cod[pos1] = sign;

		if (pos2 < pos1) {
			sign = -(sign);
		}
		cod[pos2] = cod[pos2] + sign;
	}
	return;
}


/*
* gmed_n
*
*
* Parameters:
*    ind               I: values
*    n                 I: The number of gains (odd)
*
* Function:
*    Calculates N-point median.
*
* Returns:
*    index of the median value
*/
__device__ static Word32 gmed_n(Word32 ind[], Word32 n)
{
	Word32 tmp[NMAX], tmp2[NMAX];
	Word32 max, medianIndex, i, j, ix = 0;


	for (i = 0; i < n; i++) {
		tmp2[i] = ind[i];
	}

	for (i = 0; i < n; i++) {
		max = -32767;

		for (j = 0; j < n; j++) {
			if (tmp2[j] >= max) {
				max = tmp2[j];
				ix = j;
			}
		}
		tmp2[ix] = -32768;
		tmp[i] = ix;
	}
	medianIndex = tmp[(n >> 1)];
	return(ind[medianIndex]);
}


/*
* ec_gain_pitch
*
*
* Parameters:
*    st->pbuf          I: last five gains
*    st->past_gain_pit I: past gain
*    state             I: state of the state machine
*    gain_pitch        O: pitch gain
*
* Function:
*    Calculates pitch from previous values.
*
* Returns:
*    void
*/
__device__ static void ec_gain_pitch(ec_gain_pitchState *st, Word16 state, Word32 *
	gain_pitch)
{
	Word32 tmp;


	/* calculate median of last five gains */
	tmp = gmed_n(st->pbuf, 5);

	/* new gain = minimum(median, past_gain) * pdown[state] */
	if (tmp > st->past_gain_pit) {
		tmp = st->past_gain_pit;
	}
	*gain_pitch = (tmp * pdown[state]) >> 15;
}


/*
* d_gain_pitch
*
*
* Parameters:
*    mode              I: AMR mode
*    index             I: index of quantization
*
* Function:
*    Decodes the pitch gain using the received index
*
* Returns:
*    gain
*/
__device__ static Word32 d_gain_pitch(enum Mode mode, Word32 index)
{
	Word32 gain;


	if (mode == MR122) {
		/* clear 2 LSBits */
		gain = (qua_gain_pitch[index] >> 2) << 2;
	}
	else {
		gain = qua_gain_pitch[index];
	}
	return gain;
}


/*
* ec_gain_pitch_update
*
*
* Parameters:
*    st->prev_gp       B: previous pitch gain
*    st->past_gain_pit O: past gain
*    st->pbuf          B: past gain buffer
*    bfi               I: bad frame indicator
*    prev_bf           I: previous frame was bad
*    gain_pitch        B: pitch gain
*
* Function:
*    Update the pitch gain concealment state
*    Limit gain_pitch if the previous frame was bad
*
* Returns:
*    gain
*/
__device__ static void ec_gain_pitch_update(ec_gain_pitchState *st, Word32 bfi,
	Word32 prev_bf, Word32 *gain_pitch)
{
	if (bfi == 0) {
		if (prev_bf != 0) {
			if (*gain_pitch > st->prev_gp) {
				*gain_pitch = st->prev_gp;
			}
		}
		st->prev_gp = *gain_pitch;
	}
	st->past_gain_pit = *gain_pitch;

	/* if (st->past_gain_pit > 1.0) */
	if (st->past_gain_pit > 16384) {
		st->past_gain_pit = 16384;
	}
	st->pbuf[0] = st->pbuf[1];
	st->pbuf[1] = st->pbuf[2];
	st->pbuf[2] = st->pbuf[3];
	st->pbuf[3] = st->pbuf[4];
	st->pbuf[4] = st->past_gain_pit;
}


/*
* gc_pred (366)
*
*
* Parameters:
*    st->past_qua_en         I: MA predictor
*    st->past_qua_en_MR122   I: MA predictor MR122
*    mode                    I: AMR mode
*    code                    I: innovative codebook vector
*    exp_gcode0              O: predicted gain factor (exponent)
*    frac_gcode0             O: predicted gain factor (fraction)
*    exp_en                  I: innovation energy (MR795) (exponent)
*    frac_en                 I: innovation energy (MR795) (fraction)
*
* Function:
*    MA prediction of the innovation energy
*
*    Mean removed innovation energy (dB) in subframe n
*                          N-1
*    E(n) = 10*log(gc*gc * SUM[(code(i) * code(i)]/N) - EMean
*                          i=0
*    N=40
*
*    Mean innovation energy (dB)
*                   N-1
*    Ei(n) = 10*log(SUM[(code(i) * code(i)]/N)
*                   i=0
*
*    Predicted energy
*              4
*    Ep(n) = SUM[b(i) * R(n-i)]
*            i=1
*    b = [0.68 0.58 0.34 0.19]
*    R(k) is quantified prediction error at subframe k
*
*    E_Mean = 36 dB (MR122)
*
*    Predicted gain gc is found by
*
*    gc = POW[10, 0.05 * (Ep(n) + EMean - Ei)]
*
* Returns:
*    void
*/
__device__ static void gc_pred(dec_gc_predState *st, enum Mode mode, Word32 *code, Word32 *
	exp_gcode0, Word32 *frac_gcode0, Word32 *exp_en, Word32 *frac_en)
{
	Word32 exp, frac, ener_code = 0, i = 0;


	/* energy of code:
	* ener_code = sum(code[i]^2)
	*/
	while (i < L_SUBFR) {
		ener_code += code[i] * code[i];
		i++;
	}

	if ((0x3fffffff <= ener_code) | (ener_code < 0))
		ener_code = MAX_32;
	else
		ener_code <<= 1;

	if (mode == MR122) {
		Word32 ener;


		/* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
		ener_code = ((ener_code + 0x00008000L) >> 16) * 52428;

		/* Q9  * Q20 -> Q30 */
		/* energy of code:
		* ener_code(Q17) = 10 * Log10(energy) / constant
		*                = 1/2 * Log2(energy)
		* constant = 20*Log10(2)
		*/
		/* ener_code = 1/2 * Log2(ener_code); Note: Log2=log2+30 */
		Log2(ener_code, &exp, &frac);
		ener_code = ((exp - 30) << 16) + (frac << 1);

		/* Q16 for log(), ->Q17 for 1/2 log() */
		/*
		* predicted energy:
		* ener(Q24) = (Emean + sum{pred[i]*pastEn[i]})/constant
		*           = MEAN_ENER + sum(pred[i]*past_qua_en[i])
		* constant = 20*Log10(2)
		*/
		ener = 0;
		i = 0;

		while (i < 4) {
			ener += st->past_qua_en_MR122[i] * pred_MR122[i];
			i++;
		}
		ener <<= 1;
		ener += MEAN_ENER_MR122;

		/*
		* predicted codebook gain

		* gc0 = Pow10( (ener*constant - ener_code*constant) / 20 )
		*     = Pow2(ener-ener_code)
		*     = Pow2(int(d)+frac(d))
		*/
		ener = (ener - ener_code) >> 1;   /* Q16 */
		*exp_gcode0 = ener >> 16;
		*frac_gcode0 = (ener >> 1) - (*exp_gcode0 << 15);
	}

	/* all modes except 12.2 */
	else {
		Word32 tmp, gcode0;
		int exp_code;


		/*
		* Compute: meansEner - 10log10(ener_code/ LSufr)
		*/
		exp_code = 0;
		if (ener_code != 0) {
			while (!(ener_code & 0x40000000))
			{
				exp_code++;
				ener_code = ener_code << 1;
			}
		}

		/* Log2 = log2 + 27 */
		Log2_norm(ener_code, exp_code, &exp, &frac);

		/* fact = 10/log2(10) = 3.01 = 24660 Q13 */
		/* Q0.Q15 * Q13 -> Q14 */
		tmp = (exp * (-49320)) + (((frac * (-24660)) >> 15) << 1);

		/*
		* tmp = meansEner - 10log10(ener_code/L_SUBFR)
		*       = meansEner - 10log10(ener_code) + 10log10(L_SUBFR)
		*       = K - fact * Log2(ener_code)
		*     = K - fact * log2(ener_code) - fact*27
		*
		*   ==> K = meansEner + fact*27 + 10log10(L_SUBFR)
		*
		*   meansEner =       33    =  540672    Q14  (MR475, MR515, MR59)
		*   meansEner =       28.75 =  471040    Q14  (MR67)
		*   meansEner =       30    =  491520    Q14  (MR74)
		*   meansEner =       36    =  589824    Q14  (MR795)
		*   meansEner =       33    =  540672    Q14  (MR102)
		*   10log10(L_SUBFR) = 16.02 =  262481.51 Q14
		*   fact * 27                = 1331640    Q14
		*   -----------------------------------------
		*   (MR475, MR515, MR59)   K = 2134793.51 Q14 ~= 16678 * 64 * 2
		*   (MR67)                 K = 2065161.51 Q14 ~= 32268 * 32 * 2
		*   (MR74)                 K = 2085641.51 Q14 ~= 32588 * 32 * 2
		*   (MR795)                K = 2183945.51 Q14 ~= 17062 * 64 * 2
		*   (MR102)                K = 2134793.51 Q14 ~= 16678 * 64 * 2
		*/
		if (mode == MR102) {
			/* mean = 33 dB */
			tmp += 2134784;   /* Q14 */
		}
		else if (mode == MR795) {
			/* mean = 36 dB */
			tmp += 2183936;   /* Q14 */

							  /*
							  * ener_code  = <xn xn> * 2^27*2^exp_code
							  * frac_en    = ener_code / 2^16
							  *            = <xn xn> * 2^11*2^exp_code
							  * <xn xn>    = <xn xn>*2^11*2^exp * 2^exp_en
							  *           := frac_en            * 2^exp_en
							  *
							  * ==> exp_en = -11-exp_code;
							  */
			*frac_en = ener_code >> 16;
			*exp_en = -11 - exp_code;
		}
		else if (mode == MR74) {
			/* mean = 30 dB */
			tmp += 2085632;   /* Q14 */
		}
		else if (mode == MR67) {
			/* mean = 28.75 dB */
			tmp += 2065152;   /* Q14 */
		}
		else /* MR59, MR515, MR475 */ {
			/* mean = 33 dB */
			tmp += 2134784;   /* Q14 */
		}

		/*
		* Compute gcode0
		* = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + meanEner
		*/
		tmp = tmp << 9;   /* Q23 */

						  /* Q13 * Q10 -> Q23 */
		i = 0;

		while (i < 4) {
			tmp += pred[i] * st->past_qua_en[i];
			i++;
		}
		gcode0 = tmp >> 15;   /* Q8  */

							  /*
							  * gcode0 = pow(10.0, gcode0/20)
							  *        = pow(2, 3.3219*gcode0/20)
							  *        = pow(2, 0.166*gcode0)
							  */
							  /* 5439 Q15 = 0.165985                                        */
							  /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
							  /* For IS641 bitexactness */
		if (mode == MR74) {
			/* Q8 * Q15 -> Q24 */
			tmp = gcode0 * 10878;
		}
		else {
			/* Q8 * Q15 -> Q24 */
			tmp = gcode0 * 10886;
		}
		tmp = tmp >> 9;   /* -> Q15 */

						  /* -> Q0.Q15 */
		*exp_gcode0 = tmp >> 15;
		*frac_gcode0 = tmp - (*exp_gcode0 * 32768);
	}
}


/*
* gc_pred_update
*
*
* Parameters:
*    st->past_qua_en         B: MA predictor
*    st->past_qua_en_MR122   B: MA predictor MR122
*    qua_ener_MR122          I: quantized energy for update (log2(quaErr))
*    qua_ener                I: quantized energy for update (20*log10(quaErr))
*
* Function:
*    Update MA predictor with last quantized energy
*
* Returns:
*    void
*/
__device__ static void gc_pred_update(dec_gc_predState *st, Word32 qua_ener_MR122,
	Word32 qua_ener)
{
	Word32 i;


	for (i = 3; i > 0; i--) {
		st->past_qua_en[i] = st->past_qua_en[i - 1];
		st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1];
	}
	st->past_qua_en_MR122[0] = qua_ener_MR122;   /* log2 (quaErr), Q10 */
	st->past_qua_en[0] = qua_ener;   /* 20*log10(quaErr), Q10 */
}


/*
* Dec_gain
*
*
* Parameters:
*    pred_state->past_qua_en       B: MA predictor
*    pred_state->past_qua_en_MR122 B: MA predictor MR122
*    mode                          I: AMR mode
*    index                         I: index of quantization
*    code                          I: Innovative vector
*    evenSubfr                     I: Flag for even subframes
*    gain_pit                      O: Pitch gain
*    gain_cod                      O: Code gain
*
* Function:
*    Decode the pitch and codebook gains
*
* Returns:
*    void
*/
__device__ static void Dec_gain(dec_gc_predState *pred_state, enum Mode mode, Word32 index,
	Word32 code[], Word32 evenSubfr, Word32 *gain_pit, Word32 *gain_cod)
{
	Word32 frac, gcode0, exp, qua_ener, qua_ener_MR122, g_code, tmp;
	const Word32 *p;


	/* Read the quantized gains (table depends on mode) */
	index = index << 2;

	if ((mode == MR102) || (mode == MR74) || (mode == MR67)) {
		p = &table_gain_highrates[index];
		*gain_pit = *p++;
		g_code = *p++;
		qua_ener_MR122 = *p++;
		qua_ener = *p;
	}
	else {
		if (mode == MR475) {
			index = index + ((1 - evenSubfr) << 1);
			p = &table_gain_MR475[index];
			*gain_pit = *p++;
			g_code = *p++;

			/*
			* calculate predictor update values (not stored in 4.75
			* quantizer table to save space):
			*   qua_ener       = log2(g)
			*   qua_ener_MR122 = 20*log10(g)
			*/
			/* Log2(x Q12) = log2(x) + 12 */
			Log2(g_code, &exp, &frac);
			exp = exp - 12;
			tmp = frac >> 5;

			if ((frac & ((Word16)1 << 4)) != 0) {
				tmp++;
			}
			qua_ener_MR122 = tmp + (exp << 10);

			/* 24660 Q12 ~= 6.0206 = 20*log10(2) */
			tmp = exp * 49320;
			tmp += (((frac * 24660) >> 15) << 1);

			/* Q12 * Q0 = Q13 -> Q10 */
			qua_ener = ((tmp << 13) + 0x00008000L) >> 16;
		}
		else {
			p = &table_gain_lowrates[index];
			*gain_pit = *p++;
			g_code = *p++;
			qua_ener_MR122 = *p++;
			qua_ener = *p;
		}
	}

	/*
	* predict codebook gain
	* gc0 = Pow2(int(d)+frac(d))
	*     = 2^exp + 2^frac
	* gcode0 (Q14) = 2^14*2^frac = gc0 * 2^(14-exp)
	*/
	gc_pred(pred_state, mode, code, &exp, &frac, NULL, NULL);
	gcode0 = Pow2(14, frac);

	/*
	* read quantized gains, update table of past quantized energies
	* st->past_qua_en(Q10) = 20 * Log10(gFac) / constant
	*                      = Log2(gFac)
	*                      = qua_ener
	* constant = 20*Log10(2)
	*/
	if (exp < 11) {
		*gain_cod = (g_code * gcode0) >> (25 - exp);
	}
	else {
		tmp = ((g_code * gcode0) << (exp - 9));

		if ((tmp >> (exp - 9)) != (g_code * gcode0)) {
			*gain_cod = 0x7FFF;
		}
		else {
			*gain_cod = tmp >> 16;
		}
	}

	/* update table of past quantized energies */
	gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
	return;
}


/*
* gc_pred_average_limited
*
*
* Parameters:
*    st->past_qua_en         I: MA predictor
*    st->past_qua_en_MR122   I: MA predictor MR122
*    ener_avg_MR122          O: everaged quantized energy (log2(quaErr))
*    ener_avg                O: averaged quantized energy (20*log10(quaErr))
*
* Function:
*    Compute average limited quantized energy
* Returns:
*    void
*/
__device__ static void gc_pred_average_limited(dec_gc_predState *st, Word32 *ener_avg_MR122,
	Word32 *ener_avg)
{
	Word32 av_pred_en, i;


	/* do average in MR122 mode (log2() domain) */
	av_pred_en = 0;

	for (i = 0; i < NPRED; i++) {
		av_pred_en = (av_pred_en + st->past_qua_en_MR122[i]);
	}

	/* av_pred_en = 0.25*av_pred_en */
	av_pred_en = (av_pred_en * 8192) >> 15;

	/* if (av_pred_en < -14/(20Log10(2))) av_pred_en = .. */
	if (av_pred_en < MIN_ENERGY_MR122) {
		av_pred_en = MIN_ENERGY_MR122;
	}
	*ener_avg_MR122 = (Word16)av_pred_en;

	/* do average for other modes (20*log10() domain) */
	av_pred_en = 0;

	for (i = 0; i < NPRED; i++) {
		av_pred_en = (av_pred_en + st->past_qua_en[i]);
		if (av_pred_en < -32768)
			av_pred_en = -32768;
		else if (av_pred_en > 32767)
			av_pred_en = 32767;
	}

	/* av_pred_en = 0.25*av_pred_en */
	av_pred_en = (av_pred_en * 8192) >> 15;

	*ener_avg = av_pred_en;
}


/*
* ec_gain_code
*
*
* Parameters:
*    st->gbuf             I: last five gains
*    st->past_gain_code   I: past gain
*    pred_state           B: MA predictor state
*    state                I: state of the state machine
*    gain_code            O: decoded innovation gain
*
* Function:
*    Conceal the codebook gain
*
* Returns:
*    void
*/
__device__ static void ec_gain_code(ec_gain_codeState *st, dec_gc_predState *pred_state,
	Word16 state, Word32 *gain_code)
{
	Word32 tmp, qua_ener_MR122, qua_ener;


	/* calculate median of last five gain values */
	tmp = gmed_n(st->gbuf, 5);

	/* new gain = minimum(median, past_gain) * cdown[state] */
	if (tmp > st->past_gain_code) {
		tmp = st->past_gain_code;
	}
	tmp = (tmp * cdown[state]) >> 15;
	*gain_code = tmp;

	/*
	* update table of past quantized energies with average of
	* current values
	*/
	gc_pred_average_limited(pred_state, &qua_ener_MR122, &qua_ener);
	gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
}


/*
* ec_gain_code_update
*
*
* Parameters:
*    st->gbuf             B: last five gains
*    st->past_gain_code   O: past gain
*    st->prev_gc          B  previous gain
*    bfi                  I: bad indicator
*    prev_bf              I: previous frame bad indicator
*    gain_code            O: decoded innovation gain
*
* Function:
*    Update the codebook gain concealment state
*
* Returns:
*    void
*/
__device__ static void ec_gain_code_update(ec_gain_codeState *st, Word16 bfi,
	Word16 prev_bf, Word32 *gain_code)
{
	/* limit gain_code by previous good gain if previous frame was bad */
	if (bfi == 0) {
		if (prev_bf != 0) {
			if (*gain_code > st->prev_gc) {
				*gain_code = st->prev_gc;
			}
		}
		st->prev_gc = *gain_code;
	}

	/* update EC states: previous gain, gain buffer */
	st->past_gain_code = *gain_code;
	st->gbuf[0] = st->gbuf[1];
	st->gbuf[1] = st->gbuf[2];
	st->gbuf[2] = st->gbuf[3];
	st->gbuf[3] = st->gbuf[4];
	st->gbuf[4] = *gain_code;
	return;
}


/*
* d_gain_code
*
*
* Parameters:
*    pred_state        B: MA predictor state
*    mode              I: AMR mode (MR795 or MR122)
*    index             I: received quantization index
*    code              I: innovation codevector
*    gain_code         O: decoded innovation gain
*
* Function:
*    Decode the fixed codebook gain using the received index
*
* Returns:
*    void
*/
__device__ static void d_gain_code(dec_gc_predState *pred_state, enum Mode mode, Word32 index,
	Word32 code[], Word32 *gain_code)
{
	Word32 g_code0, exp, frac, qua_ener_MR122, qua_ener;
	Word32 exp_inn_en, frac_inn_en, tmp, tmp2, i;
	const Word32 *p;


	/*
	* Decode codebook gain
	*/
	gc_pred(pred_state, mode, code, &exp, &frac, &exp_inn_en, &frac_inn_en);
	p = &qua_gain_code[((index + index) + index)];

	/* Different scalings between MR122 and the other modes */
	if (mode == MR122) {
		/* predicted gain */
		g_code0 = Pow2(exp, frac);

		if (g_code0 <= 2047)
			g_code0 = g_code0 << 4;
		else
			g_code0 = 32767;
		*gain_code = ((g_code0 * *p++) >> 15) << 1;
		if (*gain_code & 0xFFFF8000)
			*gain_code = 32767;

	}
	else {
		g_code0 = Pow2(14, frac);
		tmp = (*p++ * g_code0) << 1;
		exp = 9 - exp;

		if (exp > 0) {
			tmp = tmp >> exp;
		}
		else {
			for (i = exp; i < 0; i++) {
				tmp2 = tmp << 1;
				if ((tmp ^ tmp2) & 0x80000000) {
					tmp = (tmp & 0x80000000) ? 0x80000000 : 0x7FFFFFFF;
					break;
				}
				else {
					tmp = tmp2;
				}
			}
		}
		*gain_code = tmp >> 16;
		if (*gain_code & 0xFFFF8000)
			*gain_code = 32767;
	}

	/*
	* update table of past quantized energies
	*/
	qua_ener_MR122 = *p++;
	qua_ener = *p++;
	gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
	return;
}


/*
* Int_lsf
*
*
* Parameters:
*    lsf_old           I: LSF vector at the 4th subframe of past frame
*    lsf_new           I: LSF vector at the 4th subframe of present frame
*    i_subfr           I: current subframe
*    lsf_out           O: interpolated LSF parameters for current subframe
*
* Function:
*    Interpolates the LSFs for selected subframe
*
*    The LSFs are interpolated at the 1st, 2nd and 3rd
*    ubframe and only forwarded at the 4th subframe.
*
*    sf1:  3/4 F0 + 1/4 F1
*    sf2:  1/2 F0 + 1/2 F1
*    sf3:  1/4 F0 + 3/4 F1
*    sf4:  F1
*
* Returns:
*    void
*/
__device__ static void Int_lsf(Word32 lsf_old[], Word32 lsf_new[], int i_subfr, Word32
	lsf_out[])
{
	Word32 i;


	switch (i_subfr) {
	case 0:
		for (i = 0; i < 10; i++) {
			lsf_out[i] = lsf_old[i] - (lsf_old[i] >> 2) + (lsf_new[i] >> 2);
		}
		break;

	case 40:
		for (i = 0; i < 10; i++) {
			lsf_out[i] = (lsf_old[i] >> 1) + (lsf_new[i] >> 1);
		}
		break;

	case 80:
		for (i = 0; i < 10; i++) {
			lsf_out[i] = (lsf_old[i] >> 2) - (lsf_new[i] >> 2) +
				lsf_new[i];
		}
		break;

	case 120:
		memcpy(lsf_out, lsf_new, M << 2);
		break;
	}
}


/*
* Cb_gain_average
*
*
* Parameters:
*    st->cbGainHistory B: codebook gain history
*    st->hangCount     B: hangover counter
*    mode              I: AMR mode
*    gain_code         I: codebook gain
*    lsp               I: The LSP for the current frame
*    lspAver           I: The average of LSP for 8 frames
*    bfi               I: bad frame indication
*    prev_bf           I: previous bad frame indication
*    pdfi              I: potential degraded bad frame indication
*    prev_pdf          I: previous potential degraded bad frame indication
*    inBackgroundNoise I: background noise decision
*    voicedHangover    I: number of frames after last voiced frame
*
* Function:
*    The mixed codebook gain, used to make codebook gain more smooth in background
*
*
* Returns:
*    void
*/
__device__ static Word32 Cb_gain_average(Cb_gain_averageState *st, enum Mode mode, Word32
	gain_code, Word32 lsp[], Word32 lspAver[], Word16 bfi, Word16 prev_bf,
	Word16 pdfi, Word16 prev_pdf, Word32 inBackgroundNoise, Word32
	voicedHangover)
{
	Word32 tmp[M];
	Word32 i, cbGainMix, tmp_diff, bgMix, cbGainMean, sum, diff, tmp1, tmp2;
	int shift1, shift2, shift;


	/* set correct cbGainMix for MR74, MR795, MR122 */
	cbGainMix = gain_code;

	/*
	* Store list of CB gain needed in the CB gain averaging                                           *
	*/
	st->cbGainHistory[0] = st->cbGainHistory[1];
	st->cbGainHistory[1] = st->cbGainHistory[2];
	st->cbGainHistory[2] = st->cbGainHistory[3];
	st->cbGainHistory[3] = st->cbGainHistory[4];
	st->cbGainHistory[4] = st->cbGainHistory[5];
	st->cbGainHistory[5] = st->cbGainHistory[6];
	st->cbGainHistory[6] = gain_code;

	/* compute lsp difference */
	for (i = 0; i < M; i++) {
		tmp1 = labs(lspAver[i] - lsp[i]);
		shift1 = 0;
		if (tmp1 != 0) {
			while (!(tmp1 & 0x2000))
			{
				shift1++;
				tmp1 = tmp1 << 1;
			}
		}
		tmp2 = lspAver[i];
		shift2 = 0;
		if (tmp2 != 0) {
			while (!(tmp2 & 0x4000))
			{
				shift2++;
				tmp2 = tmp2 << 1;
			}
		}
		tmp[i] = (tmp1 << 15) / tmp2;
		shift = 2 + shift1 - shift2;

		if (shift >= 0) {
			tmp[i] = tmp[i] >> shift;
		}
		else {
			tmp[i] = tmp[i] << -(shift);
		}
	}
	diff = *tmp + tmp[1] + tmp[2] + tmp[3] + tmp[4] + tmp[5] + tmp[6] + tmp[7] +
		tmp[8] + tmp[9];

	/* saturate */
	if (diff > 32767) {
		diff = 32767;
	}

	/* Compute hangover */
	st->hangVar += 1;

	if (diff <= 5325) {
		st->hangVar = 0;
	}

	if (st->hangVar > 10) {
		/* Speech period, reset hangover variable */
		st->hangCount = 0;
	}

	/* Compute mix constant (bgMix) */
	bgMix = 8192;

	/* MR475, MR515, MR59, MR67, MR102 */
	if ((mode <= MR67) | (mode == MR102)) {
		/* disable mix if too short time since */
		if ((st->hangCount >= 40) & (diff <= 5325)) /* 0.65 in Q13 */ {
			/* if errors and presumed noise make smoothing probability stronger */
			if (((((pdfi != 0) & (prev_pdf != 0)) | (bfi != 0) | (
				prev_bf != 0)) & ((voicedHangover > 1)) & (
					inBackgroundNoise != 0) & (mode < MR67))) {
				/* bgMix = min(0.25, max(0.0, diff-0.55)) / 0.25; */
				tmp_diff = diff - 4506;   /* 0.55 in Q13 */

										  /* max(0.0, diff-0.55) */
				tmp1 = 0;

				if (tmp_diff > 0) {
					tmp1 = tmp_diff;
				}

				/* min(0.25, tmp1) */
				if (2048 >= tmp1) {
					bgMix = tmp1 << 2;
				}
			}
			else {
				/* bgMix = min(0.25, max(0.0, diff-0.40)) / 0.25; */
				tmp_diff = diff - 3277;   /* 0.4 in Q13 */

										  /* max(0.0, diff-0.40) */
				tmp1 = 0;

				if (tmp_diff > 0) {
					tmp1 = tmp_diff;
				}

				/* min(0.25, tmp1) */
				if (2048 >= tmp1) {
					bgMix = tmp1 << 2;
				}
			}
		}

		/*
		* Smoothen the cb gain trajectory
		* smoothing depends on mix constant bgMix
		*/
		sum = st->cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
			st->cbGainHistory[5] + st->cbGainHistory[6];

		if (sum > 163822) {
			cbGainMean = 32767;
		}
		else {
			cbGainMean = (3277 * sum + 0x00002000L) >> 14;   /* Q1 */
		}

		/* more smoothing in error and bg noise (NB no DFI used  here) */
		if (((bfi != 0) | (prev_bf != 0)) & (inBackgroundNoise != 0) & (
			mode < MR67)) {
			sum = 9362 * (st->cbGainHistory[0] + st->cbGainHistory[1] + st->
				cbGainHistory[2] + st->cbGainHistory[3] + st->cbGainHistory[4] +
				st->cbGainHistory[5] + st->cbGainHistory[6]);
			cbGainMean = (sum + 0x00008000L) >> 16;   /* Q1 */
		}

		/* cbGainMix = bgMix*cbGainMix + (1-bgMix)*cbGainMean; */
		sum = bgMix * cbGainMix;   /* sum in Q14 */
		sum += cbGainMean << 13;
		sum -= bgMix * cbGainMean;
		cbGainMix = (sum + 0x00001000L) >> 13;

		/* Q1 */
	}
	st->hangCount += 1;
	if (st->hangCount & 0x80000000)
		st->hangCount = 40;
	return cbGainMix;
}


/*
* ph_disp
*
*
* Parameters:
*    state->gainMem    B: LTP gain memory
*    state->prevCbGain B: Codebook gain memory
*    mode              I: AMR mode
*    x                 B: LTP excitation signal -> total excitation signal
*    cbGain            I: Codebook gain
*    ltpGain           I: LTP gain
*    inno              B: Innovation vector
*    pitch_fac         I: pitch factor used to scale the LTP excitation
*    tmp_shift         I: shift factor applied to sum of scaled LTP ex & innov.
*                         before rounding
*
* Function:
*    Adaptive phase dispersion; forming of total excitation
*
*
* Returns:
*    void
*/
__device__ static void ph_disp(ph_dispState *state, enum Mode mode, Word32 x[],
	Word32 cbGain, Word32 ltpGain, Word32 inno[],
	Word32 pitch_fac, Word32 tmp_shift)
{
	Word32 inno_sav[L_SUBFR], ps_poss[L_SUBFR];
	Word32 i, i1, impNr, temp1, temp2, j, nze, nPulse, ppos;
	const Word32 *ph_imp;   /* Pointer to phase dispersion filter */


							/* Update LTP gain memory */
	state->gainMem[4] = state->gainMem[3];
	state->gainMem[3] = state->gainMem[2];
	state->gainMem[2] = state->gainMem[1];
	state->gainMem[1] = state->gainMem[0];
	state->gainMem[0] = ltpGain;

	/* basic adaption of phase dispersion */
	/* no dispersion */
	impNr = 2;

	/* if (ltpGain < 0.9) */
	if (ltpGain < PHDTHR2LTP) {
		/* maximum dispersion */
		impNr = 0;

		/* if (ltpGain > 0.6 */
		if (ltpGain > PHDTHR1LTP) {
			/* medium dispersion */
			impNr = 1;
		}
	}

	/* onset indicator */
	/* onset = (cbGain  > onFact * cbGainMem[0]) */
	temp1 = ((state->prevCbGain * ONFACTPLUS1) + 0x1000) >> 13;

	if (cbGain > temp1) {
		state->onset = ONLENGTH;
	}
	else {
		if (state->onset > 0) {
			state->onset--;
		}
	}

	/*
	* if not onset, check ltpGain buffer and use max phase dispersion if
	* half or more of the ltpGain-parameters say so
	*/
	if (state->onset == 0) {
		/* Check LTP gain memory and set filter accordingly */
		i1 = 0;

		for (i = 0; i < PHDGAINMEMSIZE; i++) {
			if (state->gainMem[i] < PHDTHR1LTP) {
				i1++;
			}
		}

		if (i1 > 2) {
			impNr = 0;
		}
	}

	/* Restrict decrease in phase dispersion to one step if not onset */
	if ((impNr > (state->prevState + 1)) & (state->onset == 0)) {
		impNr--;
	}

	/* if onset, use one step less phase dispersion */
	if ((impNr<2)&(state->onset>0)) {
		impNr++;
	}

	/* disable for very low levels */
	if (cbGain < 10) {
		impNr = 2;
	}

	if (state->lockFull == 1) {
		impNr = 0;
	}

	/* update static memory */
	state->prevState = impNr;
	state->prevCbGain = cbGain;

	/*
	* do phase dispersion for all modes but 12.2 and 7.4;
	* don't modify the innovation if impNr >=2 (= no phase disp)
	*/
	if ((mode != MR122) & (mode != MR102) & (mode != MR74) & (impNr < 2)
		) {
		/*
		* track pulse positions, save innovation,
		* and initialize new innovation
		*/
		nze = 0;

		for (i = 0; i < L_SUBFR; i++) {
			if (inno[i] != 0) {
				ps_poss[nze] = i;
				nze++;
			}
		}
		memcpy(inno_sav, inno, L_SUBFR << 2);
		memset(inno, 0, L_SUBFR << 2);

		/* Choose filter corresponding to codec mode and dispersion criterium */
		ph_imp = ph_imp_mid;

		if (impNr == 0) {
			ph_imp = ph_imp_low;
		}

		if (mode == MR795) {
			ph_imp = ph_imp_mid_MR795;

			if (impNr == 0) {
				ph_imp = ph_imp_low_MR795;
			}
		}

		/* Do phase dispersion of innovation */
		for (nPulse = 0; nPulse < nze; nPulse++) {
			ppos = ps_poss[nPulse];

			/* circular convolution with impulse response */
			j = 0;

			for (i = ppos; i < L_SUBFR; i++) {
				/* inno[i1] += inno_sav[ppos] * ph_imp[i1-ppos] */
				temp1 = (inno_sav[ppos] * ph_imp[j++]) >> 15;
				inno[i] = inno[i] + temp1;
			}

			for (i = 0; i < ppos; i++) {
				/* inno[i] += inno_sav[ppos] * ph_imp[L_SUBFR-ppos+i] */
				temp1 = (inno_sav[ppos] * ph_imp[j++]) >> 15;
				inno[i] = inno[i] + temp1;
			}
		}
	}

	/*
	* compute total excitation for synthesis part of decoder
	* (using modified innovation if phase dispersion is active)
	*/
	for (i = 0; i < L_SUBFR; i++) {
		/* x[i] = gain_pit*x[i] + cbGain*code[i]; */
		temp1 = x[i] * pitch_fac + inno[i] * cbGain;
		temp2 = temp1 << tmp_shift;
		x[i] = (temp2 + 0x4000) >> 15;
		if (labs(x[i]) > 32767)
		{
			if ((temp1 ^ temp2) & 0x80000000) {
				x[i] = (temp1 & 0x80000000) ? -32768 : 32767;
			}
			else {
				x[i] = (temp2 & 0x80000000) ? -32768 : 32767;
			}
		}
	}
	return;
}


/*
* sqrt_l_exp
*
*
* Parameters:
*    x                 I: input value
*    exp               O: right shift to be applied to result
*
* Function:
*    Sqrt with exponent value.
*
*    y = sqrt(x)
*    x = f * 2^-e,   0.5 <= f < 1   (normalization)
*    y = sqrt(f) * 2^(-e/2)
*
*    a) e = 2k   --> y = sqrt(f)   * 2^-k
*       (k = e div 2, 0.707 <= sqrt(f) < 1)
*    b) e = 2k+1 --> y = sqrt(f/2) * 2^-k
*       (k = e div 2, 0.5 <= sqrt(f/2) < 0.707)
*
*
* Returns:
*    y                 output value
*/
__device__ static Word32 sqrt_l_exp(Word32 x, Word32 *exp)
{
	Word32 y, a, i, tmp;
	int e;


	if (x <= (Word32)0) {
		*exp = 0;
		return(Word32)0;
	}
	e = 0;
	if (x != 0) {
		tmp = x;
		while (!(tmp & 0x40000000))
		{
			e++;
			tmp = tmp << 1;
		}
	}
	e = e & 0xFFFE;
	x = (x << e);
	*exp = (Word16)e;
	x = (x >> 9);
	i = (Word16)(x >> 16);
	x = (x >> 1);
	a = x & (Word16)0x7fff;
	i = (i - 16);
	y = (sqrt_table[i] << 16);
	tmp = (sqrt_table[i] - sqrt_table[i + 1]);
	y -= (tmp * a) << 1;
	return(y);
}


/*
* Ex_ctrl
*
*
* Parameters:
*    excitation        B: Current subframe excitation
*    excEnergy         I: Exc. Energy, sqrt(totEx*totEx)
*    exEnergyHist      I: History of subframe energies
*    voicedHangover    I: number of frames after last voiced frame
*    prevBFI           I: Set i previous bad frame indicators
*    carefulFlag       I: Restrict dymamic in scaling
*
* Function:
*    Charaterice synthesis speech and detect background noise
*
* Returns:
*    background noise decision; 0 = no bgn, 1 = bgn
*/
__device__ static Word16 Ex_ctrl(Word32 excitation[], Word32 excEnergy, Word32
	exEnergyHist[], Word32 voicedHangover, Word16 prevBFI, Word16 carefulFlag
)
{
	Word32 i, testEnergy, scaleFactor, avgEnergy, prevEnergy, T0;
	int exp;


	/* get target level */
	avgEnergy = gmed_n(exEnergyHist, 9);
	prevEnergy = (exEnergyHist[7] + exEnergyHist[8]) >> 1;

	if (exEnergyHist[8] < prevEnergy) {
		prevEnergy = exEnergyHist[8];
	}

	/* upscaling to avoid too rapid energy rises  for some cases */
	if ((excEnergy<avgEnergy)&(excEnergy>5)) {
		/* testEnergy = 4*prevEnergy; */
		testEnergy = prevEnergy << 2;

		if ((voicedHangover < 7) || prevBFI != 0) {
			/* testEnergy = 3*prevEnergy */
			testEnergy = testEnergy - prevEnergy;
		}

		if (avgEnergy > testEnergy) {
			avgEnergy = testEnergy;
		}

		/* scaleFactor=avgEnergy/excEnergy in Q0 */
		exp = 0;
		if (excEnergy != 0) {
			while (!(excEnergy & 0x4000))
			{
				exp++;
				excEnergy = excEnergy << 1;
			}
		}
		excEnergy = 536838144 / excEnergy;
		T0 = (avgEnergy * excEnergy) << 1;
		T0 = (T0 >> (20 - exp));

		if (T0 > 32767) {
			/* saturate  */
			T0 = 32767;
		}
		scaleFactor = T0;

		/* test if scaleFactor > 3.0 */
		if ((carefulFlag != 0) & (scaleFactor > 3072)) {
			scaleFactor = 3072;
		}

		/* scale the excitation by scaleFactor */
		for (i = 0; i < L_SUBFR; i++) {
			T0 = (scaleFactor * excitation[i]) << 1;
			T0 = (T0 >> 11);
			excitation[i] = T0;
		}
	}
	return 0;
}


/*
* Inv_sqrt
*
*
* Parameters:
*    x                 I: input value
*
* Function:
*    1/sqrt(x)
*
* Returns:
*    y                 1/sqrt(x)
*/
__device__ static Word32 Inv_sqrt(Word32 x)
{
	int i, a, tmp, exp;
	Word32 y;


	if (x <= (Word32)0)
		return((Word32)0x3fffffffL);
	exp = 0;
	while (!(x & 0x40000000))
	{
		exp++;
		x = x << 1;
	}

	/* x is normalized */
	exp = (30 - exp);

	/* If exponent even -> shift right */
	if ((exp & 1) == 0) {
		x = (x >> 1);
	}
	exp = (exp >> 1);
	exp = (exp + 1);
	x = (x >> 9);

	/* Extract b25-b31 */
	i = (Word16)(x >> 16);

	/* Extract b10-b24 */
	x = (x >> 1);
	a = x & (Word16)0x7fff;
	i = (i - 16);

	/* table[i] << 16 */
	y = inv_sqrt_table[i] << 16;

	/* table[i] - table[i+1]) */
	tmp = (inv_sqrt_table[i] - inv_sqrt_table[i + 1]);

	/* y -= tmp*a*2 */
	y -= (tmp * a) << 1;

	/* denormalization */
	y = (y >> exp);
	return(y);
}


/*
* energy_old
*
*
* Parameters:
*    in                I: input value
*
* Function:
*    Energy of signal
*
* Returns:
*    Energy
*/
__device__ static Word32 energy_old(Word32 in[])
{
	Word32 temp, i, sum = 0;


	for (i = 0; i < L_SUBFR; i += 8) {
		temp = in[i] >> 2;
		sum += temp * temp;
		temp = in[i + 1] >> 2;
		sum += temp * temp;
		temp = in[i + 2] >> 2;
		sum += temp * temp;
		temp = in[i + 3] >> 2;
		sum += temp * temp;
		temp = in[i + 4] >> 2;
		sum += temp * temp;
		temp = in[i + 5] >> 2;
		sum += temp * temp;
		temp = in[i + 6] >> 2;
		sum += temp * temp;
		temp = in[i + 7] >> 2;
		sum += temp * temp;
	}

	if (sum & 0xC0000000) {
		return 0x7FFFFFFF;
	}
	return(sum << 1);
}


/*
* energy_new
*
*
* Parameters:
*    in                I: input value
*
* Function:
*    Energy of signal
*
* Returns:
*    Energy
*/
__device__ static Word32 energy_new(Word32 in[])
{
	Word32 i, s = 0, overflow = 0;

	s += in[0] * in[0];
	for (i = 1; i < L_SUBFR; i += 3) {
		s += in[i] * in[i];
		s += in[i + 1] * in[i + 1];
		s += in[i + 2] * in[i + 2];


		if (s & 0xC0000000) {
			overflow = 1;
			break;
		}
	}

	/* check for overflow */
	if (overflow) {
		s = energy_old(in);
	}
	else {
		s = (s >> 3);
	}
	return s;
}


/*
* agc2
*
*
* Parameters:
*    sig_in            I: Post_Filter input signal
*    sig_out           B: Post_Filter output signal
*
* Function:
*    Scales the excitation on a subframe basis
*
* Returns:
*    Energy
*/
__device__ static void agc2(Word32 *sig_in, Word32 *sig_out)
{
	Word32 s;
	int i, exp;
	Word16 gain_in, gain_out, g0;


	/* calculate gain_out with exponent */
	s = energy_new(sig_out);

	if (s == 0) {
		return;
	}
	exp = 0;
	while (!(s & 0x20000000))
	{
		exp++;
		s = s << 1;
	}

	gain_out = (Word16)((s + 0x00008000L) >> 16);

	/* calculate gain_in with exponent */
	s = energy_new(sig_in);

	if (s == 0) {
		g0 = 0;
	}
	else {
		i = 0;
		while (!(s & 0x40000000))
		{
			i++;
			s = s << 1;
		}

		if (s < 0x7fff7fff)
			gain_in = (Word16)((s + 0x00008000L) >> 16);
		else
			gain_in = 32767;
		exp = (exp - i);

		/*
		* g0 = sqrt(gain_in/gain_out);
		*/
		/* s = gain_out / gain_in */
		s = (gain_out << 15) / gain_in;
		s = (s << 7);

		if (exp > 0)
			s = (s >> exp);
		else
			s = (s << (-exp));
		s = Inv_sqrt(s);
		g0 = (Word16)(((s << 9) + 0x00008000L) >> 16);
	}

	/* sig_out(n) = gain(n) * sig_out(n) */
	for (i = 0; i < L_SUBFR; i++) {
		sig_out[i] = (sig_out[i] * g0) >> 12;
	}
	return;
}


/*
* Bgn_scd
*
*
* Parameters:
*    st->frameEnergyHist  B: Frame Energy memory
*    st->bgHangover       B: Background hangover counter
*    ltpGainHist          I: LTP gain history
*    speech               I: synthesis speech frame
*    voicedHangover       O: number of frames after last voiced frame
*
* Function:
*    Charaterice synthesis speech and detect background noise
*
* Returns:
*    inbgNoise         background noise decision; 0 = no bgn, 1 = bgn
*/
__device__ static Word16 Bgn_scd(Bgn_scdState *st, Word32 ltpGainHist[], Word32 speech[],
	Word32 *voicedHangover)
{
	Word32 temp, ltpLimit, frame_energyMin, currEnergy, noiseFloor, maxEnergy,
		maxEnergyLastPart, s, i;
	Word16 prevVoiced, inbgNoise;


	/*
	* Update the inBackgroundNoise flag (valid for use in next frame if BFI)
	* it now works as a energy detector floating on top
	* not as good as a VAD.
	*/
	s = 0;

	for (i = 0; i < L_FRAME; i++) {
		s += speech[i] * speech[i];
	}

	if ((s < 0xFFFFFFF) & (s >= 0))
		currEnergy = s >> 13;
	else
		currEnergy = 32767;
	frame_energyMin = 32767;

	for (i = 0; i < L_ENERGYHIST; i++) {
		if (st->frameEnergyHist[i] < frame_energyMin)
			frame_energyMin = st->frameEnergyHist[i];
	}

	/* Frame Energy Margin of 16 */
	noiseFloor = frame_energyMin << 4;
	maxEnergy = st->frameEnergyHist[0];

	for (i = 1; i < L_ENERGYHIST - 4; i++) {
		if (maxEnergy < st->frameEnergyHist[i]) {
			maxEnergy = st->frameEnergyHist[i];
		}
	}
	maxEnergyLastPart = st->frameEnergyHist[2 * L_ENERGYHIST / 3];

	for (i = 2 * L_ENERGYHIST / 3 + 1; i < L_ENERGYHIST; i++) {
		if (maxEnergyLastPart < st->frameEnergyHist[i]) {
			maxEnergyLastPart = st->frameEnergyHist[i];
		}
	}

	/* false */
	inbgNoise = 0;

	/*
	* Do not consider silence as noise
	* Do not consider continuous high volume as noise
	* Or if the current noise level is very low
	* Mark as noise if under current noise limit
	* OR if the maximum energy is below the upper limit
	*/
	if ((maxEnergy> LOWERNOISELIMIT)&(currEnergy<FRAMEENERGYLIMIT)&(
		currEnergy>LOWERNOISELIMIT) & ((currEnergy < noiseFloor) || (
			maxEnergyLastPart < UPPERNOISELIMIT))) {
		if ((st->bgHangover + 1) > 30) {
			st->bgHangover = 30;
		}
		else {
			st->bgHangover += 1;
		}
	}
	else {
		st->bgHangover = 0;
	}

	/* make final decision about frame state, act somewhat cautiosly */
	if (st->bgHangover > 1)
		inbgNoise = 1;   /* true  */

	for (i = 0; i < L_ENERGYHIST - 1; i++) {
		st->frameEnergyHist[i] = st->frameEnergyHist[i + 1];
	}
	st->frameEnergyHist[L_ENERGYHIST - 1] = currEnergy;

	/*
	* prepare for voicing decision;
	* tighten the threshold after some time in noise
	*/
	ltpLimit = 13926;   /* 0.85  Q14 */

	if (st->bgHangover > 8) {
		ltpLimit = 15565;   /* 0.95  Q14 */
	}

	if (st->bgHangover > 15) {
		ltpLimit = 16383;   /* 1.00  Q14 */
	}

	/* weak sort of voicing indication. */
	prevVoiced = 0;   /* false */

	if (gmed_n(&ltpGainHist[4], 5) > ltpLimit) {
		prevVoiced = 1;   /* true  */
	}

	if (st->bgHangover > 20) {
		if (gmed_n(ltpGainHist, 9) > ltpLimit) {
			prevVoiced = 1;   /* true  */
		}
		else {
			prevVoiced = 0;   /* false  */
		}
	}

	if (prevVoiced) {
		*voicedHangover = 0;
	}
	else {
		temp = *voicedHangover + 1;

		if (temp > 10) {
			*voicedHangover = 10;
		}
		else {
			*voicedHangover = temp;
		}
	}
	return inbgNoise;
}


/*
* dtx_dec_activity_update
*
*
* Parameters:
*    st->lsf_hist_ptr  B: LSF history pointer
*    st->lsf_hist      B: LSF history
*    lsf               I: lsf
*    frame             I: noise frame
*
* Function:
*    Update lsp history and compute log energy.
*
* Returns:
*    void
*/
__device__ static void dtx_dec_activity_update(dtx_decState *st, Word32 lsf[], Word32
	frame[])
{
	Word32 frame_en;
	Word32 log_en_e, log_en_m, log_en, i;


	/* update lsp history */
	st->lsf_hist_ptr += M;

	if (st->lsf_hist_ptr == 80) {
		st->lsf_hist_ptr = 0;
	}
	memcpy(&st->lsf_hist[st->lsf_hist_ptr], lsf, M << 2);

	/* compute log energy based on frame energy */
	frame_en = 0;   /* Q0 */

	for (i = 0; (i < L_FRAME); i++) {
		frame_en += frame[i] * frame[i];
		if (frame_en & 0x80000000)
			break;
	}

	log_en = (frame_en & 0xC0000000) ? 0x7FFFFFFE : (Word32)frame_en << 1;

	Log2(log_en, &log_en_e, &log_en_m);

	/* convert exponent and mantissa to Word16 Q10 */
	log_en = log_en_e << 10;   /* Q10 */
	log_en = log_en + (log_en_m >> 5);

	/* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
	log_en = log_en - 8521;

	/*
	* insert into log energy buffer, no division by two as
	* log_en in decoder is Q11
	*/
	st->log_en_hist_ptr += 1;

	if (st->log_en_hist_ptr == DTX_HIST_SIZE) {
		st->log_en_hist_ptr = 0;
	}
	st->log_en_hist[st->log_en_hist_ptr] = log_en;   /* Q11 */
}


/*
* Decoder_amr
*
*
* Parameters:
*    st                B: State variables
*    mode              I: AMR mode
*    parm              I: vector of synthesis parameters
*    frame_type        I: received frame type
*    synth             O: synthesis speech
*    A_t               O: decoded LP filter in 4 subframes
*
* Function:
*    Speech decoder routine
*
* Returns:
*    void
*/
__device__ static void Decoder_amr(Decoder_amrState *st, enum Mode mode, Word16 parm[],
	enum RXFrameType frame_type, Word32 synth[], Word32 A_t[])
{
	/* LSPs */
	Word32 lsp_new[M];
	Word32 lsp_mid[M];


	/* LSFs */
	Word32 prev_lsf[M];
	Word32 lsf_i[M];


	/* Algebraic codevector */
	Word32 code[L_SUBFR];


	/* excitation */
	Word32 excp[L_SUBFR];
	Word32 exc_enhanced[L_SUBFR];


	/* Scalars */
	Word32 i, i_subfr, overflow, T0_frac, index, temp, temp2, subfrNr, excEnergy;
	Word32 gain_code, gain_code_mix, pit_sharp, pit_flag, pitch_fac, t0_min, t0_max;
	Word32 gain_pit = 0, evenSubfr = 0, T0 = 0, index_mr475 = 0;
	Word32 *Az;   /* Pointer on A_t */
	Word16 flag4, carefulFlag;
	Word16 delta_frc_low, delta_frc_range, tmp_shift;
	Word16 bfi = 0, pdfi = 0;
	/* bad frame indication flag, potential degraded bad frame flag */


	enum DTXStateType newDTXState;   /* SPEECH , DTX, DTX_MUTE */

									 /* find the new  DTX state  SPEECH OR DTX */
	newDTXState = rx_dtx_handler(&st->dtxDecoderState, frame_type);

	/* DTX actions */
	if (newDTXState != SPEECH) {
		Decoder_amr_reset(st, MRDTX);
		dtx_dec(&st->dtxDecoderState, st->mem_syn, &st->lsfState, &st->pred_state,
			&st->Cb_gain_averState, newDTXState, mode, parm, synth, A_t);

		/* update average lsp */
		Lsf_lsp(st->lsfState.past_lsf_q, st->lsp_old);
		lsp_avg(&st->lsp_avg_st, st->lsfState.past_lsf_q);
		goto theEnd;
	}

	/* SPEECH action state machine  */
	if (table_speech_bad[frame_type]) {
		bfi = 1;

		if (frame_type != RX_SPEECH_BAD) {
			Build_CN_param(&st->nodataSeed, mode, parm);
		}
	}
	else if (frame_type == RX_SPEECH_DEGRADED) {
		pdfi = 1;
	}

	if (bfi != 0) {
		st->state += 1;
	}
	else if (st->state == 6) {
		st->state = 5;
	}
	else {
		st->state = 0;
	}

	if (st->state > 6) {
		st->state = 6;
	}

	/*
	* If this frame is the first speech frame after CNI period,
	* set the BFH state machine to an appropriate state depending
	* on whether there was DTX muting before start of speech or not
	* If there was DTX muting, the first speech frame is muted.
	* If there was no DTX muting, the first speech frame is not
	* muted. The BFH state machine starts from state 5, however, to
	* keep the audible noise resulting from a SID frame which is
	* erroneously interpreted as a good speech frame as small as
	* possible (the decoder output in this case is quickly muted)
	*/
	if (st->dtxDecoderState.dtxGlobalState == DTX) {
		st->state = 5;
		st->prev_bf = 0;
	}
	else if (st->dtxDecoderState.dtxGlobalState == DTX_MUTE) {
		st->state = 5;
		st->prev_bf = 1;
	}

	/* save old LSFs for CB gain smoothing */
	memcpy(prev_lsf, st->lsfState.past_lsf_q, M << 2);

	/*
	* decode LSF parameters and generate interpolated lpc coefficients
	* for the 4 subframes
	*/
	if (mode != MR122) {
		D_plsf_3(&st->lsfState, mode, bfi, parm, lsp_new);

		/* Advance synthesis parameters pointer */
		parm += 3;
		Int_lpc_1to3(st->lsp_old, lsp_new, A_t);
	}
	else {
		D_plsf_5(&st->lsfState, bfi, parm, lsp_mid, lsp_new);

		/* Advance synthesis parameters pointer */
		parm += 5;
		Int_lpc_1and3(st->lsp_old, lsp_mid, lsp_new, A_t);
	}

	/* update the LSPs for the next frame */
	memcpy(st->lsp_old, lsp_new, M << 2);

	/*
	* Loop for every subframe in the analysis frame
	*
	* The subframe size is L_SUBFR and the loop is repeated
	* L_FRAME/L_SUBFR times                                                                 *
	*  - decode the pitch delay
	*  - decode algebraic code
	*  - decode pitch and codebook gains
	*  - find the excitation and compute synthesis speech
	*/
	/* pointer to interpolated LPC parameters */
	Az = A_t;
	evenSubfr = 0;
	subfrNr = -1;

	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR) {
		subfrNr += 1;
		evenSubfr = 1 - evenSubfr;

		/* flag for first and 3th subframe */
		pit_flag = i_subfr;

		if (i_subfr == L_FRAME_BY2) {
			if ((mode != MR475) & (mode != MR515)) {
				pit_flag = 0;
			}
		}

		/* pitch index */
		index = *parm++;

		/*
		* decode pitch lag and find adaptive codebook vector.
		*/
		if (mode != MR122) {
			/*
			* flag4 indicates encoding with 4 bit resolution;
			* this is needed for mode MR475, MR515, MR59 and MR67
			*/
			flag4 = 0;

			if ((mode == MR475) || (mode == MR515) || (mode == MR59) || (
				mode == MR67)) {
				flag4 = 1;
			}

			/*
			* get ranges for the t0_min and t0_max
			* only needed in delta decoding
			*/
			delta_frc_low = 5;
			delta_frc_range = 9;

			if (mode == MR795) {
				delta_frc_low = 10;
				delta_frc_range = 19;
			}
			t0_min = st->old_T0 - delta_frc_low;

			if (t0_min < PIT_MIN) {
				t0_min = PIT_MIN;
			}
			t0_max = t0_min + delta_frc_range;

			if (t0_max > PIT_MAX) {
				t0_max = PIT_MAX;
				t0_min = t0_max - delta_frc_range;
			}
			Dec_lag3(index, t0_min, t0_max, pit_flag, st->old_T0, &T0, &T0_frac,
				flag4);
			st->T0_lagBuff = T0;

			if (bfi != 0) {
				if (st->old_T0 < PIT_MAX) {
					/* Graceful pitch degradation */
					st->old_T0 += 1;
				}
				T0 = st->old_T0;
				T0_frac = 0;

				if ((st->inBackgroundNoise != 0) & (st->voicedHangover > 4) & (
					(mode == MR475) || (mode == MR515) || (mode == MR59)))
				{
					T0 = st->T0_lagBuff;
				}
			}
			Pred_lt_3or6_40(&st->old_exc[st->exc], T0, T0_frac, 1);
		}
		else {
			Dec_lag6(index, PIT_MIN_MR122, PIT_MAX, pit_flag, &T0, &T0_frac);

			if ((bfi != 0) || ((pit_flag != 0) & (index > 60))) {
				st->T0_lagBuff = T0;
				T0 = st->old_T0;
				T0_frac = 0;
			}
			Pred_lt_3or6_40(&st->old_exc[st->exc], T0, T0_frac, 0);
		}

		/*
		* (MR122 only: Decode pitch gain.)
		* Decode innovative codebook.
		* set pitch sharpening factor
		*/
		/* MR475, MR515 */
		if ((mode == MR475) || (mode == MR515)) {
			/* index of position */
			index = *parm++;

			/* signs */
			i = *parm++;
			decode_2i40_9bits(subfrNr, i, index, code);
			pit_sharp = st->sharp << 1;
		}

		/* MR59 */
		else if (mode == MR59) {
			/* index of position */
			index = *parm++;

			/* signs */
			i = *parm++;
			decode_2i40_11bits(i, index, code);
			pit_sharp = st->sharp << 1;
		}

		/* MR67 */
		else if (mode == MR67) {
			/* index of position */
			index = *parm++;

			/* signs */
			i = *parm++;
			decode_3i40_14bits(i, index, code);
			pit_sharp = st->sharp << 1;
		}

		/* MR74, MR795 */
		else if (mode <= MR795) {
			/* index of position */
			index = *parm++;

			/* signs */
			i = *parm++;
			decode_4i40_17bits(i, index, code);
			pit_sharp = st->sharp << 1;
		}

		/* MR102 */
		else if (mode == MR102) {
			decode_8i40_31bits(parm, code);
			parm += 7;
			pit_sharp = st->sharp << 1;
		}

		/* MR122 */
		else {
			index = *parm++;

			if (bfi != 0) {
				ec_gain_pitch(&st->ec_gain_p_st, st->state, &gain_pit);
			}
			else {
				gain_pit = d_gain_pitch(mode, index);
			}
			ec_gain_pitch_update(&st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit);
			decode_10i40_35bits(parm, code);
			parm += 10;

			/*
			* pit_sharp = gain_pit;
			* if (pit_sharp > 1.0) pit_sharp = 1.0;
			*/
			pit_sharp = gain_pit;

			if (pit_sharp > 16383)
				pit_sharp = 32767;
			else
				pit_sharp *= 2;
		}

		/*
		* Add the pitch contribution to code[].
		*/
		for (i = T0; i < L_SUBFR; i++) {
			temp = (code[i - T0] * pit_sharp) >> 15;
			code[i] = code[i] + temp;
		}

		/*
		* Decode codebook gain (MR122) or both pitch
		* gain and codebook gain (all others)
		* Update pitch sharpening "sharp" with quantized gain_pit
		*/
		if (mode == MR475) {
			/* read and decode pitch and code gain */
			if (evenSubfr != 0) {
				/* index of gain(s) */
				index_mr475 = *parm++;
			}

			if (bfi == 0) {
				Dec_gain(&st->pred_state, mode, index_mr475, code, evenSubfr, &
					gain_pit, &gain_code);
			}
			else {
				ec_gain_pitch(&st->ec_gain_p_st, st->state, &gain_pit);
				ec_gain_code(&st->ec_gain_c_st, &st->pred_state, st->state, &
					gain_code);
			}
			ec_gain_pitch_update(&st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit);
			ec_gain_code_update(&st->ec_gain_c_st, bfi, st->prev_bf, &gain_code);
			pit_sharp = gain_pit;

			if (pit_sharp > SHARPMAX) {
				pit_sharp = SHARPMAX;
			}
		}
		else if ((mode <= MR74) || (mode == MR102)) {
			/* read and decode pitch and code gain */
			/* index of gain(s) */
			index = *parm++;

			if (bfi == 0) {
				Dec_gain(&st->pred_state, mode, index, code, evenSubfr, &gain_pit, &
					gain_code);
			}
			else {
				ec_gain_pitch(&st->ec_gain_p_st, st->state, &gain_pit);
				ec_gain_code(&st->ec_gain_c_st, &st->pred_state, st->state, &
					gain_code);
			}
			ec_gain_pitch_update(&st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit);
			ec_gain_code_update(&st->ec_gain_c_st, bfi, st->prev_bf, &gain_code);
			pit_sharp = gain_pit;

			if (pit_sharp > SHARPMAX) {
				pit_sharp = SHARPMAX;
			}

			if (mode == MR102) {
				if (st->old_T0 > (L_SUBFR + 5)) {
					pit_sharp = pit_sharp >> 2;
				}
			}
		}
		else {
			/* read and decode pitch gain */
			/* index of gain(s) */
			index = *parm++;

			if (mode == MR795) {
				/* decode pitch gain */
				if (bfi != 0) {
					ec_gain_pitch(&st->ec_gain_p_st, st->state, &gain_pit);
				}
				else {
					gain_pit = d_gain_pitch(mode, index);
				}
				ec_gain_pitch_update(&st->ec_gain_p_st, bfi, st->prev_bf, &gain_pit
				);

				/* read and decode code gain */
				index = *parm++;

				if (bfi == 0) {
					d_gain_code(&st->pred_state, mode, index, code, &gain_code);
				}
				else {
					ec_gain_code(&st->ec_gain_c_st, &st->pred_state, st->state, &
						gain_code);
				}
				ec_gain_code_update(&st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
				);
				pit_sharp = gain_pit;

				if (pit_sharp > SHARPMAX) {
					pit_sharp = SHARPMAX;
				}
			}
			else {   /* MR122 */

				if (bfi == 0) {
					d_gain_code(&st->pred_state, mode, index, code, &gain_code);
				}
				else {
					ec_gain_code(&st->ec_gain_c_st, &st->pred_state, st->state, &
						gain_code);
				}
				ec_gain_code_update(&st->ec_gain_c_st, bfi, st->prev_bf, &gain_code
				);
				pit_sharp = gain_pit;
			}
		}

		/*
		* store pitch sharpening for next subframe
		* (for modes which use the previous pitch gain for
		*  pitch sharpening in the search phase)
		* do not update sharpening in even subframes for MR475
		*/
		if ((mode != MR475) || evenSubfr == 0) {
			st->sharp = gain_pit;

			if (st->sharp > SHARPMAX) {
				st->sharp = SHARPMAX;
			}
		}

		if (pit_sharp > 16383)
			pit_sharp = 32767;
		else
			pit_sharp *= 2;

		if (pit_sharp > 16384) {
			for (i = 0; i < L_SUBFR; i++) {
				temp = (st->old_exc[st->exc + i] * pit_sharp) >> 15;
				temp2 = (temp * gain_pit) << 1;

				if (mode == MR122) {
					temp2 = (temp2 >> 1);
				}
				excp[i] = (temp2 + 0x00008000L) >> 16;
			}
		}

		/*
		* Store list of LTP gains needed in the source
		* characteristic detector (SCD)
		*/
		if (bfi == 0) {
			for (i = 0; i < 8; i++) {
				st->ltpGainHistory[i] = st->ltpGainHistory[i + 1];
			}
			st->ltpGainHistory[8] = gain_pit;
		}


		/*
		* Limit gain_pit if in background noise and BFI
		* for MR475, MR515, MR59
		*/
		if ((st->prev_bf != 0 || bfi != 0) & (st->inBackgroundNoise != 0) & (
			(mode == MR475) || (mode == MR515) || (mode == MR59))) {
			/* if (gain_pit > 0.75) in Q14*/
			if (gain_pit > 12288)
				/* gain_pit = (gain_pit-0.75)/2.0 + 0.75; */
				gain_pit = ((gain_pit - 12288) >> 1) + 12288;

			/* if (gain_pit > 0.90) in Q14*/
			if (gain_pit > 14745) {
				gain_pit = 14745;
			}
		}

		/*
		* Calculate CB mixed gain
		*/
		Int_lsf(prev_lsf, st->lsfState.past_lsf_q, i_subfr, lsf_i);
		gain_code_mix = Cb_gain_average(&st->Cb_gain_averState, mode, gain_code,
			lsf_i, st->lsp_avg_st.lsp_meanSave, bfi, st->prev_bf, pdfi, st->
			prev_pdf, st->inBackgroundNoise, st->voicedHangover);

		/* make sure that MR74, MR795, MR122 have original codeGain*/
		/* MR74, MR795, MR122 */
		if ((mode > MR67) & (mode != MR102)) {
			gain_code_mix = gain_code;
		}

		/*
		* Find the total excitation.
		* Find synthesis speech corresponding to st->exc[].
		*/
		/* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/
		if (mode <= MR102) {
			pitch_fac = gain_pit;
			tmp_shift = 1;
		}

		/* MR122 */
		else {
			pitch_fac = gain_pit >> 1;
			tmp_shift = 2;
		}

		/*
		* copy unscaled LTP excitation to exc_enhanced (used in phase
		* dispersion below) and compute total excitation for LTP feedback
		*/
		memcpy(exc_enhanced, &st->old_exc[st->exc], L_SUBFR << 2);

		for (i = 0; i < L_SUBFR; i++) {
			/* st->exc[i] = gain_pit*st->exc[i] + gain_code*code[i]; */
			temp = (st->old_exc[st->exc + i] * pitch_fac) + (code[i] * gain_code);
			temp2 = (temp << tmp_shift);
			if (((temp2 >> 1) ^ temp2) & 0x40000000) {
				if ((temp ^ temp2) & 0x80000000) {
					temp2 = (temp & 0x80000000) ? (-1073741824L) : 1073725439;
				}
				else {
					temp2 = (temp2 & 0x80000000) ? (-1073741824L) : 1073725439;
				}
			}
			st->old_exc[st->exc + i] = (temp2 + 0x00004000L) >> 15;
		}
		/*
		* Adaptive phase dispersion
		*/

		/* free phase dispersion adaption */
		st->ph_disp_st.lockFull = 0;

		if (((mode == MR475) || (mode == MR515) || (mode == MR59)) & (st
			->voicedHangover > 3) & (st->inBackgroundNoise != 0) & (bfi != 0
				)) {
			/*
			* Always Use full Phase Disp.
			* if error in bg noise
			*/
			st->ph_disp_st.lockFull = 1;
		}

		/*
		* apply phase dispersion to innovation (if enabled) and
		* compute total excitation for synthesis part
		*/
		ph_disp(&st->ph_disp_st, mode, exc_enhanced, gain_code_mix, gain_pit, code
			, pitch_fac, tmp_shift);

		/*
		* The Excitation control module are active during BFI.
		* Conceal drops in signal energy if in bg noise.
		*/
		temp2 = 0;

		for (i = 0; i < L_SUBFR; i++) {
			temp2 += (exc_enhanced[i] * exc_enhanced[i]);
		}

		if (temp2 > 0x3FFFFFFF) {
			excEnergy = 11584;
		}
		else {
			temp2 = sqrt_l_exp(temp2, &temp);
			temp2 = (temp2 >> ((temp >> 1) + 15));
			excEnergy = temp2 >> 2;
		}

		if (((mode == MR475) || (mode == MR515) || (mode == MR59)) & (st
			->voicedHangover > 5) & (st->inBackgroundNoise != 0) & (st->
				state < 4) & (((pdfi != 0) & (st->prev_pdf != 0)) || bfi !=
					0 || st->prev_bf != 0)) {
			carefulFlag = 0;

			if ((pdfi != 0) & (bfi == 0)) {
				carefulFlag = 1;
			}
			Ex_ctrl(exc_enhanced, excEnergy, st->excEnergyHist, st->voicedHangover
				, st->prev_bf, carefulFlag);
		}

		if ((st->inBackgroundNoise != 0) & (bfi != 0 || st->prev_bf != 0) & (
			st->state < 4)) {
			;   /* do nothing! */
		}
		else {
			/* Update energy history for all modes */
			for (i = 0; i < 8; i++) {
				st->excEnergyHist[i] = st->excEnergyHist[i + 1];
			}
			st->excEnergyHist[8] = excEnergy;
		}

		/*
		* Excitation control module end.
		*/
		if (pit_sharp > 16384) {
			for (i = 0; i < L_SUBFR; i++) {
				excp[i] = excp[i] + exc_enhanced[i];
				if (labs(excp[i]) > 32767)
					excp[i] = (excp[i] & 0x80000000) ? -32768 : 32767;
			}
			agc2(exc_enhanced, excp);
			overflow = Syn_filt(Az, excp, &synth[i_subfr], L_SUBFR, st->mem_syn, 0
			);
		}
		else {
			overflow = Syn_filt(Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->
				mem_syn, 0);
		}

		if (overflow) {
			for (i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++) {
				st->old_exc[i] = st->old_exc[i] >> 2;
			}

			for (i = 0; i < L_SUBFR; i++) {
				exc_enhanced[i] = exc_enhanced[i] >> 2;
			}
			Syn_filt_overflow(Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1);
		}
		else {
			memcpy(st->mem_syn, &synth[i_subfr + 30], 40);
		}

		/*
		* Update signal for next frame.
		* -> shift to the left by L_SUBFR  st->exc[]
		*/
		memcpy(&st->old_exc[0], &st->old_exc[L_SUBFR], (PIT_MAX + L_INTERPOL) <<
			2);

		/* interpolated LPC parameters for next subframe */
		Az += MP1;

		/* store T0 for next subframe */
		st->old_T0 = T0;
	}

	/*
	* Call the Source Characteristic Detector which updates
	* st->inBackgroundNoise and st->voicedHangover.
	*/
	st->inBackgroundNoise = Bgn_scd(&st->background_state, &(st->ltpGainHistory[
		0]), &(synth[0]), &(st->voicedHangover));
	dtx_dec_activity_update(&st->dtxDecoderState, st->lsfState.past_lsf_q, synth);

	/* store bfi for next subframe */
	st->prev_bf = bfi;
	st->prev_pdf = pdfi;

	/*
	* Calculate the LSF averages on the eight
	* previous frames
	*/
	lsp_avg(&st->lsp_avg_st, st->lsfState.past_lsf_q);
theEnd:
	st->dtxDecoderState.dtxGlobalState = newDTXState;
	return;
}


/*
* Residu40
*
*
* Parameters:
*    a                 I: prediction coefficients
*    x                 I: speech signal
*    y                 O: residual signal
*
* Function:
*    The LP residual is computed by filtering the input
*    speech through the LP inverse filter a(z)
*
* Returns:
*    void
*/
__device__ static void Residu40(Word32 a[], Word32 x[], Word32 y[])
{
	Word32 s, i, j;


	for (i = 0; i < 40; i++) {
		s = a[0] * x[i] + a[1] * x[i - 1] + a[2] * x[i - 2] + a[3] * x[i - 3];
		s += a[4] * x[i - 4] + a[5] * x[i - 5] + a[6] * x[i - 6] + a[7] * x[i - 7]
			;
		s += a[8] * x[i - 8] + a[9] * x[i - 9] + a[10] * x[i - 10];
		y[i] = (s + 0x800) >> 12;
		if (abs(y[i]) > 32767) {
			/* go to safe mode */
			for (i = 0; i < 40; i++) {
				s = a[0] * x[i];
				for (j = 1; j <= 10; j++) {
					s += a[j] * x[i - j];
					if (s > 1073741823) {
						s = 1073741823;
					}
					else if (s < -1073741824) {
						s = -1073741824;
					}
				}
				y[i] = (s + 0x800) >> 12;
				if (abs(y[i]) > 32767)
					y[i] = (y[i] & 0x80000000) ? -32768 : 32767;
			}
			return;
		}

	}
	return;
}


/*
* agc
*
*
* Parameters:
*    st->past_gain     B: gain memory
*    sig_in            I: Post_Filter input signal
*    sig_out           B: Post_Filter output signal
*    agc_fac           I: AGC factor
*
* Function:
*    Scales the Post_Filter output on a subframe basis
*
* Returns:
*    void
*/
__device__ static void agc(agcState *st, Word32 *sig_in, Word32 *sig_out, Word16 agc_fac)
{
	Word32 s, gain_in, gain_out, g0, gain;
	int exp, i;


	/* calculate gain_out with exponent */
	s = energy_new(sig_out);

	if (s == 0) {
		st->past_gain = 0;
		return;
	}
	exp = 0;
	i = s;
	while (!(i & 0x40000000))
	{
		exp++;
		i = i << 1;
	}
	exp -= 1;
	if (exp & 0x80000000) {
		s >>= 1;
	}
	else {
		s <<= exp;
	}
	gain_out = (s + 0x00008000L) >> 16;

	/* calculate gain_in with exponent */
	s = energy_new(sig_in);

	if (s == 0) {
		g0 = 0;
	}
	else {
		i = 0;
		while (!(s & 0x40000000))
		{
			i++;
			s = s << 1;
		}
		s = s + 0x00008000L;

		if (s >= 0)
			gain_in = s >> 16;
		else
			gain_in = 32767;
		exp = (exp - i);

		/*
		* g0 = (1-agc_fac) * sqrt(gain_in/gain_out);
		*/
		/* s = gain_out / gain_in */
		s = (gain_out << 15) / gain_in;
		exp = 7 - exp;

		if (exp > 0) {
			if (exp > 31)
			{
				if (s) {
					s = 2147483647;
				}
			}
			else {
				s = s << exp;
			}
		}
		else
			s = (s >> (-exp));
		if (s < 0)
			s = 2147483647;
		s = Inv_sqrt(s);
		i = ((s << 9) + 0x00008000L) >> 16;
		if (i & 0xFFFF8000)
			i = 32767;

		/* g0 = i * (1-agc_fac) */
		g0 = (i * (32767 - agc_fac)) >> 15;
	}

	/*
	* compute gain[n] = agc_fac * gain[n-1] + (1-agc_fac) * sqrt(gain_in/gain_out)
	* sig_out[n] = gain[n] * sig_out[n]
	*/
	gain = st->past_gain;

	for (i = 0; i < L_SUBFR; i++) {
		gain = (gain * agc_fac) >> 15;
		gain = gain + g0;
		sig_out[i] = (sig_out[i] * gain) >> 12;
		if (labs(sig_out[i]) > 32767)
			sig_out[i] = (sig_out[i] & 0x8000000) ? -32768 : 32767;
	}
	st->past_gain = gain;
	return;
}


/*
* Post_Filter
*
*
* Parameters:
*    st                B: post filter states
*    mode              I: AMR mode
*    syn               B: synthesis speech
*    Az_4              I: interpolated LPC parameters in all subfr.
*
* Function:
*    Post_Filtering of synthesis speech.
*
*    inverse filtering of syn[] through A(z/0.7) to get res2[]
*    tilt compensation filtering; 1 - MU*k*z^-1
*    synthesis filtering through 1/A(z/0.75)
*    adaptive gain control
*
* Returns:
*    void
*/
__device__ static void Post_Filter(Post_FilterState *st, enum Mode mode, Word32 *syn,
	Word32 *Az_4)
{
	Word32 h[22], Ap3[MP1], Ap4[MP1];   /* bandwidth expanded LP parameters */
	Word32 tmp, i_subfr, i, temp1, temp2, overflow = 0;
	Word32 *Az, *p1, *p2, *syn_work = &st->synth_buf[M];
	const Word32 *pgamma3 = &gamma3[0];
	const Word32 *pgamma4 = &gamma4_gamma3_MR122[0];


	/*
	* Post filtering
	*/
	memcpy(syn_work, syn, L_FRAME << 2);
	Az = Az_4;

	if ((mode == MR122) || (mode == MR102)) {
		pgamma3 = &gamma4_gamma3_MR122[0];
		pgamma4 = &gamma4_MR122[0];
	}

	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR) {
		/* Find weighted filter coefficients Ap3[] and Ap[4] */
		Ap3[0] = Az[0];
		Ap4[0] = Az[0];

		for (i = 1; i <= 10; i++) {
			Ap3[i] = (Az[i] * pgamma3[i - 1] + 0x4000) >> 15;
			Ap4[i] = (Az[i] * pgamma4[i - 1] + 0x4000) >> 15;
		}

		/* filtering of synthesis speech by A(z/0.7) to find res2[] */
		Residu40(Ap3, &syn_work[i_subfr], st->res2);

		/* tilt compensation filter */
		/* impulse response of A(z/0.7)/A(z/0.75) */
		memcpy(h, Ap3, MP1 << 2);
		memset(&h[M + 1], 0, (22 - M - 1) << 2);
		Syn_filt(Ap4, h, h, 22, &h[M + 1], 0);

		/* 1st correlation of h[] */
		tmp = 16777216 + h[1] * h[1];

		for (i = 2; i < 22; i++) {
			tmp += h[i] * h[i];
			if (tmp > 0x3FFF8000)
				break;
		}
		temp1 = tmp >> 15;
		if (temp1 & 0xFFFF8000)
			temp1 = 32767;

		tmp = h[0] * h[1];

		for (i = 1; i < 21; i++) {
			tmp += h[i] * h[i + 1];
			if (abs(tmp) > 1073741823)
				tmp = 1073741823;
		}
		temp2 = tmp >> 15;

		if (temp2 <= 0) {
			temp2 = 0;
		}
		else {
			tmp = temp2 * 26214;
			temp2 = (tmp & 0xffff8000) / temp1;
		}

		/* preemphasis */
		p1 = st->res2 + 39;
		p2 = p1 - 1;
		tmp = *p1;

		do {
			*p1 = *p1 - ((temp2 * *p2--) >> 15);
			if (abs(*p1) > 32767) {
				*p1 = (*p1 & 0x80000000) ? -32768 : 32767;
			}
			p1--;
			*p1 = *p1 - ((temp2 * *p2--) >> 15);
			if (abs(*p1) > 32767) {
				*p1 = (*p1 & 0x80000000) ? -32768 : 32767;
			}
			p1--;
			*p1 = *p1 - ((temp2 * *p2--) >> 15);
			if (abs(*p1) > 32767) {
				*p1 = (*p1 & 0x80000000) ? -32768 : 32767;
			}
			p1--;
		} while (p1 > st->res2);
		*p1 = *p1 - ((temp2 * st->preemph_state_mem_pre) >> 15);
		if (abs(*p1) > 32767) {
			*p1 = (*p1 & 0x80000000) ? -32768 : 32767;
		}
		st->preemph_state_mem_pre = tmp;

		/* filtering through  1/A(z/0.75) */
		overflow = Syn_filt(Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 0);
		if (overflow) {
			Syn_filt_overflow(Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 1);
			overflow = 0;
		}
		else {
			memcpy(st->mem_syn_pst, &syn[i_subfr + 30], 40);
		}

		/* scale output to input */
		agc(&st->agc_state, &syn_work[i_subfr], &syn[i_subfr], AGC_FAC);
		Az += MP1;
	}

	/* update syn_work[] buffer */
	memcpy(&syn_work[-M], &syn_work[L_FRAME - M], M << 2);
	return;
}


/*
* Post_Process
*
*
* Parameters:
*    st                B: post filter states
*    signal            B: signal
*
* Function:
*    Postprocessing of input speech.
*
*    2nd order high pass filtering with cut off frequency at 60 Hz.
*    Multiplication of output by two.
*
*
* Returns:
*    void
*/
__device__ static void Post_Process(Post_ProcessState *st, Word32 signal[])
{
	Word32 x2, tmp, i = 0;
	Word32 mask = 0x40000000;

	do {
		x2 = st->x1;
		st->x1 = st->x0;
		st->x0 = signal[i];

		/*
		* y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2
		*                    + a[1]*y[i-1] + a[2] * y[i-2];
		*/
		tmp = (st->y1_hi * 15836) + (((st->y1_lo * 15836) & (Word32)0xffff8000) >> 15);
		tmp += (st->y2_hi * -7667) + (((st->y2_lo * (-7667)) & (Word32)0xffff8000) >> 15);
		tmp += st->x0 * 7699;
		tmp += st->x1 * -15398;
		if (((tmp >> 1) ^ tmp) & mask)
			tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;

		tmp += x2 * 7699;
		if (((tmp >> 1) ^ tmp) & mask)
			tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;

		tmp = tmp << 1;
		if (((tmp >> 1) ^ tmp) & mask)
			tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;

		tmp = tmp << 1;
		if (((tmp >> 1) ^ tmp) & mask)
			tmp = (tmp & 0x80000000) ? -1073741824 : 1073741823;

		if (labs(tmp) < 536862720) {
			signal[i++] = (tmp + 0x00002000L) >> 14;
		}
		else if (tmp > 0) {
			signal[i++] = 32767;
		}
		else {
			signal[i++] = -32768;
		}
		st->y2_hi = st->y1_hi;
		st->y2_lo = st->y1_lo;
		st->y1_hi = tmp >> 15;
		st->y1_lo = ((tmp << 1) - (st->y1_hi << 16)) >> 1;
	} while (i < 160);
	return;
}


/*
* Speech_Decode_Frame
*
*
* Parameters:
*    st                B: decoder memory
*    mode              I: AMR mode
*    parm              I: speech parameters
*    frame_type        I: Frame type
*    synth             O: synthesis speech

* Function:
*    Decode one frame
*
* Returns:
*    void
*/
__device__ void Speech_Decode_Frame(Speech_Decode_FrameState* state, enum Mode mode, Word16 *parm, enum
	RXFrameType frame_type, Word16 *synth)
{
	Word32 Az_dec[AZ_SIZE];   /* Decoded Az for post-filter in 4 subframes*/
	Word32 synth_speech[L_FRAME];
	Word32 i;

	/* Synthesis */
	Decoder_amr(&state->decoder_amrState, mode, parm, frame_type, synth_speech, Az_dec);
	Post_Filter(&state->post_state, mode, synth_speech, Az_dec);

	/* post HP filter, and 15->16 bits */
	Post_Process(&state->postHP_state, synth_speech);

	for (i = 0; i < L_FRAME; i++) {
#ifndef NO13BIT
		/* Truncate to 13 bits */
		synth[i] = (Word16)(synth_speech[i] & 0xfff8);
#else
		synth[i] = (Word16)(synth_speech[i]);
#endif
	}


	return;
}

/*
* Post_Process_reset
*
*
* Parameters:
*    state             B: state structure
*
* Function:
*    Resets state memory
*
* Returns:
*    -1 failure
*/
__device__ static int Post_Process_reset(Post_ProcessState *state)
{
	state->y2_hi = 0;
	state->y2_lo = 0;
	state->y1_hi = 0;
	state->y1_lo = 0;
	state->x0 = 0;
	state->x1 = 0;
	return 0;
}


/*
* Decoder_amr_init
*
*
* Parameters:
*    state             O: state structure
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    success = 0
*/
__device__ static int Decoder_amr_init(Decoder_amrState *state)
{
	Decoder_amr_reset(state, MR475);
	return 0;
}


/*
* Post_Filter_reset
*
*
* Parameters:
*    state             B: state structure
*
* Function:
*    Resets state memory
*
* Returns:
*    -1 failure
*/
__device__ static int Post_Filter_reset(Post_FilterState *state)
{
	state->preemph_state_mem_pre = 0;
	state->agc_state.past_gain = 4096;
	memset(state->mem_syn_pst, 0, M << 2);
	memset(state->res2, 0, L_SUBFR << 2);
	memset(state->synth_buf, 0, (L_FRAME + M) << 2);
	return 0;
}


/*
* Post_Filter_init
*
*
* Parameters:
*    state             O: state structure
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    success = 0
*/
__device__ static int Post_Filter_init(Post_FilterState* state)
{
	Post_Filter_reset(state);
	return 0;
}


/*
* Post_Process_init
*
*
* Parameters:
*    state             O: state structure
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    success = 0
*/
__device__ static int Post_Process_init(Post_ProcessState *state)
{
	Post_Process_reset(state);
	return 0;
}


/*
* Speech_Decode_Frame_reset
*
*
* Parameters:
*    state             B: state structure
*
* Function:
*    Resets state memory
*
* Returns:
*    -1 = failure
*/
__device__ int Speech_Decode_Frame_reset(Speech_Decode_FrameState* state)
{
	Decoder_amr_reset(&state->decoder_amrState, (enum Mode)0);
	Post_Filter_reset(&state->post_state);
	Post_Process_reset(&state->postHP_state);
	return 0;
}


/*
* Speech_Decode_Frame_init
*
*
* Parameters:
*    state             O: state structure
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    success = 0
*/
__device__ void Speech_Decode_Frame_init(Speech_Decode_FrameState* state)
{
	Decoder_amr_init(&state->decoder_amrState);
	Post_Filter_init(&state->post_state);
	Post_Process_init(&state->postHP_state);
	return;
}

__device__ enum Mode DecoderMMS(Word16 *param, UWord8 *stream, enum RXFrameType
	*frame_type, enum Mode *speech_mode, Word16 *q_bit)
{
	enum Mode mode;
	Word32 j;
	Word16 *mask;


	memset(param, 0, PRMNO_MR122 << 1);
	*q_bit = 0x01 & (*stream >> 2);
	mode = Mode(0x0F & (*stream >> 3));
	stream++;

	if (mode == MRDTX) {
		mask = order_MRDTX;

		for (j = 1; j < 36; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}

		/* get SID type bit */

		*frame_type = RX_SID_FIRST;
		if (*stream & 0x80)
			*frame_type = RX_SID_UPDATE;

		/* since there is update, use it */
		/* *frame_type = RX_SID_UPDATE; */

		/* speech mode indicator */
		*speech_mode = Mode((*stream >> 4) & 0x07);
		*speech_mode = Mode(((*speech_mode & 0x0001) << 2) | (*speech_mode & 0x0002) | ((*speech_mode & 0x0004) >> 2));

	}
	else if (mode == 15) {
		*frame_type = RX_NO_DATA;
	}
	else if (mode == MR475) {
		mask = order_MR475;

		for (j = 1; j < 96; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR515) {
		mask = order_MR515;

		for (j = 1; j < 104; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR59) {
		mask = order_MR59;

		for (j = 1; j < 119; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR67) {
		mask = order_MR67;

		for (j = 1; j < 135; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR74) {
		mask = order_MR74;

		for (j = 1; j < 149; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR795) {
		mask = order_MR795;

		for (j = 1; j < 160; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR102) {
		mask = order_MR102;

		for (j = 1; j < 205; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else if (mode == MR122) {
		mask = order_MR122;

		for (j = 1; j < 245; j++) {
			if (*stream & 0x80)
				param[*mask] = (short)(param[*mask] + *(mask + 1));
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
		*frame_type = RX_SPEECH_GOOD;
	}
	else
		*frame_type = RX_SPEECH_BAD;
	return mode;
}

/*
* Decoder_Interface_reset
*
*
* Parameters:
*    st                O: state struct
*
* Function:
*    Reset homing frame counter
*
* Returns:
*    void
*/
__device__ void Decoder_Interface_reset(dec_interface_State *st)
{
	st->reset_flag_old = 1;
	st->prev_ft = RX_SPEECH_GOOD;
	st->prev_mode = MR475;   /* minimum bitrate */
}


/*
* Decoder_Interface_init
*
*
* Parameters:
*    void
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    success           : pointer to structure
*    failure           : NULL
*/
__device__ void Decoder_Interface_init(dec_interface_State* state)
{
	Speech_Decode_Frame_init(&state->decoder_State);
	Decoder_Interface_reset(state);
}

/*
* Decoder_Interface_Decode
*
*
* Parameters:
*    st                B: state structure
*    bits              I: bit stream
*    synth             O: synthesized speech
*    bfi               I: bad frame indicator
*
* Function:
*    Decode bit stream to synthesized speech
*
* Returns:
*    Void
*/
__device__ void Decoder_Interface_Decode(dec_interface_State* state, UWord8 *bits, Word16 *synth, int bfi) {
	enum Mode mode;   /* AMR mode */

	enum Mode speech_mode = MR475;   /* speech mode */

	Word16 prm[PRMNO_MR122];   /* AMR parameters */

	enum RXFrameType frame_type;   /* frame type */

	const Word16 *homing;   /* pointer to homing frame */
	Word16 homingSize;   /* frame size for homing frame */
	Word32 i;   /* counter */
	Word32 resetFlag = 1;   /* homing frame */

	Word16 q_bit;

	/*
	* extract mode information and frametype,
	* octets to parameters
	*/
	mode = DecoderMMS(prm, bits, &frame_type, &speech_mode, &q_bit);
	if (!bfi)	bfi = 1 - q_bit;

	if (bfi == 1) {
		if (mode <= MR122) {
			frame_type = RX_SPEECH_BAD;
		}
		else if (frame_type != RX_NO_DATA) {
			frame_type = RX_SID_BAD;
			mode = state->prev_mode;
		}
	}
	else {
		if (frame_type == RX_SID_FIRST || frame_type == RX_SID_UPDATE) {
			mode = speech_mode;
		}
		else if (frame_type == RX_NO_DATA) {
			mode = state->prev_mode;
		}
		/*
		* if no mode information
		* guess one from the previous frame
		*/
		if (frame_type == RX_SPEECH_BAD) {
			mode = state->prev_mode;
			if (state->prev_ft >= RX_SID_FIRST) {
				frame_type = RX_SID_BAD;
			}
		}
	}

	/* test for homing frame */
	if (state->reset_flag_old == 1) {
		switch (mode) {
		case MR122:
			homing = dhf_MR122;
			homingSize = 18;
			break;

		case MR102:
			homing = dhf_MR102;
			homingSize = 12;
			break;

		case MR795:
			homing = dhf_MR795;
			homingSize = 8;
			break;

		case MR74:
			homing = dhf_MR74;
			homingSize = 7;
			break;

		case MR67:
			homing = dhf_MR67;
			homingSize = 7;
			break;

		case MR59:
			homing = dhf_MR59;
			homingSize = 7;
			break;

		case MR515:
			homing = dhf_MR515;
			homingSize = 7;
			break;

		case MR475:
			homing = dhf_MR475;
			homingSize = 7;
			break;

		default:
			homing = NULL;
			homingSize = 0;
			break;
		}

		for (i = 0; i < homingSize; i++) {
			resetFlag = prm[i] ^ homing[i];

			if (resetFlag)
				break;
		}
	}

	if ((resetFlag == 0) && (state->reset_flag_old != 0)) {
		for (i = 0; i < 160; i++) {
			synth[i] = EHF_MASK;
		}
	}
	else
		Speech_Decode_Frame(&state->decoder_State, mode, prm, frame_type, synth);

	if (state->reset_flag_old == 0) {
		/* check whole frame */
		switch (mode) {
		case MR122:
			homing = dhf_MR122;
			homingSize = PRMNO_MR122;
			break;

		case MR102:
			homing = dhf_MR102;
			homingSize = PRMNO_MR102;
			break;

		case MR795:
			homing = dhf_MR795;
			homingSize = PRMNO_MR795;
			break;

		case MR74:
			homing = dhf_MR74;
			homingSize = PRMNO_MR74;
			break;

		case MR67:
			homing = dhf_MR67;
			homingSize = PRMNO_MR67;
			break;

		case MR59:
			homing = dhf_MR59;
			homingSize = PRMNO_MR59;
			break;

		case MR515:
			homing = dhf_MR515;
			homingSize = PRMNO_MR515;
			break;

		case MR475:
			homing = dhf_MR475;
			homingSize = PRMNO_MR475;
			break;

		default:
			homing = NULL;
			homingSize = 0;
		}

		for (i = 0; i < homingSize; i++) {
			resetFlag = prm[i] ^ homing[i];

			if (resetFlag)
				break;
		}
	}

	/* reset decoder if current frame is a homing frame */
	if (resetFlag == 0) {
 Speech_Decode_Frame_reset(&state->decoder_State);
	}
	state->reset_flag_old = !resetFlag;
	state->prev_ft = frame_type;
	state->prev_mode = mode;
}
