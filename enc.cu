#include "device_launch_parameters.h"
#include "cuda_runtime.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>


#include <math.h>
#include <memory.h>
#include <float.h>
#include "typedef.h"
#include "enc.h"
#pragma warning(disable:4996)
#define PRMNO_MR475 17
#define PRMNO_MR515 19
#define PRMNO_MR59  19
#define PRMNO_MR67  19
#define PRMNO_MR74  19
#define PRMNO_MR795 23
#define PRMNO_MR102 39
#define PRMNO_MR122 57
#define PRMNO_MRDTX 5

/*
* tables
*/
__device__ static const UWord8 block_size[16] = { 13, 14, 16, 18, 20, 21, 27, 32,
6 , 0 , 0 , 0 , 0 , 0 , 0 , 1 };

__device__ static const UWord8 toc_byte[16] = { 0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C };
/* Subjective importance of the speech encoded bits */
__device__ static Word16 order_MR475[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	7, 0x8,
	7, 0x4,
	10, 0x8,
	10, 0x4,
	14, 0x8,
	14, 0x4,
	6, 0x1,
	6, 0x2,
	6, 0x4,
	6, 0x8,
	13, 0x1,
	13, 0x2,
	13, 0x4,
	13, 0x8,
	2, 0x20,
	2, 0x10,
	2, 0x4,
	2, 0x1,
	13, 0x10,
	13, 0x20,
	13, 0x40,
	13, 0x80,
	3, 0x2,
	3, 0x1,
	6, 0x10,
	6, 0x20,
	6, 0x40,
	6, 0x80,
	5, 0x2,
	5, 0x1,
	2, 0x40,
	2, 0x8,
	2, 0x2,
	7, 0x2,
	7, 0x1,
	9, 0x2,
	9, 0x1,
	10, 0x2,
	10, 0x1,
	12, 0x2,
	12, 0x1,
	14, 0x2,
	14, 0x1,
	16, 0x2,
	16, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x4,
	4, 0x2,
	8, 0x20,
	8, 0x10,
	8, 0x4,
	8, 0x2,
	11, 0x20,
	11, 0x10,
	11, 0x4,
	11, 0x2,
	15, 0x20,
	15, 0x10,
	15, 0x4,
	15, 0x2,
	4, 0x8,
	8, 0x8,
	11, 0x8,
	15, 0x8,
	4, 0x1,
	8, 0x1,
	11, 0x1,
	15, 0x1,
	4, 0x40,
	8, 0x40,
	11, 0x40,
	15, 0x40
};
__device__ static Word16 order_MR515[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	0, 0x80,
	1, 0x1,
	1, 0x2,
	1, 0x4,
	1, 0x8,
	1, 0x10,
	1, 0x20,
	1, 0x40,
	1, 0x80,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	7, 0x8,
	11, 0x8,
	15, 0x8,
	6, 0x1,
	6, 0x2,
	6, 0x4,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	14, 0x1,
	14, 0x2,
	14, 0x4,
	18, 0x1,
	18, 0x2,
	18, 0x4,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	3, 0x4,
	7, 0x4,
	11, 0x4,
	15, 0x4,
	2, 0x10,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	3, 0x2,
	7, 0x2,
	11, 0x2,
	2, 0x20,
	2, 0x4,
	2, 0x1,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	2, 0x2,
	3, 0x1,
	7, 0x1,
	11, 0x1,
	15, 0x2,
	2, 0x8,
	2, 0x40,
	15, 0x1,
	5, 0x1,
	5, 0x2,
	9, 0x1,
	9, 0x2,
	13, 0x1,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	13, 0x2,
	17, 0x1,
	17, 0x2,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x20,
	8, 0x20,
	4, 0x10,
	8, 0x10,
	12, 0x20,
	12, 0x10,
	16, 0x20,
	16, 0x10,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8
};
__device__ static Word16 order_MR59[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x8,
	0, 0x4,
	0, 0x10,
	0, 0x2,
	0, 0x1,
	0, 0x20,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x40,
	11, 0x40,
	3, 0x80,
	11, 0x80,
	3, 0x8,
	11, 0x8,
	7, 0x8,
	15, 0x8,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	3, 0x4,
	11, 0x4,
	7, 0x4,
	15, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	7, 0x2,
	15, 0x2,
	3, 0x2,
	11, 0x2,
	3, 0x1,
	11, 0x1,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	17, 0x1,
	5, 0x2,
	13, 0x2,
	17, 0x2,
	9, 0x2,
	9, 0x1,
	5, 0x1,
	13, 0x1,
	2, 0x1,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	7, 0x1,
	15, 0x1,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x10,
	8, 0x10,
	12, 0x10,
	16, 0x10,
	4, 0x20,
	8, 0x20,
	12, 0x20,
	16, 0x20
};
__device__ static Word16 order_MR67[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x8,
	0, 0x10,
	0, 0x4,
	0, 0x2,
	1, 0x8,
	0, 0x1,
	0, 0x20,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x2,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x40,
	11, 0x40,
	3, 0x80,
	11, 0x80,
	3, 0x8,
	11, 0x8,
	1, 0x1,
	7, 0x8,
	15, 0x8,
	7, 0x4,
	15, 0x4,
	3, 0x4,
	11, 0x4,
	7, 0x2,
	15, 0x2,
	6, 0x40,
	10, 0x40,
	14, 0x40,
	18, 0x40,
	3, 0x2,
	11, 0x2,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	7, 0x1,
	15, 0x1,
	3, 0x1,
	11, 0x1,
	2, 0x40,
	2, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	2, 0x10,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	5, 0x1,
	9, 0x1,
	13, 0x1,
	17, 0x1,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	5, 0x2,
	9, 0x2,
	13, 0x2,
	17, 0x2,
	18, 0x20,
	14, 0x20,
	10, 0x20,
	6, 0x20,
	5, 0x4,
	9, 0x4,
	13, 0x4,
	17, 0x4,
	4, 0x4,
	8, 0x4,
	12, 0x4,
	16, 0x4,
	4, 0x20,
	8, 0x20,
	12, 0x20,
	16, 0x20,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40,
	4, 0x200,
	8, 0x200,
	12, 0x200,
	16, 0x200,
	4, 0x400,
	8, 0x400,
	12, 0x400,
	16, 0x400,
	4, 0x1,
	8, 0x1,
	12, 0x1,
	16, 0x1,
	4, 0x2,
	8, 0x2,
	12, 0x2,
	16, 0x2,
	4, 0x8,
	8, 0x8,
	12, 0x8,
	16, 0x8,
	4, 0x10,
	8, 0x10,
	12, 0x10,
	16, 0x10,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100
};
__device__ static Word16 order_MR74[] =
{
	0, 0x80,
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x100,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	3, 0x80,
	11, 0x80,
	3, 0x40,
	11, 0x40,
	3, 0x20,
	11, 0x20,
	3, 0x10,
	11, 0x10,
	3, 0x8,
	11, 0x8,
	6, 0x40,
	10, 0x40,
	14, 0x40,
	18, 0x40,
	6, 0x20,
	10, 0x20,
	14, 0x20,
	18, 0x20,
	6, 0x8,
	10, 0x8,
	14, 0x8,
	18, 0x8,
	6, 0x4,
	10, 0x4,
	14, 0x4,
	18, 0x4,
	7, 0x10,
	15, 0x10,
	7, 0x8,
	15, 0x8,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	3, 0x4,
	7, 0x4,
	11, 0x4,
	15, 0x4,
	6, 0x2,
	10, 0x2,
	14, 0x2,
	18, 0x2,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	5, 0x1,
	9, 0x1,
	13, 0x1,
	17, 0x1,
	6, 0x1,
	10, 0x1,
	14, 0x1,
	18, 0x1,
	5, 0x2,
	9, 0x2,
	13, 0x2,
	17, 0x2,
	5, 0x4,
	9, 0x4,
	6, 0x10,
	10, 0x10,
	14, 0x10,
	18, 0x10,
	13, 0x4,
	17, 0x4,
	5, 0x8,
	9, 0x8,
	13, 0x8,
	17, 0x8,
	3, 0x2,
	3, 0x1,
	7, 0x2,
	7, 0x1,
	11, 0x2,
	11, 0x1,
	15, 0x2,
	15, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	4, 0x2,
	4, 0x1,
	8, 0x20,
	8, 0x10,
	8, 0x8,
	8, 0x4,
	8, 0x2,
	8, 0x1,
	12, 0x20,
	12, 0x10,
	12, 0x8,
	12, 0x4,
	12, 0x2,
	12, 0x1,
	16, 0x20,
	16, 0x10,
	16, 0x8,
	16, 0x4,
	16, 0x2,
	16, 0x1,
	4, 0x1000,
	8, 0x1000,
	12, 0x1000,
	16, 0x1000,
	4, 0x800,
	8, 0x800,
	12, 0x800,
	16, 0x800,
	4, 0x400,
	8, 0x400,
	12, 0x400,
	16, 0x400,
	4, 0x200,
	8, 0x200,
	12, 0x200,
	16, 0x200,
	4, 0x100,
	8, 0x100,
	12, 0x100,
	16, 0x100,
	4, 0x80,
	8, 0x80,
	12, 0x80,
	16, 0x80,
	4, 0x40,
	8, 0x40,
	12, 0x40,
	16, 0x40
};
__device__ static Word16 order_MR795[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	7, 0x10,
	12, 0x10,
	17, 0x10,
	22, 0x10,
	7, 0x8,
	12, 0x8,
	17, 0x8,
	22, 0x8,
	7, 0x4,
	12, 0x4,
	17, 0x4,
	22, 0x4,
	6, 0x8,
	11, 0x8,
	16, 0x8,
	21, 0x8,
	6, 0x4,
	11, 0x4,
	16, 0x4,
	21, 0x4,
	3, 0x80,
	13, 0x80,
	3, 0x40,
	13, 0x40,
	3, 0x20,
	13, 0x20,
	3, 0x10,
	13, 0x10,
	3, 0x8,
	13, 0x8,
	8, 0x20,
	18, 0x20,
	8, 0x10,
	18, 0x10,
	8, 0x8,
	18, 0x8,
	7, 0x2,
	12, 0x2,
	17, 0x2,
	22, 0x2,
	3, 0x4,
	13, 0x4,
	8, 0x4,
	18, 0x4,
	0, 0x80,
	0, 0x100,
	2, 0x2,
	2, 0x1,
	3, 0x2,
	13, 0x2,
	3, 0x1,
	13, 0x1,
	8, 0x2,
	18, 0x2,
	8, 0x1,
	18, 0x1,
	6, 0x2,
	11, 0x2,
	16, 0x2,
	21, 0x2,
	7, 0x1,
	12, 0x1,
	17, 0x1,
	22, 0x1,
	6, 0x1,
	11, 0x1,
	16, 0x1,
	21, 0x1,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	4, 0x2,
	9, 0x2,
	14, 0x2,
	19, 0x2,
	4, 0x10,
	9, 0x10,
	14, 0x10,
	19, 0x10,
	4, 0x80,
	9, 0x80,
	14, 0x80,
	19, 0x80,
	4, 0x800,
	9, 0x800,
	14, 0x800,
	19, 0x800,
	15, 0x8,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	20, 0x8,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	10, 0x8,
	5, 0x1,
	5, 0x2,
	5, 0x4,
	5, 0x8,
	4, 0x1,
	4, 0x4,
	4, 0x8,
	4, 0x20,
	4, 0x100,
	4, 0x1000,
	9, 0x1,
	9, 0x4,
	9, 0x8,
	9, 0x20,
	9, 0x100,
	9, 0x1000,
	14, 0x1,
	14, 0x4,
	14, 0x8,
	14, 0x20,
	14, 0x100,
	14, 0x1000,
	19, 0x1,
	19, 0x4,
	19, 0x8,
	19, 0x20,
	19, 0x100,
	19, 0x1000,
	4, 0x40,
	9, 0x40,
	14, 0x40,
	19, 0x40,
	4, 0x400,
	9, 0x400,
	14, 0x400,
	19, 0x400,
	4, 0x200,
	9, 0x200,
	14, 0x200,
	19, 0x200,
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	1, 0x8,
	1, 0x2,
	1, 0x100,
	1, 0x80,
	1, 0x20,
	1, 0x10,
	1, 0x4,
	1, 0x40,
	1, 0x1,
	2, 0x40,
	2, 0x10,
	2, 0x4,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	7, 0x10,
	12, 0x10,
	17, 0x10,
	22, 0x10,
	7, 0x8,
	12, 0x8,
	17, 0x8,
	22, 0x8,
	7, 0x4,
	12, 0x4,
	17, 0x4,
	22, 0x4,
	6, 0x8,
	11, 0x8,
	16, 0x8,
	21, 0x8,
	6, 0x4,
	11, 0x4,
	16, 0x4,
	21, 0x4,
	3, 0x80,
	13, 0x80,
	3, 0x40,
	13, 0x40,
	3, 0x20,
	13, 0x20,
	3, 0x10,
	13, 0x10,
	3, 0x8,
	13, 0x8,
	8, 0x20,
	18, 0x20,
	8, 0x10,
	18, 0x10,
	8, 0x8,
	18, 0x8,
	7, 0x2,
	12, 0x2,
	17, 0x2,
	22, 0x2,
	3, 0x4,
	13, 0x4,
	8, 0x4,
	18, 0x4,
	0, 0x80,
	0, 0x100,
	2, 0x2,
	2, 0x1,
	3, 0x2,
	13, 0x2,
	3, 0x1,
	13, 0x1,
	8, 0x2,
	18, 0x2,
	8, 0x1,
	18, 0x1,
	6, 0x2,
	11, 0x2,
	16, 0x2,
	21, 0x2,
	7, 0x1,
	12, 0x1,
	17, 0x1,
	22, 0x1,
	6, 0x1,
	11, 0x1,
	16, 0x1,
	21, 0x1,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	4, 0x2,
	9, 0x2,
	14, 0x2,
	19, 0x2,
	4, 0x10,
	9, 0x10,
	14, 0x10,
	19, 0x10,
	4, 0x80,
	9, 0x80,
	14, 0x80,
	19, 0x80,
	4, 0x800,
	9, 0x800,
	14, 0x800,
	19, 0x800,
	15, 0x8,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	20, 0x8,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	10, 0x8,
	5, 0x1,
	5, 0x2,
	5, 0x4,
	5, 0x8,
	4, 0x1,
	4, 0x4,
	4, 0x8,
	4, 0x20,
	4, 0x100,
	4, 0x1000,
	9, 0x1,
	9, 0x4,
	9, 0x8,
	9, 0x20,
	9, 0x100,
	9, 0x1000,
	14, 0x1,
	14, 0x4,
	14, 0x8,
	14, 0x20,
	14, 0x100,
	14, 0x1000,
	19, 0x1,
	19, 0x4,
	19, 0x8,
	19, 0x20,
	19, 0x100,
	19, 0x1000,
	4, 0x40,
	9, 0x40,
	14, 0x40,
	19, 0x40,
	4, 0x400,
	9, 0x400,
	14, 0x400,
	19, 0x400,
	4, 0x200,
	9, 0x200,
	14, 0x200,
	19, 0x200
};
__device__ static Word16 order_MR102[] =
{
	0, 0x1,
	0, 0x2,
	0, 0x4,
	0, 0x8,
	0, 0x10,
	0, 0x20,
	0, 0x40,
	0, 0x80,
	1, 0x1,
	1, 0x2,
	1, 0x4,
	1, 0x8,
	1, 0x10,
	1, 0x20,
	1, 0x40,
	1, 0x80,
	1, 0x100,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	21, 0x80,
	21, 0x40,
	21, 0x20,
	21, 0x10,
	21, 0x8,
	21, 0x4,
	12, 0x10,
	12, 0x8,
	30, 0x10,
	30, 0x8,
	11, 0x40,
	11, 0x8,
	11, 0x4,
	20, 0x40,
	20, 0x8,
	20, 0x4,
	29, 0x40,
	29, 0x8,
	29, 0x4,
	38, 0x40,
	38, 0x8,
	38, 0x4,
	3, 0x2,
	3, 0x1,
	21, 0x2,
	21, 0x1,
	12, 0x4,
	12, 0x2,
	30, 0x4,
	30, 0x2,
	11, 0x20,
	20, 0x20,
	29, 0x20,
	38, 0x20,
	2, 0x40,
	2, 0x4,
	2, 0x10,
	2, 0x8,
	2, 0x80,
	2, 0x100,
	2, 0x20,
	2, 0x2,
	2, 0x1,
	7, 0x1,
	6, 0x1,
	5, 0x1,
	4, 0x1,
	16, 0x1,
	15, 0x1,
	14, 0x1,
	13, 0x1,
	25, 0x1,
	24, 0x1,
	23, 0x1,
	22, 0x1,
	34, 0x1,
	33, 0x1,
	32, 0x1,
	31, 0x1,
	11, 0x2,
	11, 0x10,
	11, 0x1,
	20, 0x2,
	20, 0x10,
	20, 0x1,
	29, 0x2,
	29, 0x10,
	29, 0x1,
	38, 0x2,
	38, 0x10,
	38, 0x1,
	12, 0x1,
	30, 0x1,
	17, 0x200,
	17, 0x100,
	18, 0x100,
	18, 0x200,
	18, 0x80,
	17, 0x80,
	18, 0x20,
	17, 0x20,
	17, 0x40,
	18, 0x40,
	19, 0x40,
	19, 0x20,
	18, 0x10,
	19, 0x8,
	17, 0x10,
	19, 0x10,
	17, 0x8,
	18, 0x8,
	26, 0x200,
	26, 0x100,
	27, 0x100,
	27, 0x200,
	27, 0x80,
	26, 0x80,
	27, 0x20,
	26, 0x20,
	26, 0x40,
	27, 0x40,
	28, 0x40,
	28, 0x20,
	27, 0x10,
	28, 0x8,
	26, 0x10,
	28, 0x10,
	26, 0x8,
	27, 0x8,
	35, 0x200,
	35, 0x100,
	36, 0x100,
	36, 0x200,
	36, 0x80,
	35, 0x80,
	36, 0x20,
	35, 0x20,
	35, 0x40,
	36, 0x40,
	37, 0x40,
	37, 0x20,
	36, 0x10,
	37, 0x8,
	35, 0x10,
	37, 0x10,
	35, 0x8,
	36, 0x8,
	8, 0x200,
	8, 0x100,
	9, 0x100,
	9, 0x200,
	9, 0x80,
	8, 0x80,
	9, 0x20,
	8, 0x20,
	8, 0x40,
	9, 0x40,
	10, 0x40,
	10, 0x20,
	9, 0x10,
	10, 0x8,
	8, 0x10,
	10, 0x10,
	8, 0x8,
	9, 0x8,
	37, 0x4,
	35, 0x1,
	36, 0x1,
	37, 0x1,
	35, 0x4,
	37, 0x2,
	35, 0x2,
	36, 0x4,
	36, 0x2,
	28, 0x4,
	26, 0x1,
	27, 0x1,
	28, 0x1,
	26, 0x4,
	28, 0x2,
	26, 0x2,
	27, 0x4,
	27, 0x2,
	19, 0x4,
	17, 0x1,
	18, 0x1,
	19, 0x1,
	17, 0x4,
	19, 0x2,
	17, 0x2,
	18, 0x4,
	18, 0x2,
	10, 0x4,
	8, 0x1,
	9, 0x1,
	10, 0x1,
	8, 0x4,
	10, 0x2,
	8, 0x2,
	9, 0x4,
	9, 0x2
};
__device__ static Word16 order_MR122[] =
{
	0, 0x40,
	0, 0x20,
	0, 0x10,
	0, 0x8,
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	2, 0x1,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	2, 0x20,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x2,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	5, 0x100,
	31, 0x100,
	5, 0x80,
	31, 0x80,
	5, 0x40,
	31, 0x40,
	5, 0x20,
	31, 0x20,
	5, 0x10,
	31, 0x10,
	5, 0x8,
	31, 0x8,
	5, 0x4,
	31, 0x4,
	5, 0x2,
	31, 0x2,
	5, 0x1,
	31, 0x1,
	6, 0x8,
	19, 0x8,
	32, 0x8,
	45, 0x8,
	6, 0x4,
	19, 0x4,
	32, 0x4,
	45, 0x4,
	6, 0x2,
	19, 0x2,
	32, 0x2,
	45, 0x2,
	17, 0x10,
	30, 0x10,
	43, 0x10,
	56, 0x10,
	17, 0x8,
	30, 0x8,
	43, 0x8,
	56, 0x8,
	17, 0x4,
	30, 0x4,
	43, 0x4,
	56, 0x4,
	18, 0x20,
	44, 0x20,
	18, 0x10,
	44, 0x10,
	18, 0x8,
	44, 0x8,
	18, 0x4,
	44, 0x4,
	18, 0x2,
	44, 0x2,
	3, 0x4,
	3, 0x2,
	3, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	6, 0x1,
	19, 0x1,
	32, 0x1,
	45, 0x1,
	17, 0x2,
	30, 0x2,
	43, 0x2,
	56, 0x2,
	7, 0x8,
	20, 0x8,
	33, 0x8,
	46, 0x8,
	8, 0x8,
	21, 0x8,
	34, 0x8,
	47, 0x8,
	17, 0x1,
	30, 0x1,
	43, 0x1,
	56, 0x1,
	9, 0x8,
	22, 0x8,
	35, 0x8,
	48, 0x8,
	10, 0x8,
	23, 0x8,
	36, 0x8,
	49, 0x8,
	11, 0x8,
	24, 0x8,
	37, 0x8,
	50, 0x8,
	4, 0x2,
	4, 0x1,
	7, 0x1,
	7, 0x2,
	7, 0x4,
	8, 0x1,
	8, 0x2,
	8, 0x4,
	9, 0x1,
	9, 0x2,
	9, 0x4,
	10, 0x1,
	10, 0x2,
	10, 0x4,
	11, 0x1,
	11, 0x2,
	11, 0x4,
	20, 0x1,
	20, 0x2,
	20, 0x4,
	21, 0x1,
	21, 0x2,
	21, 0x4,
	22, 0x1,
	22, 0x2,
	22, 0x4,
	23, 0x1,
	23, 0x2,
	23, 0x4,
	24, 0x1,
	24, 0x2,
	24, 0x4,
	33, 0x1,
	33, 0x2,
	33, 0x4,
	34, 0x1,
	34, 0x2,
	34, 0x4,
	35, 0x1,
	35, 0x2,
	35, 0x4,
	36, 0x1,
	36, 0x2,
	36, 0x4,
	37, 0x1,
	37, 0x2,
	37, 0x4,
	46, 0x1,
	46, 0x2,
	46, 0x4,
	47, 0x1,
	47, 0x2,
	47, 0x4,
	48, 0x1,
	48, 0x2,
	48, 0x4,
	49, 0x1,
	49, 0x2,
	49, 0x4,
	50, 0x1,
	50, 0x2,
	50, 0x4,
	12, 0x1,
	12, 0x2,
	12, 0x4,
	13, 0x1,
	13, 0x2,
	13, 0x4,
	14, 0x1,
	14, 0x2,
	14, 0x4,
	15, 0x1,
	15, 0x2,
	15, 0x4,
	16, 0x1,
	16, 0x2,
	16, 0x4,
	25, 0x1,
	25, 0x2,
	25, 0x4,
	26, 0x1,
	26, 0x2,
	26, 0x4,
	27, 0x1,
	27, 0x2,
	27, 0x4,
	28, 0x1,
	28, 0x2,
	28, 0x4,
	29, 0x1,
	29, 0x2,
	29, 0x4,
	38, 0x1,
	38, 0x2,
	38, 0x4,
	39, 0x1,
	39, 0x2,
	39, 0x4,
	40, 0x1,
	40, 0x2,
	40, 0x4,
	41, 0x1,
	41, 0x2,
	41, 0x4,
	42, 0x1,
	42, 0x2,
	42, 0x4,
	51, 0x1,
	51, 0x2,
	51, 0x4,
	52, 0x1,
	52, 0x2,
	52, 0x4,
	53, 0x1,
	53, 0x2,
	53, 0x4,
	54, 0x1,
	54, 0x2,
	54, 0x4,
	55, 0x1,
	55, 0x2,
	55, 0x4,
	18, 0x1,
	44, 0x1
};
__device__ static Word16 order_MRDTX[] =
{
	0, 0x4,
	0, 0x2,
	0, 0x1,
	1, 0x80,
	1, 0x40,
	1, 0x20,
	1, 0x10,
	1, 0x8,
	1, 0x4,
	1, 0x2,
	1, 0x1,
	2, 0x100,
	2, 0x80,
	2, 0x40,
	2, 0x20,
	2, 0x10,
	2, 0x8,
	2, 0x4,
	2, 0x2,
	2, 0x1,
	3, 0x100,
	3, 0x80,
	3, 0x40,
	3, 0x20,
	3, 0x10,
	3, 0x8,
	3, 0x4,
	3, 0x2,
	3, 0x1,
	4, 0x20,
	4, 0x10,
	4, 0x8,
	4, 0x4,
	4, 0x2,
	4, 0x1
};

/* Homing frames for the decoder */
__device__ static const Word16 dhf_MR475[PRMNO_MR475] =
{
	0x00F8,
	0x009D,
	0x001C,
	0x0066,
	0x0000,
	0x0003,
	0x0028,
	0x000F,
	0x0038,
	0x0001,
	0x000F,
	0x0031,
	0x0002,
	0x0008,
	0x000F,
	0x0026,
	0x0003
};
__device__ static const Word16 dhf_MR515[PRMNO_MR515] =
{
	0x00F8,
	0x009D,
	0x001C,
	0x0066,
	0x0000,
	0x0003,
	0x0037,
	0x000F,
	0x0000,
	0x0003,
	0x0005,
	0x000F,
	0x0037,
	0x0003,
	0x0037,
	0x000F,
	0x0023,
	0x0003,
	0x001F
};
__device__ static const Word16 dhf_MR59[PRMNO_MR59] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0000,
	0x0003,
	0x0037,
	0x000F,
	0x0001,
	0x0003,
	0x000F,
	0x0060,
	0x00F9,
	0x0003,
	0x0037,
	0x000F,
	0x0000,
	0x0003,
	0x0037
};
__device__ static const Word16 dhf_MR67[PRMNO_MR67] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0002,
	0x0007,
	0x0000,
	0x000F,
	0x0098,
	0x0007,
	0x0061,
	0x0060,
	0x05C5,
	0x0007,
	0x0000,
	0x000F,
	0x0318,
	0x0007,
	0x0000
};
__device__ static const Word16 dhf_MR74[PRMNO_MR74] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x00BD,
	0x0006,
	0x000F,
	0x0000,
	0x001B,
	0x0208,
	0x000F,
	0x0062,
	0x0060,
	0x1BA6,
	0x000F,
	0x0000,
	0x001B,
	0x0006,
	0x000F,
	0x0000
};
__device__ static const Word16 dhf_MR795[PRMNO_MR795] =
{
	0x00C2,
	0x00E3,
	0x002F,
	0x00BD,
	0x0006,
	0x000F,
	0x000A,
	0x0000,
	0x0039,
	0x1C08,
	0x0007,
	0x000A,
	0x000B,
	0x0063,
	0x11A6,
	0x000F,
	0x0001,
	0x0000,
	0x0039,
	0x09A0,
	0x000F,
	0x0002,
	0x0001
};
__device__ static const Word16 dhf_MR102[PRMNO_MR102] =
{
	0x00F8,
	0x00E3,
	0x002F,
	0x0045,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x001B,
	0x0000,
	0x0001,
	0x0000,
	0x0001,
	0x0326,
	0x00CE,
	0x007E,
	0x0051,
	0x0062,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x015A,
	0x0359,
	0x0076,
	0x0000,
	0x001B,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x017C,
	0x0215,
	0x0038,
	0x0030
};
__device__ static const Word16 dhf_MR122[PRMNO_MR122] =
{
	0x0004,
	0x002A,
	0x00DB,
	0x0096,
	0x002A,
	0x0156,
	0x000B,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0000,
	0x0036,
	0x000B,
	0x0000,
	0x000F,
	0x000E,
	0x000C,
	0x000D,
	0x0000,
	0x0001,
	0x0005,
	0x0007,
	0x0001,
	0x0008,
	0x0024,
	0x0000,
	0x0001,
	0x0000,
	0x0005,
	0x0006,
	0x0001,
	0x0002,
	0x0004,
	0x0007,
	0x0004,
	0x0002,
	0x0003,
	0x0036,
	0x000B,
	0x0000,
	0x0002,
	0x0004,
	0x0000,
	0x0003,
	0x0006,
	0x0001,
	0x0007,
	0x0006,
	0x0005,
	0x0000
};


/* parameter sizes (# of bits), one table per mode */
__device__ static const Word16 bitno_MR475[PRMNO_MR475] =
{
	8, 8, 7,    /* LSP VQ          */
	8, 7, 2, 8, /* first subframe  */
	4, 7, 2,    /* second subframe */
	4, 7, 2, 8, /* third subframe  */
	4, 7, 2     /* fourth subframe */
};
__device__ static const Word16 bitno_MR515[PRMNO_MR515] =
{
	8, 8, 7,    /* LSP VQ          */
	8, 7, 2, 6, /* first subframe  */
	4, 7, 2, 6, /* second subframe */
	4, 7, 2, 6, /* third subframe  */
	4, 7, 2, 6  /* fourth subframe */
};
__device__ static const Word16 bitno_MR59[PRMNO_MR59] =
{
	8, 9, 9,    /* LSP VQ          */
	8, 9, 2, 6, /* first subframe  */
	4, 9, 2, 6, /* second subframe */
	8, 9, 2, 6, /* third subframe  */
	4, 9, 2, 6  /* fourth subframe */
};
__device__ static const Word16 bitno_MR67[PRMNO_MR67] =
{
	8, 9, 9,       /* LSP VQ          */
	8, 11, 3, 7,   /* first subframe  */
	4, 11, 3, 7,   /* second subframe */
	8, 11, 3, 7,   /* third subframe  */
	4, 11, 3, 7    /* fourth subframe */
};
__device__ static const Word16 bitno_MR74[PRMNO_MR74] =
{
	8, 9, 9,       /* LSP VQ          */
	8, 13, 4, 7,   /* first subframe  */
	5, 13, 4, 7,   /* second subframe */
	8, 13, 4, 7,   /* third subframe  */
	5, 13, 4, 7    /* fourth subframe */
};
__device__ static const Word16 bitno_MR795[PRMNO_MR795] =
{
	9, 9, 9,          /* LSP VQ          */
	8, 13, 4, 4, 5,   /* first subframe  */
	6, 13, 4, 4, 5,   /* second subframe */
	8, 13, 4, 4, 5,   /* third subframe  */
	6, 13, 4, 4, 5    /* fourth subframe */
};
__device__ static const Word16 bitno_MR102[PRMNO_MR102] =
{
	8, 9, 9,                      /* LSP VQ          */
	8, 1, 1, 1, 1, 10, 10, 7, 7,  /* first subframe  */
	5, 1, 1, 1, 1, 10, 10, 7, 7,  /* second subframe */
	8, 1, 1, 1, 1, 10, 10, 7, 7,  /* third subframe  */
	5, 1, 1, 1, 1, 10, 10, 7, 7   /* fourth subframe */
};
__device__ static const Word16 bitno_MR122[PRMNO_MR122] =
{
	7, 8, 9, 8, 6,                            /* LSP VQ          */
	9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* first subframe  */
	6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* second subframe */
	9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,    /* third subframe  */
	6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5     /* fourth subframe */
};
__device__ static const Word16 bitno_MRDTX[PRMNO_MRDTX] =
{
	3, 8, 9, 9, 6
};
#define SCALE_LSP_FREQ  (Float32)(4000.0/3.141592654)
#define SCALE_FREQ_LSP  (Float32)(3.141592654/4000.0)
#define SLOPE1_WGHT_LSF (Float32)((3.347-1.8)/(450.0-0.0))
#define SLOPE2_WGHT_LSF (Float32)((1.8-1.0)/(1500.0-450.0))

#define FRAME_LEN 160    /* Length (samples) of the input frame          */
#define INV_COMPLEN 3641 /* 1.0/COMPLEN*2^15                             */
#define LOOKAHEAD 40     /* length of the lookahead used by speech coder */

#define UNITY 512        /* Scaling used with SNR calculation            */
#define UNIRSHFT 6       /* = log2(MAX_16/UNITY)                         */

#define TONE_THR 0.65F   /* Threshold for tone detection   */

/* Constants for background spectrum update */
#define ALPHA_UP1   (Float32)(1.0 - 0.95)  /* Normal update, upwards:   */
#define ALPHA_DOWN1 (Float32)(1.0 - 0.936) /* Normal update, downwards  */
#define ALPHA_UP2   (Float32)(1.0 - 0.985) /* Forced update, upwards    */
#define ALPHA_DOWN2 (Float32)(1.0 - 0.943) /* Forced update, downwards  */
#define ALPHA3      (Float32)(1.0 - 0.95)  /* Update downwards          */
#define ALPHA4      (Float32)(1.0 - 0.9)   /* For stationary estimation */
#define ALPHA5      (Float32)(1.0 - 0.5)   /* For stationary estimation */

/* Constants for VAD threshold */
#define VAD_THR_HIGH 1260 /* Highest threshold                 */
#define VAD_THR_LOW  720  /* Lowest threshold                  */
#define VAD_P1 0          /* Noise level for highest threshold */
#define VAD_P2 6300       /* Noise level for lowest threshold  */
#define VAD_SLOPE (float)(VAD_THR_LOW-VAD_THR_HIGH)/(float)(VAD_P2-VAD_P1)

/* Parameters for background spectrum recovery function */
#define STAT_COUNT 20         /* threshold of stationary detection counter         */
#define STAT_COUNT_BY_2 10    /* threshold of stationary detection counter         */
#define CAD_MIN_STAT_COUNT 5  /* threshold of stationary detection counter         */

#define STAT_THR_LEVEL 184    /* Threshold level for stationarity detection        */
#define STAT_THR 1000         /* Threshold for stationarity detection              */

/* Limits for background noise estimate */
#define NOISE_MIN 40          /* minimum */
#define NOISE_MAX 16000       /* maximum */
#define NOISE_INIT 150        /* initial */

/* Constants for VAD hangover addition */
#define HANG_NOISE_THR 100
#define BURST_LEN_HIGH_NOISE 4
#define HANG_LEN_HIGH_NOISE 7
#define BURST_LEN_LOW_NOISE 5
#define HANG_LEN_LOW_NOISE 4

/* Thresholds for signal power */
#define VAD_POW_LOW (Word32)15000/2    /* If input power is lower,                    */
/*     VAD is set to 0                         */
#define POW_PITCH_THR (Word32)343040/2 /* If input power is lower, pitch              */
/*     detection is ignored                    */

#define POW_COMPLEX_THR (Word32)15000/2/* If input power is lower, complex            */
/* flags  value for previous frame  is un-set  */
/*
* VAD Constants
*/

/* Constants for the filter bank */
#define LEVEL_SHIFT 0                     /* scaling                                  */
#define COEFF3   (Float32)13363/32768     /* coefficient for the 3rd order filter     */
#define COEFF5_1 (Float32)21955/32768     /* 1st coefficient the for 5th order filter */
#define COEFF5_2 (Float32)6390/32768      /* 2nd coefficient the for 5th order filter */

/* Constants for pitch detection */
#define LTHRESH 4
#define NTHRESH 4

/* Constants for complex signal VAD  */
#define CVAD_THRESH_ADAPT_HIGH  0.6F            /* threshold for adapt stopping high */
#define CVAD_THRESH_ADAPT_LOW  0.5F             /* threshold for adapt stopping low */
#define CVAD_THRESH_IN_NOISE  0.65F * 32768.0F  /* threshold going into speech on
a short term basis */
#define CVAD_THRESH_HANG  0.70F           /* threshold */
#define CVAD_HANG_LIMIT  (Word16)(100)    /* 2 second estimation time */
#define CVAD_HANG_LENGTH  (Word16)(250)   /* 5 second hangover */

#define CVAD_LOWPOW_RESET 0.40F  /* init in low power segment */
#define CVAD_MIN_CORR 0.40F      /* lowest adaptation value */

#define CVAD_BURST 20                        /* speech burst length for speech reset */
#define CVAD_ADAPT_SLOW 1.0F - 0.98F         /* threshold for slow adaption */
#define CVAD_ADAPT_FAST 1.0F - 0.92F         /* threshold for fast adaption */
#define CVAD_ADAPT_REALLY_FAST 1.0F - 0.80F  /* threshold for really fast adaption */

/* track table for algebraic code book search (MR475, MR515) */
__device__ static Word8 trackTable[4 * 5] =
{
	/* subframe 1; track to code; -1 do not code this position */ 0,
	1,
	0,
	1,
	-1,
	/* subframe 2 */ 0,
	-1,
	1,
	0,
	1,
	/* subframe 3 */ 0,
	1,
	0,
	-1,
	1,
	/* subframe 4 */ 0,
	1,
	-1,
	0,
	1
};
__device__ static const Float32 gamma1[M] =
{
	0.9400024414063F,
	0.8836059570313F,
	0.8305969238281F,
	0.78076171875F,
	0.7339172363281F,
	0.6898803710938F,
	0.6484985351563F,
	0.6095886230469F,
	0.5730285644531F,
	0.5386352539063F
};

/*
*  gamma1 for the 12k2 coder
*/
__device__ static const Float32 gamma1_12k2[M] =
{
	0.8999938964844F,
	0.8099975585938F,
	0.72900390625F,
	0.6560974121094F,
	0.5904846191406F,
	0.5314331054688F,
	0.478271484375F,
	0.4304504394531F,
	0.3873901367188F,
	0.3486633300781F
};
__device__ static const Float32 gamma2[M] =
{
	0.6000061035156F,
	0.3600158691406F,
	0.2160034179688F,
	0.1296081542969F,
	0.0777587890625F,
	0.04666137695313F,
	0.02798461914063F,
	0.01678466796875F,
	0.01007080078125F,
	0.00604248046875F
};

/* 1/6 resolution interpolation filter  (-3 dB at 3600 Hz)
* Note: the 1/3 resolution filter is simply a subsampled
*       version of the 1/6 resolution filter, i.e. it uses
*       every second coefficient:
*
*       inter_6(1/3)[k] = inter_6(1/3)[2*k], 0 <= k <= 3*L_INTER10
*/
__device__ static Float32 b60[UP_SAMP_MAX*(L_INTERPOL - 1) + 1] =
{
	0.898529F,
	0.865051F,
	0.769257F,
	0.624054F,
	0.448639F,
	0.265289F,
	0.0959167F,
	-0.0412598F,
	-0.134338F,
	-0.178986F,
	-0.178528F,
	-0.142609F,
	-0.0849304F,
	-0.0205078F,
	0.0369568F,
	0.0773926F,
	0.0955200F,
	0.0912781F,
	0.0689392F,
	0.0357056F,
	0.000000F,
	-0.0305481F,
	-0.0504150F,
	-0.0570068F,
	-0.0508423F,
	-0.0350037F,
	-0.0141602F,
	0.00665283F,
	0.0230713F,
	0.0323486F,
	0.0335388F,
	0.0275879F,
	0.0167847F,
	0.00411987F,
	-0.00747681F,
	-0.0156860F,
	-0.0193481F,
	-0.0183716F,
	-0.0137634F,
	-0.00704956F,
	0.000000F,
	0.00582886F,
	0.00939941F,
	0.0103760F,
	0.00903320F,
	0.00604248F,
	0.00238037F,
	-0.00109863F,
	-0.00366211F,
	-0.00497437F,
	-0.00503540F,
	-0.00402832F,
	-0.00241089F,
	-0.000579834F,
	0.00103760F,
	0.00222778F,
	0.00277710F,
	0.00271606F,
	0.00213623F,
	0.00115967F,
	0.000000F
};

/* same in fixed-point */
__device__ static const Word32 inter6[61] =
{
	29443,
	28346,
	25207,
	20449,
	14701,
	8693,
	3143,
	-1352,
	-4402,
	-5865,
	-5850,
	-4673,
	-2783,
	-672,
	1211,
	2536,
	3130,
	2991,
	2259,
	1170,
	0,
	-1001,
	-1652,
	-1868,
	-1666,
	-1147,
	-464,
	218,
	756,
	1060,
	1099,
	904,
	550,
	135,
	-245,
	-514,
	-634,
	-602,
	-451,
	-231,
	0,
	191,
	308,
	340,
	296,
	198,
	78,
	-36,
	-120,
	-163,
	-165,
	-132,
	-79,
	-19,
	34,
	73,
	91,
	89,
	70,
	38,
	0
};

__device__ static const Word16 startPos1[2] =
{
	1,
	3
};

__device__ static const Word16 startPos2[4] =
{
	0,
	1,
	2,
	4
};

__device__ static const Word16 startPos[2 * 4 * 2] =
{
	0,
	2,
	0,
	3,
	0,
	2,
	0,
	3,
	1,
	3,
	2,
	4,
	1,
	4,
	1,
	4
};

/* Scalar quantization tables of the pitch gain and the codebook gain. */
#define NB_QUA_PITCH 16

__device__ static const Float32 qua_gain_pitch[NB_QUA_PITCH] =
{
	0.0F,
	0.20001220703125F,
	0.400146484375F,
	0.5F,
	0.5999755859375F,
	0.70001220703125F,
	0.75F,
	0.79998779296875F,
	0.8499755859375F,
	0.9000244140625F,
	0.95001220703125F,
	1.0F,
	1.04998779296875F,
	1.0999755859375F,
	1.1500244140625F,
	1.20001220703125F
};

__device__ static const Float32 qua_gain_pitch_MR122[NB_QUA_PITCH] =
{
	0.0F,
	0.199951171875F,
	0.400146484375F,
	0.5F,
	0.599853515625F,
	0.699951171875F,
	0.75F,
	0.7998046875F,
	0.849853515625F,
	0.89990234375F,
	0.949951171875F,
	1.0F,
	1.0498046875F,
	1.099853515625F,
	1.14990234375F,
	1.199951171875F
};

#define NB_QUA_CODE 32
__device__ static const Float32 gain_factor[NB_QUA_CODE] =
{
	/* gain factor (g_fac) */
	0.0776367F,
	0.100586F,
	0.130859F,
	0.170410F,
	0.204590F,
	0.235352F,
	0.270508F,
	0.311035F,
	0.357910F,
	0.411133F,
	0.473145F,
	0.543945F,
	0.625488F,
	0.719238F,
	0.827148F,
	0.951172F,
	1.09424F,
	1.25830F,
	1.44678F,
	1.66406F,
	1.91357F,
	2.20068F,
	2.53076F,
	2.91016F,
	3.34717F,
	3.84912F,
	4.42627F,
	5.09033F,
	6.10840F,
	7.94092F,
	10.3232F,
	13.4204F
};






__device__ static const Word8 gray[8] =
{
	0,
	1,
	3,
	2,
	6,
	4,
	5,
	7
};

/*
* grid[0] = 1.0;
* grid[61] = -1.0;
* for (i = 1; i < 61; i++)
*    grid[i] = (Float32)cos((6.283185307*i)/(2.0*60));
*/
__device__ static const Float32 grid[61] =
{
	1.00000F,
	0.998630F,
	0.994522F,
	0.987688F,
	0.978148F,
	0.965926F,
	0.951057F,
	0.933580F,
	0.913545F,
	0.891007F,
	0.866025F,
	0.838671F,
	0.809017F,
	0.777146F,
	0.743145F,
	0.707107F,
	0.669131F,
	0.629320F,
	0.587785F,
	0.544639F,
	0.500000F,
	0.453990F,
	0.406737F,
	0.358368F,
	0.309017F,
	0.258819F,
	0.207912F,
	0.156434F,
	0.104528F,
	0.0523360F,
	4.48966e-011F,
	-0.0523360F,
	-0.104528F,
	-0.156434F,
	-0.207912F,
	-0.258819F,
	-0.309017F,
	-0.358368F,
	-0.406737F,
	-0.453990F,
	-0.500000F,
	-0.544639F,
	-0.587785F,
	-0.629320F,
	-0.669131F,
	-0.707107F,
	-0.743145F,
	-0.777146F,
	-0.809017F,
	-0.838671F,
	-0.866025F,
	-0.891007F,
	-0.913545F,
	-0.933580F,
	-0.951057F,
	-0.965926F,
	-0.978148F,
	-0.987688F,
	-0.994522F,
	-0.998630F,
	-1.00000F
};

/*
* 1/6 resolution interpolation filter  (-3 dB at 3600 Hz)
* Note: The IS641 (7.4) 1/3 resolution filter is simply a subsampled
*       version of the 1/6 resolution filter, i.e. it uses
*       every second coefficient:
*
*       b24[k](1/3) = b24[2*k](1/6), 0 <= k <= 3*L_INTER_SRCH
*/
__device__ static const Float32 b24[UP_SAMP_MAX*L_INTER_SRCH + 1] =
{
	0.900848F,
	0.864136F,
	0.760071F,
	0.605408F,
	0.424072F,
	0.242462F,
	0.0840759F,
	-0.0343933F,
	-0.105560F,
	-0.131348F,
	-0.121124F,
	-0.0884705F,
	-0.0476379F,
	-0.0102539F,
	0.0162964F,
	0.0296021F,
	0.0312195F,
	0.0251160F,
	0.0157471F,
	0.00671387F,
	0.000000F,
	-0.00399780F,
	-0.00592041F,
	-0.00656128F,
	0.000000F
};

/*
* Exponential Window coefficients used to weight the autocorrelation
* coefficients for 60 Hz bandwidth expansion of high pitched voice
* before Levinson-Durbin recursion to compute the LPC coefficients.
*
* lagwindow[i] =  exp( -0.5*(2*pi*F0*(i+1)/Fs)^2 ); i = 0,...,9
* F0 = 60 Hz, Fs = 8000 Hz
*/
__device__ static Float32 lag_wind[M] =
{
	0.99889028F,
	0.99556851F,
	0.99005681F,
	0.98239160F,
	0.97262347F,
	0.96081644F,
	0.94704735F,
	0.93140495F,
	0.91398895F,
	0.89490914F
};

/* initialization table for lsp history in DTX */
__device__ static const Float32 lsp_init_data[M] =
{
	0.9595F,
	0.8413F,
	0.6549F,
	0.4154F,
	0.1423F,
	-0.1423F,
	-0.4154F,
	-0.6549F,
	-0.8413F,
	-0.9595F
};

#define PAST_RQ_INIT_SIZE 8

/* initalization table for MA predictor in dtx mode */
__device__ static const Float32 past_rq_init[80] =
{
	-62.9883F, -77.6367F, -107.178F, -154.785F, -160.156F, -188.721F, -173.584F, -122.559F,
	-65.4297F, -47.1191F, -0.488281F, 30.5176F, 29.7852F, -9.52148F, -2.19727F, 25.6348F,
	31.4941F, 69.0918F, 90.8203F, 140.381F, -67.627F, -79.1016F, -48.0957F, -118.896F,
	-108.643F, -88.3789F, -71.2891F, -6.5918F, 43.2129F, 132.568F, 83.4961F, 126.221F,
	125.977F, 31.7383F, 6.5918F, -25.3906F, -29.2969F, -34.1797F, -18.0664F, -13.6719F,
	-137.695F, -230.225F, -371.094F, -235.596F, -198.73F, -128.418F, -78.6133F, -0.488281F,
	38.8184F, 160.4F, -76.1719F, -69.3359F, -94.2383F, -145.752F, -120.361F, -128.418F,
	-102.051F, -55.9082F, 25.6348F, 109.619F, -135.986F, -212.402F, -262.451F, -224.365F,
	-231.934F, -183.594F, -173.096F, -77.1484F, 15.1367F, 118.652F, -76.6602F, -46.6309F,
	-49.5605F, -80.5664F, -39.0625F, -25.1465F, -12.4512F, 31.9824F, 82.5195F, 125.732F
};

/* LSF means ->normalize frequency domain */

__device__ static const Float32 mean_lsf_3[10] =
{
	377.441F,
	554.688F,
	922.363F,
	1339.84F,
	1702.15F,
	2046.39F,
	2452.88F,
	2741.46F,
	3116.70F,
	3348.14F,
};

__device__ static const Float32 mean_lsf_5[10] =
{
	337.891F,
	507.080F,
	834.961F,
	1247.07F,
	1646.00F,
	1982.91F,
	2407.96F,
	2708.01F,
	3104.00F,
	3344.97F,
};

/* LSF prediction factors (not in MR122) */
__device__ static const Float32 pred_fac[10] =
{
	0.291626F,
	0.328644F,
	0.383636F,
	0.405640F,
	0.438873F,
	0.355560F,
	0.323120F,
	0.298065F,
	0.262238F,
	0.197876F
};

/* codebooks from IS641 */
#define DICO1_SIZE_3  256
#define DICO2_SIZE_3  512
#define DICO3_SIZE_3  512
__device__ static const Float32 dico1_lsf_3[] =
{
	1.46484F,
	20.0195F,
	-31.9824F,
	37.5977F,
	-13.6719F,
	-179.443F,
	44.6777F,
	-15.8691F,
	-64.6973F,
	2.19727F,
	-51.2695F,
	-88.1348F,
	27.5879F,
	175.293F,
	443.604F,
	246.582F,
	296.387F,
	384.033F,
	209.229F,
	325.439F,
	555.664F,
	201.904F,
	382.813F,
	471.924F,
	175.049F,
	485.596F,
	538.574F,
	204.590F,
	286.133F,
	445.068F,
	176.025F,
	244.141F,
	525.879F,
	69.8242F,
	116.211F,
	368.408F,
	-60.3027F,
	-129.639F,
	56.1523F,
	35.8887F,
	-20.0195F,
	138.916F,
	6.34766F,
	-43.2129F,
	-230.469F,
	-6.59180F,
	-66.6504F,
	168.945F,
	-40.0391F,
	-64.4531F,
	-44.6777F,
	54.6875F,
	192.871F,
	253.662F,
	219.482F,
	230.957F,
	146.729F,
	118.408F,
	188.232F,
	280.762F,
	127.930F,
	165.283F,
	220.459F,
	-34.1797F,
	91.5527F,
	189.941F,
	100.098F,
	165.039F,
	104.736F,
	73.4863F,
	129.395F,
	246.338F,
	175.537F,
	157.715F,
	9.27734F,
	55.1758F,
	89.5996F,
	9.76563F,
	35.4004F,
	-10.9863F,
	-123.291F,
	70.8008F,
	29.5410F,
	-29.5410F,
	73.7305F,
	31.0059F,
	40.5273F,
	-30.2734F,
	-93.5059F,
	-233.398F,
	-87.4023F,
	-111.084F,
	-238.525F,
	174.561F,
	214.355F,
	218.262F,
	238.770F,
	225.342F,
	51.5137F,
	116.455F,
	66.4063F,
	15.6250F,
	45.8984F,
	-19.0430F,
	4.15039F,
	-34.9121F,
	-15.8691F,
	9.27734F,
	156.982F,
	143.066F,
	151.611F,
	-32.7148F,
	-104.004F,
	-158.936F,
	84.7168F,
	133.057F,
	688.477F,
	290.039F,
	665.527F,
	596.191F,
	34.6680F,
	-19.5313F,
	423.584F,
	69.0918F,
	31.7383F,
	112.549F,
	-63.9648F,
	-97.4121F,
	-279.541F,
	-100.342F,
	37.8418F,
	104.980F,
	80.3223F,
	91.5527F,
	190.186F,
	12.9395F,
	-55.1758F,
	-33.9355F,
	-31.4941F,
	-57.6172F,
	410.645F,
	69.5801F,
	181.641F,
	323.975F,
	180.176F,
	170.166F,
	406.250F,
	76.1719F,
	99.8535F,
	64.9414F,
	79.3457F,
	175.781F,
	32.9590F,
	0.244141F,
	53.9551F,
	110.596F,
	1.95313F,
	49.5605F,
	35.4004F,
	72.9980F,
	156.250F,
	185.547F,
	7.08008F,
	114.258F,
	155.762F,
	25.1465F,
	104.736F,
	92.5293F,
	102.539F,
	232.910F,
	227.539F,
	323.730F,
	295.410F,
	307.129F,
	171.875F,
	247.070F,
	281.250F,
	-40.5273F,
	-108.398F,
	-64.9414F,
	-77.1484F,
	-31.7383F,
	-91.7969F,
	46.6309F,
	281.006F,
	464.844F,
	-58.5938F,
	-132.568F,
	-307.617F,
	-27.3438F,
	65.4297F,
	294.678F,
	17.0898F,
	259.277F,
	386.475F,
	67.8711F,
	332.031F,
	384.277F,
	-62.9883F,
	-66.4063F,
	-187.500F,
	4.63867F,
	137.451F,
	546.875F,
	-0.732422F,
	-64.6973F,
	32.9590F,
	-72.0215F,
	-144.287F,
	-94.7266F,
	34.1797F,
	86.4258F,
	-50.2930F,
	-63.4766F,
	-123.047F,
	-194.092F,
	-105.713F,
	-175.293F,
	-322.021F,
	26.6113F,
	80.8105F,
	234.863F,
	-104.736F,
	-21.2402F,
	159.180F,
	-72.2656F,
	104.004F,
	248.779F,
	-58.3496F,
	189.209F,
	207.764F,
	119.385F,
	325.684F,
	261.963F,
	-81.5430F,
	-81.0547F,
	6.10352F,
	132.568F,
	294.434F,
	441.162F,
	79.5898F,
	14.8926F,
	177.490F,
	141.113F,
	207.275F,
	343.018F,
	-50.7813F,
	-67.6270F,
	80.3223F,
	-37.1094F,
	15.6250F,
	163.330F,
	-105.957F,
	-165.527F,
	-177.490F,
	-110.840F,
	-17.3340F,
	61.2793F,
	147.705F,
	117.188F,
	62.0117F,
	-117.676F,
	2.68555F,
	243.164F,
	-70.5566F,
	96.4355F,
	118.652F,
	176.270F,
	256.104F,
	351.563F,
	-7.32422F,
	-77.1484F,
	-191.895F,
	-25.8789F,
	-28.0762F,
	-151.123F,
	210.205F,
	359.863F,
	344.727F,
	257.568F,
	333.496F,
	289.063F,
	198.242F,
	302.002F,
	225.830F,
	10.2539F,
	-61.2793F,
	-140.625F,
	83.4961F,
	34.4238F,
	-110.840F,
	-41.0156F,
	-19.5313F,
	331.787F,
	-83.4961F,
	-160.156F,
	-430.420F,
	24.4141F,
	200.439F,
	177.002F,
	241.699F,
	182.373F,
	195.313F,
	81.0547F,
	107.422F,
	138.672F,
	161.865F,
	92.5293F,
	208.008F,
	27.3438F,
	40.2832F,
	-90.0879F,
	145.752F,
	222.168F,
	68.8477F,
	-1.95313F,
	203.613F,
	312.744F,
	-85.9375F,
	139.648F,
	169.678F,
	112.793F,
	548.340F,
	440.918F,
	84.2285F,
	46.3867F,
	335.449F,
	101.563F,
	223.389F,
	528.809F,
	41.0156F,
	-20.0195F,
	68.3594F,
	-125.977F,
	-108.887F,
	205.078F,
	11.4746F,
	130.127F,
	10.7422F,
	-88.3789F,
	-173.584F,
	-279.053F,
	5.37109F,
	47.1191F,
	359.375F,
	-20.7520F,
	56.8848F,
	442.627F,
	-15.1367F,
	141.357F,
	367.188F,
	134.277F,
	230.469F,
	427.002F,
	176.514F,
	158.691F,
	280.273F,
	237.305F,
	215.820F,
	340.576F,
	-103.760F,
	156.982F,
	0.000000F,
	244.141F,
	232.422F,
	268.066F,
	60.7910F,
	353.027F,
	164.063F,
	-81.5430F,
	-21.2402F,
	530.273F,
	-135.254F,
	459.473F,
	652.344F,
	34.1797F,
	445.801F,
	452.393F,
	224.609F,
	427.002F,
	632.324F,
	262.695F,
	471.924F,
	497.559F,
	-33.4473F,
	-108.154F,
	-379.639F,
	309.814F,
	286.621F,
	114.258F,
	-120.361F,
	-29.7852F,
	371.338F,
	-110.107F,
	252.197F,
	296.387F,
	117.676F,
	413.818F,
	272.949F,
	198.975F,
	158.447F,
	93.7500F,
	-108.887F,
	-168.945F,
	26.1230F,
	-77.8809F,
	-147.705F,
	-28.8086F,
	-50.5371F,
	-123.291F,
	128.174F,
	-114.258F,
	-2.92969F,
	667.969F,
	18.3105F,
	472.168F,
	318.604F,
	214.844F,
	575.684F,
	553.467F,
	313.721F,
	384.521F,
	489.258F,
	-11.7188F,
	-74.2188F,
	-289.551F,
	-106.201F,
	-112.549F,
	-61.2793F,
	-89.3555F,
	-98.6328F,
	-133.545F,
	-70.5566F,
	-147.705F,
	-145.752F,
	-131.348F,
	-197.754F,
	-40.2832F,
	-29.2969F,
	0.732422F,
	86.9141F,
	156.006F,
	302.979F,
	366.699F,
	23.4375F,
	43.2129F,
	183.105F,
	-106.201F,
	-142.822F,
	-286.621F,
	-86.9141F,
	26.6113F,
	-19.2871F,
	-118.408F,
	70.3125F,
	489.502F,
	2.19727F,
	272.461F,
	178.467F,
	214.844F,
	520.996F,
	230.957F,
	-64.6973F,
	386.963F,
	260.010F,
	282.471F,
	295.410F,
	205.811F,
	-121.582F,
	-163.086F,
	105.225F,
	91.3086F,
	78.3691F,
	-55.9082F,
	351.563F,
	512.939F,
	337.158F,
	109.619F,
	112.549F,
	281.982F,
	-25.6348F,
	9.52148F,
	-93.7500F,
	-64.2090F,
	89.5996F,
	44.4336F,
	-90.5762F,
	-161.133F,
	188.721F,
	-45.8984F,
	281.006F,
	237.061F,
	325.439F,
	398.438F,
	350.342F,
	188.965F,
	309.326F,
	298.096F,
	-117.676F,
	-203.125F,
	-363.525F,
	-57.8613F,
	-51.2695F,
	209.961F,
	217.285F,
	394.287F,
	259.766F,
	115.234F,
	259.277F,
	291.016F,
	45.1660F,
	262.939F,
	241.455F,
	-138.672F,
	-242.188F,
	-416.016F,
	-109.619F,
	-220.215F,
	-498.779F,
	-34.6680F,
	-92.0410F,
	-111.816F,
	-51.2695F,
	-135.254F,
	-251.221F,
	-2.68555F,
	276.611F,
	552.979F,
	-80.3223F,
	-164.795F,
	-218.018F,
	-61.0352F,
	160.400F,
	289.795F,
	126.709F,
	368.652F,
	434.326F,
	126.953F,
	131.592F,
	342.529F,
	128.662F,
	346.924F,
	317.871F,
	-137.451F,
	-212.646F,
	-304.688F,
	-35.8887F,
	-113.037F,
	214.600F,
	-18.5547F,
	569.824F,
	693.359F,
	137.451F,
	628.174F,
	582.275F,
	154.297F,
	470.215F,
	712.891F,
	175.537F,
	493.896F,
	449.219F,
	-133.057F,
	-176.514F,
	270.508F,
	31.4941F,
	-30.5176F,
	215.820F,
	345.947F,
	398.438F,
	225.830F,
	-22.9492F,
	382.324F,
	427.490F,
	-83.2520F,
	374.268F,
	378.662F,
	144.287F,
	96.4355F,
	-66.8945F,
	-18.5547F,
	239.502F,
	691.162F,
	37.3535F,
	728.760F,
	450.195F,
	251.953F,
	626.221F,
	671.143F,
	368.164F,
	691.406F,
	458.740F,
	193.115F,
	292.725F,
	131.348F,
	-46.3867F,
	-110.596F,
	363.525F,
	-67.8711F,
	-133.789F,
	282.715F,
	-59.8145F,
	473.877F,
	499.023F,
	250.000F,
	380.859F,
	402.832F,
	125.000F,
	61.7676F,
	113.770F,
	-15.1367F,
	-78.8574F,
	281.006F,
	-115.479F,
	-91.7969F,
	123.779F,
	-105.713F,
	336.914F,
	527.832F,
	219.482F,
	474.365F,
	352.783F,
	32.7148F,
	171.875F,
	107.422F,
	112.305F,
	128.174F,
	-6.83594F,
	-109.863F,
	68.1152F,
	326.660F,
	0.000000F,
	237.061F,
	61.5234F,
	-108.643F,
	-153.076F,
	-241.943F,
	-84.9609F,
	-146.973F,
	-347.656F,
	97.1680F,
	173.828F,
	404.297F,
	-26.1230F,
	76.6602F,
	-43.4570F,
	22.7051F,
	543.457F,
	546.387F,
	126.465F,
	207.275F,
	160.156F,
	-112.793F,
	-173.584F,
	-109.131F,
	42.4805F,
	-8.30078F,
	290.771F,
	-29.0527F,
	10.2539F,
	245.361F,
	-90.8203F,
	66.8945F,
	185.059F,
	252.930F,
	574.219F,
	448.730F,
	164.795F,
	420.898F,
	365.723F,
	104.980F,
	313.965F,
	520.752F,
	-31.4941F,
	-107.178F,
	0.000000F,
	-91.0645F,
	195.313F,
	523.438F,
	1.46484F,
	387.451F,
	604.980F,
	116.699F,
	145.508F,
	519.531F,
	-104.492F,
	-179.688F,
	367.432F,
	93.9941F,
	43.4570F,
	239.258F,
	33.9355F,
	109.619F,
	299.072F,
	-128.418F,
	-205.566F,
	-239.746F,
	35.4004F,
	379.395F,
	303.223F,
	152.100F,
	353.516F,
	160.156F,
	85.2051F,
	248.047F,
	361.816F,
	7.56836F,
	-68.3594F,
	101.318F,
	-77.1484F,
	176.758F,
	400.635F,
	87.8906F,
	258.301F,
	135.742F,
	-106.445F,
	-87.4023F,
	293.213F,
	-86.6699F,
	274.170F,
	473.389F,
	97.9004F,
	386.719F,
	548.828F,
	-128.662F,
	-247.070F,
	86.6699F,
	56.8848F,
	58.1055F,
	545.166F,
	-134.277F,
	-218.994F,
	-156.006F,
	-89.1113F,
	-122.314F,
	477.783F,
	94.9707F,
	454.102F,
	395.752F,
	39.5508F,
	276.367F,
	308.594F,
	-57.8613F,
	286.621F,
	339.355F,
	-156.250F,
	-100.342F,
	28.3203F,
	-55.6641F,
	413.574F,
	561.035F,
	400.146F,
	533.691F,
	553.467F,
	137.207F,
	310.791F,
	648.926F,
	78.8574F,
	82.5195F,
	433.105F,
	141.113F,
	270.264F,
	208.008F,
	5.37109F,
	145.020F,
	228.027F,
	-34.9121F,
	175.293F,
	108.887F

};
__device__ static const Float32 dico2_lsf_3[] =
{
	12.2070F,
	17.3340F,
	-2.19727F,
	-82.5195F,
	-170.410F,
	-343.506F,
	24.9023F,
	-33.6914F,
	-200.195F,
	-75.6836F,
	-114.502F,
	-280.029F,
	101.074F,
	16.3574F,
	-65.1855F,
	258.789F,
	198.730F,
	351.807F,
	377.930F,
	332.031F,
	310.547F,
	428.223F,
	462.646F,
	405.518F,
	492.920F,
	520.752F,
	444.336F,
	441.406F,
	565.918F,
	450.439F,
	157.227F,
	-22.7051F,
	110.840F,
	209.473F,
	80.3223F,
	-33.2031F,
	119.385F,
	-62.9883F,
	-31.2500F,
	-48.3398F,
	-181.885F,
	-10.0098F,
	-12.6953F,
	-64.6973F,
	-240.479F,
	84.4727F,
	33.4473F,
	116.943F,
	-425.049F,
	-182.617F,
	-166.992F,
	-283.936F,
	-421.143F,
	-89.5996F,
	-218.506F,
	-279.541F,
	-191.406F,
	-119.141F,
	-230.957F,
	-236.328F,
	-20.7520F,
	-95.2148F,
	-177.002F,
	52.4902F,
	-83.0078F,
	-41.7480F,
	249.023F,
	223.633F,
	480.713F,
	137.695F,
	43.7012F,
	182.129F,
	161.621F,
	238.525F,
	423.340F,
	216.553F,
	151.855F,
	223.145F,
	229.248F,
	208.984F,
	284.424F,
	75.4395F,
	167.969F,
	196.045F,
	223.877F,
	39.3066F,
	139.160F,
	28.8086F,
	-4.88281F,
	-69.0918F,
	-199.219F,
	-10.2539F,
	49.8047F,
	-299.805F,
	-79.3457F,
	-112.793F,
	-235.107F,
	-49.3164F,
	-34.9121F,
	-241.211F,
	-118.164F,
	-88.1348F,
	-171.387F,
	-238.770F,
	-116.455F,
	-73.7305F,
	-192.871F,
	-290.039F,
	-24.4141F,
	-191.895F,
	-265.625F,
	-257.324F,
	-231.201F,
	-411.133F,
	-49.3164F,
	-205.811F,
	-190.918F,
	-253.662F,
	-336.426F,
	-219.971F,
	-152.344F,
	-26.8555F,
	-20.7520F,
	86.9141F,
	52.0020F,
	-2.44141F,
	-120.361F,
	88.8672F,
	188.965F,
	103.760F,
	200.684F,
	116.943F,
	-20.2637F,
	135.986F,
	126.953F,
	-242.188F,
	-380.859F,
	-139.648F,
	-147.217F,
	-180.908F,
	-6.34766F,
	-122.559F,
	-155.762F,
	-220.459F,
	51.0254F,
	74.7070F,
	35.8887F,
	-77.1484F,
	-144.775F,
	-145.508F,
	-20.7520F,
	-51.5137F,
	-54.9316F,
	-224.121F,
	-129.150F,
	28.5645F,
	56.8848F,
	-107.178F,
	-180.176F,
	268.799F,
	183.350F,
	154.541F,
	355.713F,
	418.945F,
	368.896F,
	430.908F,
	355.713F,
	222.168F,
	273.926F,
	282.227F,
	207.275F,
	330.566F,
	211.914F,
	114.746F,
	-212.646F,
	-280.762F,
	-438.477F,
	-212.646F,
	-210.205F,
	-242.188F,
	-28.8086F,
	37.8418F,
	51.7578F,
	-256.592F,
	-207.275F,
	-147.949F,
	-272.705F,
	-451.416F,
	-671.387F,
	-248.779F,
	-348.389F,
	-456.299F,
	90.3320F,
	-44.9219F,
	-101.074F,
	234.131F,
	120.361F,
	25.3906F,
	233.887F,
	253.662F,
	132.568F,
	37.5977F,
	159.424F,
	49.0723F,
	304.932F,
	123.779F,
	36.6211F,
	161.865F,
	122.803F,
	56.1523F,
	152.100F,
	189.697F,
	164.795F,
	160.889F,
	21.4844F,
	-26.8555F,
	205.811F,
	59.5703F,
	54.6875F,
	93.2617F,
	132.080F,
	73.7305F,
	176.758F,
	105.713F,
	162.598F,
	284.668F,
	179.199F,
	83.2520F,
	-33.6914F,
	4.88281F,
	-96.9238F,
	-288.818F,
	-103.516F,
	-11.2305F,
	-78.3691F,
	-85.9375F,
	-30.2734F,
	325.439F,
	249.268F,
	263.672F,
	63.9648F,
	89.3555F,
	176.514F,
	225.098F,
	69.0918F,
	-134.521F,
	7.56836F,
	-155.273F,
	-149.170F,
	-168.213F,
	-170.166F,
	-101.318F,
	-232.422F,
	-190.186F,
	-49.0723F,
	-324.463F,
	-145.996F,
	-87.6465F,
	-232.666F,
	-313.721F,
	40.5273F,
	120.361F,
	74.4629F,
	53.9551F,
	206.543F,
	171.631F,
	148.926F,
	205.078F,
	228.516F,
	188.965F,
	-176.514F,
	-323.242F,
	-307.861F,
	-87.1582F,
	-250.244F,
	-338.867F,
	-267.578F,
	-335.938F,
	-89.1113F,
	-345.703F,
	-459.229F,
	-148.438F,
	-438.965F,
	-421.631F,
	-164.551F,
	-133.057F,
	-286.377F,
	-171.631F,
	165.527F,
	191.895F,
	36.1328F,
	-30.0293F,
	169.922F,
	314.453F,
	157.227F,
	85.4492F,
	-2.44141F,
	101.074F,
	149.902F,
	3.66211F,
	33.4473F,
	83.9844F,
	-51.5137F,
	-198.730F,
	-369.141F,
	-199.951F,
	-95.4590F,
	-227.051F,
	-143.555F,
	11.4746F,
	-144.287F,
	-219.238F,
	-221.924F,
	-267.822F,
	-39.7949F,
	-310.547F,
	-284.912F,
	-38.3301F,
	-357.422F,
	-372.314F,
	-94.9707F,
	-311.035F,
	-290.039F,
	-152.344F,
	163.818F,
	52.0020F,
	110.840F,
	30.2734F,
	-66.8945F,
	-128.174F,
	-177.979F,
	-121.094F,
	-37.1094F,
	-328.125F,
	29.7852F,
	32.9590F,
	-709.229F,
	-143.799F,
	-96.1914F,
	-421.875F,
	107.666F,
	-12.2070F,
	360.352F,
	220.703F,
	192.139F,
	77.1484F,
	57.6172F,
	-107.422F,
	-84.7168F,
	52.9785F,
	100.830F,
	-222.412F,
	-223.877F,
	29.5410F,
	-111.084F,
	-227.539F,
	49.3164F,
	-22.4609F,
	-113.525F,
	-91.5527F,
	119.141F,
	95.2148F,
	115.723F,
	213.867F,
	177.979F,
	77.1484F,
	-443.115F,
	-320.313F,
	-163.330F,
	21.2402F,
	234.863F,
	105.469F,
	137.451F,
	-60.7910F,
	-258.301F,
	61.0352F,
	69.5801F,
	269.775F,
	278.564F,
	104.248F,
	169.922F,
	-253.418F,
	-406.250F,
	-386.230F,
	-231.445F,
	84.4727F,
	39.0625F,
	-75.4395F,
	-66.4063F,
	-209.473F,
	163.574F,
	152.344F,
	305.176F,
	-230.469F,
	-99.6094F,
	-162.598F,
	-147.949F,
	-78.1250F,
	-93.7500F,
	-120.117F,
	56.1523F,
	15.8691F,
	81.5430F,
	-12.2070F,
	-3.90625F,
	-3.90625F,
	-168.457F,
	-341.064F,
	437.256F,
	418.945F,
	341.553F,
	604.980F,
	503.662F,
	342.773F,
	303.955F,
	359.131F,
	348.145F,
	-93.2617F,
	-253.174F,
	-0.488281F,
	42.2363F,
	-97.1680F,
	279.541F,
	364.014F,
	494.141F,
	439.697F,
	188.477F,
	311.035F,
	367.676F,
	348.877F,
	423.584F,
	488.525F,
	263.428F,
	297.363F,
	310.791F,
	-281.738F,
	-451.904F,
	-324.463F,
	-197.266F,
	-276.611F,
	-267.578F,
	-110.107F,
	-252.197F,
	-420.410F,
	15.8691F,
	141.113F,
	-20.5078F,
	-360.352F,
	-594.238F,
	-434.082F,
	-186.768F,
	-333.496F,
	-120.605F,
	-53.2227F,
	-145.020F,
	-227.295F,
	82.2754F,
	-57.6172F,
	137.207F,
	575.439F,
	649.902F,
	473.145F,
	363.525F,
	311.523F,
	213.379F,
	46.1426F,
	87.4023F,
	91.3086F,
	-370.850F,
	-556.885F,
	-572.754F,
	-236.084F,
	-310.303F,
	-511.475F,
	-153.320F,
	-290.039F,
	-376.465F,
	405.518F,
	254.639F,
	133.301F,
	137.939F,
	259.033F,
	178.711F,
	-15.6250F,
	-204.102F,
	-105.957F,
	-106.445F,
	-23.4375F,
	49.5605F,
	263.184F,
	296.875F,
	399.414F,
	221.436F,
	374.512F,
	240.723F,
	79.5898F,
	235.596F,
	206.299F,
	34.6680F,
	-20.5078F,
	48.0957F,
	114.746F,
	580.811F,
	383.301F,
	276.611F,
	114.746F,
	296.387F,
	96.4355F,
	335.938F,
	292.969F,
	274.658F,
	254.395F,
	84.9609F,
	-132.568F,
	-301.270F,
	-91.7969F,
	-52.4902F,
	-44.1895F,
	117.432F,
	-475.342F,
	-395.752F,
	-51.2695F,
	-183.105F,
	-289.307F,
	95.2148F,
	7.08008F,
	-97.4121F,
	6.59180F,
	200.195F,
	301.758F,
	184.326F,
	169.678F,
	239.014F,
	99.8535F,
	-42.4805F,
	292.236F,
	252.686F,
	222.656F,
	331.055F,
	450.684F,
	-242.188F,
	-350.830F,
	118.164F,
	-362.549F,
	-415.039F,
	50.7813F,
	-100.586F,
	293.945F,
	349.609F,
	-66.1621F,
	218.750F,
	279.297F,
	-101.563F,
	433.838F,
	350.098F,
	-414.063F,
	-645.508F,
	-49.8047F,
	-436.768F,
	-378.662F,
	252.197F,
	-404.297F,
	-380.615F,
	318.115F,
	-305.908F,
	-387.939F,
	263.916F,
	-163.330F,
	-267.334F,
	-16.1133F,
	-166.504F,
	78.1250F,
	-84.2285F,
	160.889F,
	74.4629F,
	260.986F,
	-315.430F,
	-196.289F,
	-4.63867F,
	-399.170F,
	-315.186F,
	7.08008F,
	-410.889F,
	-121.338F,
	17.3340F,
	-70.0684F,
	-1.70898F,
	-24.4141F,
	-120.605F,
	-234.863F,
	-57.8613F,
	208.008F,
	459.229F,
	424.805F,
	-297.119F,
	-338.623F,
	55.4199F,
	-161.133F,
	73.7305F,
	91.0645F,
	23.4375F,
	265.381F,
	306.885F,
	-262.207F,
	-407.471F,
	39.0625F,
	118.408F,
	506.836F,
	438.965F,
	-228.027F,
	-53.7109F,
	134.766F,
	-145.508F,
	-149.414F,
	57.8613F,
	82.0313F,
	419.922F,
	214.600F,
	156.982F,
	153.564F,
	105.957F,
	309.326F,
	127.441F,
	398.682F,
	3.66211F,
	59.5703F,
	-107.666F,
	360.107F,
	175.049F,
	44.9219F,
	444.092F,
	388.184F,
	417.236F,
	241.211F,
	63.7207F,
	228.760F,
	510.986F,
	572.510F,
	371.094F,
	522.217F,
	453.613F,
	392.090F,
	-140.869F,
	-141.357F,
	-293.701F,
	-233.398F,
	32.9590F,
	-119.141F,
	-113.281F,
	12.4512F,
	-82.5195F,
	-153.564F,
	-84.9609F,
	-176.514F,
	279.785F,
	506.104F,
	352.051F,
	535.156F,
	357.910F,
	222.412F,
	-352.539F,
	-383.789F,
	-556.152F,
	341.797F,
	173.340F,
	316.650F,
	325.928F,
	154.541F,
	226.563F,
	350.098F,
	535.645F,
	633.301F,
	591.309F,
	538.086F,
	459.229F,
	239.746F,
	547.363F,
	452.637F,
	92.7734F,
	193.359F,
	279.541F,
	-15.3809F,
	-131.592F,
	101.074F,
	-61.5234F,
	-235.352F,
	-76.6602F,
	-307.861F,
	-166.748F,
	-190.430F,
	-202.881F,
	-128.418F,
	-245.361F,
	-406.738F,
	-277.100F,
	-103.516F,
	-393.311F,
	-110.352F,
	-72.9980F,
	309.570F,
	255.859F,
	156.738F,
	280.029F,
	208.252F,
	208.984F,
	-164.795F,
	-82.0313F,
	33.9355F,
	553.711F,
	327.881F,
	346.191F,
	7.08008F,
	187.500F,
	194.580F,
	-298.828F,
	103.271F,
	137.695F,
	-321.777F,
	-264.160F,
	59.8145F,
	-317.871F,
	-198.242F,
	139.893F,
	-316.895F,
	-394.775F,
	157.715F,
	-236.328F,
	203.613F,
	176.514F,
	242.432F,
	403.320F,
	494.873F,
	-46.6309F,
	-199.463F,
	105.469F,
	161.621F,
	14.6484F,
	48.3398F,
	152.832F,
	243.408F,
	324.707F,
	402.344F,
	479.248F,
	314.697F,
	-389.893F,
	-22.7051F,
	-10.9863F,
	-265.625F,
	9.03320F,
	-20.5078F,
	403.564F,
	636.475F,
	570.557F,
	260.010F,
	498.047F,
	580.322F,
	278.076F,
	567.871F,
	517.090F,
	209.717F,
	87.1582F,
	368.652F,
	162.109F,
	299.561F,
	268.311F,
	116.943F,
	332.031F,
	222.656F,
	463.135F,
	428.223F,
	492.920F,
	285.156F,
	466.064F,
	435.547F,
	97.4121F,
	8.30078F,
	62.5000F,
	-144.775F,
	-74.2188F,
	-257.080F,
	133.545F,
	413.574F,
	343.506F,
	157.959F,
	-24.1699F,
	-83.2520F,
	364.258F,
	402.100F,
	290.527F,
	9.27734F,
	-157.227F,
	-51.7578F,
	96.4355F,
	206.543F,
	54.1992F,
	-171.875F,
	-186.768F,
	-174.805F,
	-176.758F,
	-479.492F,
	-684.570F,
	-36.6211F,
	71.0449F,
	-20.0195F,
	301.025F,
	356.201F,
	245.850F,
	-34.1797F,
	-37.8418F,
	37.3535F,
	107.178F,
	72.5098F,
	382.813F,
	-373.291F,
	-100.098F,
	-155.273F,
	375.000F,
	111.084F,
	-57.8613F,
	-324.219F,
	-33.9355F,
	-63.4766F,
	129.639F,
	135.254F,
	211.914F,
	65.6738F,
	308.594F,
	147.949F,
	-56.8848F,
	215.576F,
	113.037F,
	181.152F,
	146.484F,
	-29.2969F,
	-17.8223F,
	102.783F,
	51.7578F,
	-107.178F,
	-14.1602F,
	196.289F,
	-313.965F,
	-302.979F,
	177.734F,
	71.7773F,
	-119.629F,
	12.2070F,
	-144.287F,
	-220.947F,
	-306.152F,
	10.2539F,
	-167.725F,
	35.8887F,
	-6.10352F,
	66.6504F,
	145.508F,
	-75.9277F,
	296.143F,
	146.729F,
	-184.082F,
	207.275F,
	142.578F,
	104.736F,
	148.193F,
	143.311F,
	-146.973F,
	-40.5273F,
	112.549F,
	-194.336F,
	-200.928F,
	189.697F,
	336.914F,
	222.168F,
	428.467F,
	29.0527F,
	345.947F,
	237.305F,
	-53.4668F,
	-214.844F,
	-389.648F,
	-256.104F,
	-246.582F,
	106.934F,
	-174.072F,
	-336.670F,
	19.0430F,
	0.000000F,
	-109.131F,
	-287.842F,
	-277.344F,
	-322.021F,
	-384.033F,
	548.828F,
	431.396F,
	319.580F,
	230.957F,
	386.475F,
	349.609F,
	280.762F,
	117.676F,
	106.445F,
	-114.502F,
	-270.508F,
	150.879F,
	-109.131F,
	-235.840F,
	265.625F,
	-305.664F,
	-369.873F,
	-27.8320F,
	-269.531F,
	-490.234F,
	-141.357F,
	51.2695F,
	149.658F,
	121.338F,
	-482.178F,
	-350.830F,
	156.738F,
	-309.814F,
	-208.984F,
	246.826F,
	-401.855F,
	-289.307F,
	259.521F,
	-379.639F,
	-164.063F,
	293.945F,
	-413.086F,
	-271.973F,
	152.100F,
	-239.014F,
	-323.730F,
	-311.768F,
	131.592F,
	-35.8887F,
	218.262F,
	-330.566F,
	-218.994F,
	-105.957F,
	216.797F,
	115.967F,
	104.492F,
	37.3535F,
	-93.7500F,
	82.5195F,
	-364.258F,
	-124.756F,
	87.6465F,
	-237.793F,
	-272.217F,
	-114.746F,
	25.6348F,
	-134.277F,
	165.283F,
	-228.760F,
	-279.541F,
	214.111F,
	92.7734F,
	-63.4766F,
	51.2695F,
	411.377F,
	225.586F,
	306.641F,
	433.350F,
	290.527F,
	267.334F,
	346.436F,
	154.053F,
	130.127F,
	153.076F,
	72.9980F,
	-84.7168F,
	-100.342F,
	-130.371F,
	157.959F,
	-158.691F,
	7.08008F,
	-145.264F,
	-92.2852F,
	-333.740F,
	381.592F,
	342.285F,
	273.682F,
	357.666F,
	265.869F,
	344.238F,
	158.203F,
	-511.719F,
	-266.113F,
	-1.46484F,
	75.9277F,
	-47.3633F,
	-212.158F,
	-156.006F,
	-202.881F,
	101.563F,
	-283.691F,
	-298.828F,
	329.346F,
	-304.443F,
	-229.736F,
	442.627F,
	-535.400F,
	-485.107F,
	110.596F,
	-151.123F,
	-333.740F,
	-233.398F,
	-392.090F,
	-481.445F,
	-367.920F,
	-286.865F,
	-258.057F,
	-269.531F,
	-92.0410F,
	146.729F,
	49.0723F,
	458.008F,
	201.416F,
	91.3086F,
	-104.980F,
	-322.998F,
	7.08008F,
	-341.064F,
	-304.932F,
	-324.951F,
	-245.850F,
	-367.188F,
	234.375F,
	-342.041F,
	-490.479F,
	48.0957F,
	-336.670F,
	-475.830F,
	-57.6172F,
	-262.939F,
	30.0293F,
	103.027F,
	150.146F,
	309.814F,
	133.301F,
	-74.7070F,
	372.559F,
	220.703F,
	291.504F,
	436.523F,
	287.354F,
	-152.832F,
	-215.820F,
	-372.559F,
	48.5840F,
	187.012F,
	367.188F,
	-260.010F,
	210.449F,
	48.0957F,
	-252.441F,
	-432.861F,
	-216.553F,
	-195.313F,
	35.4004F,
	146.240F,
	-276.855F,
	-126.709F,
	152.832F,
	-294.189F,
	-470.215F,
	122.070F,
	-222.168F,
	-254.150F,
	-340.576F,
	-360.352F,
	-382.568F,
	-236.572F,
	-127.686F,
	205.566F,
	8.30078F,
	437.988F,
	157.715F,
	210.449F,
	-294.678F,
	-460.938F,
	-244.629F,
	-19.0430F,
	-2.19727F,
	-164.063F,
	254.883F,
	185.303F,
	19.5313F,
	-146.484F,
	278.076F,
	248.779F,
	13.9160F,
	488.281F,
	347.168F,
	-203.369F,
	345.215F,
	273.682F,
	-293.457F,
	397.949F,
	307.617F,
	-112.549F,
	346.680F,
	303.711F,
	375.244F,
	238.037F,
	61.7676F,
	-69.0918F,
	79.1016F,
	-87.6465F,
	146.240F,
	-47.6074F,
	25.8789F,
	143.555F,
	15.1367F,
	-143.311F,
	-184.814F,
	157.471F,
	50.0488F,
	12.4512F,
	293.213F,
	185.059F,
	-295.166F,
	164.307F,
	-95.2148F,
	-152.344F,
	385.986F,
	229.736F,
	-36.8652F,
	249.756F,
	179.443F,
	688.477F,
	317.627F,
	168.457F,
	-73.7305F,
	127.930F,
	-24.1699F,
	-219.727F,
	-387.695F,
	-290.283F,
	264.648F,
	61.2793F,
	58.1055F,
	491.699F,
	437.500F,
	246.582F,
	303.955F,
	398.682F,
	425.049F,
	-299.561F,
	-375.977F,
	-294.922F,
	-151.611F,
	111.328F,
	-26.6113F,
	9.76563F,
	-15.8691F,
	192.383F,
	-196.533F,
	-170.654F,
	-329.590F,
	-142.334F,
	220.703F,
	203.125F,
	-195.557F,
	129.883F,
	145.020F,
	481.445F,
	343.750F,
	329.834F,
	-287.354F,
	-458.984F,
	-516.113F,
	-188.721F,
	138.672F,
	231.445F,
	-247.803F,
	263.428F,
	307.617F,
	-271.240F,
	117.676F,
	-31.7383F,
	434.082F,
	254.883F,
	190.430F,
	-364.014F,
	59.8145F,
	222.656F,
	-77.1484F,
	-278.564F,
	-223.877F,
	-130.859F,
	-352.051F,
	-572.754F,
	-191.650F,
	-377.441F,
	-485.352F,
	-489.014F,
	62.7441F,
	221.924F,
	-451.416F,
	-154.541F,
	-295.166F,
	-375.488F,
	-468.262F,
	-257.324F,
	392.090F,
	546.631F,
	384.766F,
	-138.428F,
	-366.211F,
	-376.953F,
	-312.256F,
	47.6074F,
	334.229F,
	-199.463F,
	71.5332F,
	297.607F,
	-128.174F,
	153.809F,
	292.236F,
	-414.551F,
	-592.041F,
	-449.219F,
	-73.9746F,
	178.467F,
	182.373F,
	-285.400F,
	-61.2793F,
	65.6738F,
	-231.934F,
	-18.3105F,
	411.133F,
	-288.574F,
	-110.596F,
	245.361F,
	-390.381F,
	142.822F,
	92.2852F,
	-506.592F,
	-139.404F,
	-104.248F,
	-129.150F,
	-282.959F,
	-285.889F,
	-69.0918F,
	-50.0488F,
	-137.695F,
	-194.336F,
	304.199F,
	175.049F,
	555.908F,
	226.318F,
	131.592F,
	-110.840F,
	136.475F,
	107.422F,
	-175.049F,
	356.445F,
	394.287F,
	-251.465F,
	256.836F,
	393.066F,
	-285.400F,
	-33.6914F,
	206.787F,
	55.1758F,
	9.52148F,
	-149.414F,
	-305.420F,
	-25.8789F,
	-177.979F,
	-158.936F,
	236.328F,
	317.871F,
	-174.316F,
	-155.273F,
	421.631F,
	86.1816F,
	260.986F,
	100.098F,
	-194.824F,
	-38.0859F,
	268.311F,
	-140.137F,
	224.121F,
	108.887F,
	-319.824F,
	247.070F,
	113.770F,
	343.750F,
	388.428F,
	186.768F,
	348.877F,
	336.914F,
	428.955F,
	475.830F,
	477.539F,
	580.566F,
	385.254F,
	499.756F,
	524.414F,
	223.633F,
	23.9258F,
	-1.70898F,
	462.158F,
	346.191F,
	522.705F,
	84.9609F,
	343.018F,
	385.498F,
	37.1094F,
	276.855F,
	439.697F,
	-65.1855F,
	37.5977F,
	340.576F,
	-284.668F,
	114.502F,
	257.324F,
	-278.809F,
	-98.8770F,
	-261.963F,
	-327.393F,
	-552.734F,
	-385.986F,
	-88.8672F,
	212.158F,
	416.504F,
	-283.691F,
	134.033F,
	378.418F,
	-299.072F,
	-471.680F,
	-406.738F,
	-362.549F,
	-482.666F,
	-501.709F,
	-421.631F,
	-221.191F,
	-23.9258F,
	-463.135F,
	56.8848F,
	364.258F,
	217.773F,
	26.3672F,
	-80.8105F,
	-421.875F,
	-285.645F,
	-415.039F,
	-258.789F,
	483.398F,
	437.012F,
	-261.230F,
	-425.049F,
	-466.064F,
	-2.68555F,
	375.732F,
	321.533F,
	-390.625F,
	22.9492F,
	121.338F,
	102.783F,
	108.154F,
	-48.0957F,
	-385.254F,
	-85.2051F,
	-242.676F,
	-146.240F,
	-131.592F,
	278.320F,
	-235.596F,
	-346.436F,
	-31.4941F,
	-327.393F,
	42.7246F,
	-109.131F,
	-91.5527F,
	320.068F,
	501.709F,
	-90.5762F,
	-158.691F,
	-74.9512F,
	-261.963F,
	147.705F,
	89.1113F,
	-502.197F,
	-27.5879F,
	104.980F,
	159.180F,
	223.145F,
	236.084F,
	-247.070F,
	-387.207F,
	-567.139F,
	367.432F,
	304.688F,
	136.475F,
	63.9648F,
	-118.652F,
	-97.9004F,
	-421.631F,
	327.637F,
	377.441F,
	12.2070F,
	13.6719F,
	105.469F,
	-80.5664F,
	29.0527F,
	-147.461F,
	-370.361F,
	-263.672F,
	-197.754F,
	230.957F,
	275.146F,
	257.568F,
	-341.797F,
	-415.771F,
	-417.969F,
	-310.059F,
	-171.875F,
	-321.533F,
	197.021F,
	444.580F,
	279.053F,
	673.828F,
	392.090F,
	530.029F,
	273.438F,
	99.8535F,
	-36.6211F,
	-35.8887F,
	98.6328F,
	234.131F,
	595.459F,
	466.553F,
	534.424F,
	-221.191F,
	-34.4238F,
	-211.426F,
	-220.703F,
	-34.6680F,
	-111.816F,
	-135.986F,
	-172.852F,
	-409.912F,
	-202.637F,
	-349.365F,
	-386.475F,
	-449.707F,
	-328.613F,
	-265.137F,
	-391.602F,
	-66.4063F,
	223.389F,
	-291.992F,
	188.477F,
	257.813F,
	-155.762F,
	-301.270F,
	-463.135F,
	-122.070F,
	-19.7754F,
	-200.684F,
	-314.697F,
	-393.799F,
	-179.443F,
	-28.5645F,
	191.650F,
	41.0156F,
	-266.113F,
	276.611F,
	225.098F,
	-267.578F,
	-182.129F,
	337.891F,
	70.0684F,
	-133.545F,
	-259.521F,
	-335.938F,
	-537.354F,
	-293.945F,
	-531.250F,
	-383.301F,
	-428.955F,
	-368.896F,
	-547.119F,
	-188.232F,
	-424.072F,
	268.311F,
	202.637F,
	-387.695F,
	176.758F,
	303.467F,
	-376.465F,
	169.189F,
	196.533F,
	-412.598F,
	-58.5938F,
	406.494F,
	-415.039F,
	-0.976563F,
	-163.086F,
	524.658F,
	199.219F,
	254.395F,
	-199.707F,
	-449.463F,
	5.37109F,
	-186.523F,
	-123.779F,
	109.619F,
	-281.006F,
	-150.635F,
	70.5566F,
	-205.811F,
	-389.648F,
	-58.5938F,
	121.582F,
	-57.1289F,
	-160.400F,
	-183.594F,
	117.188F,
	409.668F,
	-77.8809F,
	-117.432F,
	47.1191F,
	-197.998F,
	41.7480F,
	-29.0527F,
	-519.531F,
	-49.3164F,
	-207.031F,
	419.189F,
	278.320F,
	415.039F

};
__device__ static const Float32 dico3_lsf_3[] =
{
	16.3574F,
	-4.15039F,
	16.1133F,
	-2.92969F,
	-412.598F,
	-141.846F,
	-25.3906F,
	-66.4063F,
	-262.695F,
	-289.551F,
	-450.439F,
	-91.7969F,
	-278.320F,
	-226.074F,
	-102.539F,
	-14.1602F,
	-63.2324F,
	-160.156F,
	-276.855F,
	-135.010F,
	436.523F,
	299.561F,
	111.084F,
	31.4941F,
	112.793F,
	107.666F,
	-58.5938F,
	-128.906F,
	205.078F,
	125.488F,
	31.7383F,
	-18.3105F,
	271.973F,
	152.100F,
	37.3535F,
	52.7344F,
	260.742F,
	137.695F,
	-1.46484F,
	-67.3828F,
	273.193F,
	177.490F,
	46.3867F,
	-16.6016F,
	171.875F,
	74.7070F,
	29.0527F,
	-64.4531F,
	80.3223F,
	14.8926F,
	-24.4141F,
	38.0859F,
	88.8672F,
	30.0293F,
	44.6777F,
	-50.7813F,
	-41.7480F,
	-30.0293F,
	53.7109F,
	-15.8691F,
	-74.7070F,
	-15.1367F,
	98.1445F,
	4.15039F,
	-161.133F,
	-229.004F,
	-64.9414F,
	0.000000F,
	93.9941F,
	57.3730F,
	67.3828F,
	69.5801F,
	78.1250F,
	65.4297F,
	-82.0313F,
	-48.8281F,
	-176.758F,
	4.15039F,
	-20.5078F,
	93.0176F,
	-132.813F,
	104.736F,
	120.605F,
	126.709F,
	-28.5645F,
	70.3125F,
	74.2188F,
	80.3223F,
	156.982F,
	38.3301F,
	171.143F,
	124.023F,
	292.969F,
	152.588F,
	194.336F,
	148.438F,
	243.652F,
	102.783F,
	120.117F,
	154.297F,
	293.945F,
	190.430F,
	108.887F,
	32.2266F,
	306.885F,
	206.055F,
	133.545F,
	109.619F,
	202.393F,
	160.645F,
	132.080F,
	114.746F,
	276.367F,
	307.129F,
	224.121F,
	156.006F,
	133.545F,
	12.4512F,
	103.271F,
	68.1152F,
	2.19727F,
	95.7031F,
	20.2637F,
	22.9492F,
	132.324F,
	132.568F,
	55.9082F,
	-35.8887F,
	-48.3398F,
	31.4941F,
	47.3633F,
	-45.1660F,
	-210.693F,
	-322.510F,
	-73.7305F,
	7.32422F,
	-145.752F,
	-153.564F,
	-4.63867F,
	27.8320F,
	-219.727F,
	-263.916F,
	113.770F,
	86.1816F,
	-362.061F,
	-384.033F,
	3.66211F,
	-34.9121F,
	-416.992F,
	-502.686F,
	-183.350F,
	47.8516F,
	-458.008F,
	-504.639F,
	-156.738F,
	-62.9883F,
	-570.068F,
	-358.887F,
	-109.863F,
	-137.695F,
	-142.578F,
	-45.4102F,
	-212.891F,
	-101.074F,
	-440.674F,
	-241.211F,
	-274.658F,
	-319.824F,
	-177.246F,
	-275.635F,
	6.83594F,
	41.2598F,
	-253.662F,
	-210.938F,
	-175.293F,
	-60.0586F,
	118.164F,
	8.78906F,
	-56.8848F,
	-11.9629F,
	64.6973F,
	16.3574F,
	70.5566F,
	114.014F,
	43.4570F,
	132.568F,
	197.754F,
	131.836F,
	20.5078F,
	68.8477F,
	164.063F,
	171.631F,
	-238.037F,
	-189.697F,
	31.4941F,
	70.0684F,
	-229.004F,
	-55.4199F,
	233.154F,
	145.264F,
	-394.775F,
	-70.5566F,
	204.102F,
	158.447F,
	-450.928F,
	-52.4902F,
	270.020F,
	175.293F,
	-496.582F,
	-264.893F,
	158.691F,
	107.422F,
	-512.939F,
	-129.150F,
	221.436F,
	140.381F,
	-490.967F,
	-82.0313F,
	163.574F,
	49.8047F,
	-583.252F,
	-168.945F,
	87.8906F,
	33.4473F,
	-526.367F,
	-538.086F,
	-2.19727F,
	68.3594F,
	-64.9414F,
	29.0527F,
	9.52148F,
	47.1191F,
	19.0430F,
	-14.4043F,
	-29.2969F,
	55.1758F,
	-238.037F,
	-209.473F,
	-190.674F,
	-267.334F,
	-151.123F,
	-100.830F,
	-110.107F,
	-205.566F,
	-296.875F,
	-322.510F,
	-198.486F,
	-215.576F,
	-335.938F,
	-394.287F,
	-96.1914F,
	-104.492F,
	-179.932F,
	-271.729F,
	-134.033F,
	-192.871F,
	-214.844F,
	-238.037F,
	-236.084F,
	-156.738F,
	-240.479F,
	-216.309F,
	-310.791F,
	-332.275F,
	-115.479F,
	-196.289F,
	-342.041F,
	-343.506F,
	39.0625F,
	-64.6973F,
	-224.365F,
	-67.1387F,
	-60.5469F,
	-61.0352F,
	-175.293F,
	-92.7734F,
	23.6816F,
	-25.1465F,
	-91.5527F,
	-55.9082F,
	-101.318F,
	-47.1191F,
	-32.9590F,
	-135.498F,
	153.320F,
	88.1348F,
	29.0527F,
	52.7344F,
	141.357F,
	88.8672F,
	95.4590F,
	51.0254F,
	154.785F,
	127.441F,
	-37.5977F,
	-36.1328F,
	128.418F,
	94.9707F,
	41.5039F,
	8.05664F,
	25.6348F,
	65.1855F,
	15.6250F,
	92.7734F,
	-366.943F,
	-244.141F,
	-7.32422F,
	-90.0879F,
	-261.230F,
	14.1602F,
	157.959F,
	54.4434F,
	-371.094F,
	-71.0449F,
	151.611F,
	74.9512F,
	-373.779F,
	38.0859F,
	186.035F,
	98.6328F,
	-495.361F,
	34.4238F,
	179.199F,
	121.826F,
	-451.416F,
	-158.691F,
	74.7070F,
	125.000F,
	-45.6543F,
	-25.3906F,
	-14.4043F,
	106.934F,
	32.7148F,
	-56.1523F,
	38.0859F,
	-45.4102F,
	-14.8926F,
	-63.4766F,
	-3.90625F,
	2.44141F,
	-138.916F,
	-0.732422F,
	-102.783F,
	-72.5098F,
	-421.143F,
	-127.197F,
	-84.4727F,
	43.4570F,
	-332.520F,
	-14.4043F,
	-10.7422F,
	38.3301F,
	-523.926F,
	-112.549F,
	-114.746F,
	-85.2051F,
	-529.785F,
	-0.244141F,
	-90.0879F,
	-29.5410F,
	-385.498F,
	-91.0645F,
	-219.727F,
	-247.803F,
	-272.705F,
	-144.287F,
	-149.658F,
	-191.406F,
	-136.963F,
	29.7852F,
	-18.3105F,
	-109.619F,
	-0.976563F,
	-41.7480F,
	-30.0293F,
	-90.8203F,
	46.8750F,
	41.0156F,
	-18.5547F,
	-32.2266F,
	61.5234F,
	-26.1230F,
	83.0078F,
	51.2695F,
	95.7031F,
	124.268F,
	66.4063F,
	44.1895F,
	-26.6113F,
	35.4004F,
	53.2227F,
	29.0527F,
	-101.563F,
	-64.2090F,
	118.408F,
	64.6973F,
	-44.1895F,
	-1.95313F,
	-69.8242F,
	55.1758F,
	-59.5703F,
	-53.2227F,
	16.8457F,
	-70.8008F,
	-38.5742F,
	46.6309F,
	-0.244141F,
	-15.6250F,
	-144.531F,
	-21.9727F,
	52.0020F,
	-23.4375F,
	62.2559F,
	106.201F,
	43.4570F,
	-19.5313F,
	-90.0879F,
	-4.39453F,
	-8.05664F,
	-19.5313F,
	-10.2539F,
	101.318F,
	34.1797F,
	-54.1992F,
	279.053F,
	158.936F,
	158.447F,
	80.3223F,
	187.256F,
	135.742F,
	60.7910F,
	57.3730F,
	231.445F,
	100.830F,
	107.910F,
	68.1152F,
	34.4238F,
	82.7637F,
	86.9141F,
	135.986F,
	-114.746F,
	-41.5039F,
	24.1699F,
	57.8613F,
	-138.916F,
	-195.313F,
	85.9375F,
	137.939F,
	68.8477F,
	115.479F,
	114.746F,
	81.0547F,
	-48.5840F,
	-168.457F,
	-313.477F,
	-223.877F,
	-47.1191F,
	-104.004F,
	-195.313F,
	-273.926F,
	-6.34766F,
	-90.5762F,
	-119.629F,
	-47.1191F,
	155.518F,
	145.264F,
	126.709F,
	80.5664F,
	99.6094F,
	-28.0762F,
	19.2871F,
	2.92969F,
	116.455F,
	21.2402F,
	-25.1465F,
	-91.7969F,
	-162.598F,
	-84.7168F,
	-67.6270F,
	-71.0449F,
	-124.512F,
	-117.432F,
	41.2598F,
	72.5098F,
	-202.393F,
	-180.176F,
	-50.0488F,
	-41.7480F,
	-78.1250F,
	-131.836F,
	80.0781F,
	69.0918F,
	-209.717F,
	-233.887F,
	107.910F,
	-0.488281F,
	135.742F,
	167.480F,
	31.7383F,
	13.6719F,
	337.646F,
	247.070F,
	184.326F,
	104.248F,
	149.414F,
	180.908F,
	153.320F,
	135.010F,
	-82.7637F,
	-194.336F,
	32.7148F,
	67.6270F,
	-154.541F,
	-264.893F,
	-0.488281F,
	-60.0586F,
	-214.844F,
	-252.686F,
	-392.334F,
	-259.766F,
	-242.676F,
	-115.723F,
	-277.832F,
	-119.141F,
	-101.074F,
	-194.092F,
	17.8223F,
	-50.2930F,
	-1.95313F,
	-33.9355F,
	107.178F,
	49.8047F,
	-42.9688F,
	-141.113F,
	5.61523F,
	31.9824F,
	-65.6738F,
	-184.814F,
	-46.6309F,
	59.8145F,
	-26.6113F,
	-82.5195F,
	27.3438F,
	77.1484F,
	29.2969F,
	-99.1211F,
	-28.8086F,
	149.170F,
	-43.9453F,
	-45.4102F,
	-157.471F,
	28.0762F,
	-42.2363F,
	8.30078F,
	-126.465F,
	-119.385F,
	-36.8652F,
	14.8926F,
	-142.334F,
	-206.055F,
	53.7109F,
	-33.6914F,
	-166.260F,
	-249.023F,
	95.4590F,
	-4.15039F,
	-145.996F,
	-78.3691F,
	38.3301F,
	-72.0215F,
	31.4941F,
	37.8418F,
	-226.074F,
	-213.623F,
	-240.967F,
	69.5801F,
	58.8379F,
	-20.2637F,
	-30.5176F,
	-30.5176F,
	151.367F,
	145.752F,
	105.469F,
	22.4609F,
	95.9473F,
	19.0430F,
	99.8535F,
	14.8926F,
	-95.9473F,
	-180.420F,
	-100.830F,
	-182.617F,
	20.2637F,
	13.1836F,
	88.1348F,
	6.59180F,
	-264.648F,
	31.7383F,
	-82.2754F,
	-169.434F,
	-382.080F,
	72.5098F,
	77.6367F,
	-4.63867F,
	-457.275F,
	8.78906F,
	12.4512F,
	-77.3926F,
	-567.139F,
	-60.0586F,
	56.3965F,
	-20.5078F,
	-562.988F,
	-191.162F,
	9.76563F,
	-43.7012F,
	-545.166F,
	-227.051F,
	-115.723F,
	-112.793F,
	-184.082F,
	-20.9961F,
	-70.3125F,
	-152.832F,
	-588.623F,
	-111.084F,
	-15.3809F,
	41.7480F,
	-268.311F,
	-267.090F,
	-6.34766F,
	-34.9121F,
	-291.260F,
	-111.084F,
	-99.1211F,
	-93.0176F,
	-147.705F,
	-51.2695F,
	-23.4375F,
	-12.4512F,
	-141.602F,
	-116.211F,
	-67.3828F,
	-3.66211F,
	-291.748F,
	-154.785F,
	-293.701F,
	-215.088F,
	-92.2852F,
	-53.9551F,
	-163.330F,
	-232.422F,
	145.020F,
	43.4570F,
	-98.3887F,
	-165.039F,
	186.279F,
	79.8340F,
	146.729F,
	70.8008F,
	41.9922F,
	73.2422F,
	49.5605F,
	38.3301F,
	-13.6719F,
	-82.0313F,
	86.9141F,
	5.85938F,
	-55.6641F,
	-72.2656F,
	-63.2324F,
	-7.08008F,
	-45.4102F,
	64.2090F,
	101.563F,
	3.41797F,
	-86.1816F,
	91.0645F,
	-2.92969F,
	-52.7344F,
	62.7441F,
	23.4375F,
	42.4805F,
	13.9160F,
	-372.559F,
	-150.391F,
	-232.910F,
	-121.826F,
	-121.338F,
	-37.1094F,
	-81.2988F,
	30.5176F,
	25.6348F,
	48.8281F,
	43.7012F,
	-23.6816F,
	-80.8105F,
	-54.6875F,
	186.768F,
	170.166F,
	185.547F,
	62.5000F,
	73.4863F,
	14.4043F,
	111.084F,
	-20.7520F,
	49.8047F,
	70.3125F,
	-125.488F,
	58.5938F,
	61.2793F,
	-26.6113F,
	62.5000F,
	101.807F,
	-8.30078F,
	-100.830F,
	24.6582F,
	104.980F,
	93.7500F,
	38.0859F,
	-7.56836F,
	-2.44141F,
	50.2930F,
	104.004F,
	143.799F,
	35.4004F,
	34.9121F,
	17.3340F,
	197.266F,
	221.191F,
	81.2988F,
	85.2051F,
	240.723F,
	229.004F,
	143.799F,
	80.8105F,
	317.383F,
	201.172F,
	45.6543F,
	124.268F,
	259.277F,
	159.424F,
	92.5293F,
	113.770F,
	356.934F,
	228.760F,
	97.9004F,
	66.8945F,
	192.139F,
	210.205F,
	64.6973F,
	0.488281F,
	148.682F,
	135.010F,
	6.83594F,
	74.4629F,
	226.074F,
	83.0078F,
	25.8789F,
	94.2383F,
	58.8379F,
	-65.1855F,
	-35.8887F,
	54.9316F,
	-43.4570F,
	-130.371F,
	84.7168F,
	122.559F,
	-156.982F,
	-93.0176F,
	96.9238F,
	7.32422F,
	-158.936F,
	-178.955F,
	-106.201F,
	97.1680F,
	-99.3652F,
	-177.246F,
	-118.164F,
	-60.5469F,
	-192.627F,
	-223.145F,
	-106.934F,
	-116.211F,
	-121.582F,
	-95.2148F,
	18.3105F,
	-72.0215F,
	-235.352F,
	-144.043F,
	-147.949F,
	36.6211F,
	-29.5410F,
	-11.9629F,
	-37.8418F,
	-19.0430F,
	228.271F,
	134.277F,
	94.9707F,
	9.27734F,
	-78.3691F,
	31.0059F,
	103.516F,
	76.9043F,
	-69.5801F,
	-27.5879F,
	69.0918F,
	63.2324F,
	160.645F,
	49.5605F,
	78.6133F,
	118.652F,
	220.459F,
	123.291F,
	182.617F,
	101.807F,
	149.170F,
	103.271F,
	135.498F,
	125.000F,
	58.3496F,
	-20.2637F,
	-141.113F,
	-4.63867F,
	-82.7637F,
	-178.467F,
	85.2051F,
	3.17383F,
	-228.027F,
	-341.553F,
	-27.8320F,
	-87.8906F,
	26.1230F,
	168.945F,
	44.4336F,
	21.9727F,
	-303.467F,
	-375.488F,
	-378.662F,
	-177.002F,
	-138.672F,
	-220.459F,
	-332.764F,
	-128.174F,
	-126.221F,
	-208.252F,
	-210.205F,
	-245.117F,
	-41.0156F,
	-168.457F,
	-203.857F,
	15.3809F,
	-33.4473F,
	-135.742F,
	-133.545F,
	35.1563F,
	-69.8242F,
	-199.463F,
	118.408F,
	77.8809F,
	-35.8887F,
	-99.6094F,
	128.418F,
	60.0586F,
	-84.7168F,
	-105.957F,
	72.5098F,
	-6.83594F,
	-70.8008F,
	-114.990F,
	-270.996F,
	-313.721F,
	-112.305F,
	-87.6465F,
	-241.211F,
	-193.848F,
	328.857F,
	317.139F,
	168.457F,
	127.686F,
	296.875F,
	260.742F,
	267.090F,
	184.814F,
	201.416F,
	278.320F,
	183.594F,
	120.605F,
	305.664F,
	333.252F,
	291.748F,
	219.238F,
	127.197F,
	257.080F,
	129.883F,
	105.469F,
	-81.5430F,
	-52.7344F,
	-76.4160F,
	-64.2090F,
	-39.0625F,
	12.6953F,
	-115.234F,
	-37.8418F,
	31.0059F,
	33.2031F,
	-92.7734F,
	10.7422F,
	207.764F,
	100.098F,
	-39.5508F,
	-119.385F,
	30.0293F,
	-62.2559F,
	-194.336F,
	-162.842F,
	266.113F,
	223.877F,
	192.627F,
	120.361F,
	341.064F,
	292.236F,
	136.230F,
	49.3164F,
	-12.4512F,
	-28.8086F,
	-83.4961F,
	-171.143F,
	20.2637F,
	26.3672F,
	-10.2539F,
	-107.666F,
	14.8926F,
	23.1934F,
	70.0684F,
	62.5000F,
	-6.59180F,
	21.7285F,
	127.930F,
	129.639F,
	85.6934F,
	55.4199F,
	144.531F,
	133.057F,
	170.166F,
	37.8418F,
	-40.0391F,
	74.9512F,
	155.762F,
	66.8945F,
	-119.385F,
	-12.2070F,
	184.082F,
	58.5938F,
	-40.5273F,
	-30.2734F,
	-28.3203F,
	-141.357F,
	-295.898F,
	-15.3809F,
	46.3867F,
	-72.0215F,
	-253.906F,
	-316.406F,
	35.8887F,
	-91.7969F,
	-43.2129F,
	-27.5879F,
	205.322F,
	302.979F,
	256.592F,
	163.086F,
	0.488281F,
	71.5332F,
	134.521F,
	74.2188F,
	-267.578F,
	-232.666F,
	-60.5469F,
	91.7969F,
	-183.105F,
	-235.596F,
	21.2402F,
	125.977F,
	-67.1387F,
	-125.977F,
	168.213F,
	95.4590F,
	-92.5293F,
	-156.982F,
	213.867F,
	145.020F,
	-95.2148F,
	-247.314F,
	-157.471F,
	139.893F,
	-26.1230F,
	-138.672F,
	-168.213F,
	-201.660F,
	-250.244F,
	-6.59180F,
	-80.0781F,
	-49.5605F,
	210.205F,
	182.861F,
	133.789F,
	56.8848F,
	-405.273F,
	-254.639F,
	110.107F,
	26.3672F,
	-161.133F,
	-151.367F,
	104.980F,
	57.6172F,
	5.12695F,
	-96.6797F,
	-282.715F,
	-154.053F,
	334.961F,
	316.895F,
	236.084F,
	140.869F,
	274.658F,
	274.658F,
	143.799F,
	110.840F,
	-78.8574F,
	-211.182F,
	-114.014F,
	37.3535F,
	-114.258F,
	-170.654F,
	-196.289F,
	-124.268F,
	-95.7031F,
	-175.293F,
	-49.8047F,
	-8.54492F,
	-147.217F,
	-266.846F,
	-138.428F,
	-39.5508F,
	-123.291F,
	-245.117F,
	-24.9023F,
	85.4492F,
	53.4668F,
	54.6875F,
	103.271F,
	61.5234F,
	96.4355F,
	144.287F,
	148.438F,
	88.6230F,
	-182.129F,
	-23.4375F,
	91.0645F,
	41.9922F,
	41.7480F,
	72.0215F,
	174.316F,
	82.7637F,
	56.8848F,
	18.7988F,
	26.1230F,
	67.6270F,
	38.3301F,
	37.3535F,
	-121.826F,
	-86.9141F,
	377.686F,
	261.963F,
	140.625F,
	120.605F,
	-71.2891F,
	-82.7637F,
	-123.047F,
	-144.531F,
	-220.459F,
	-17.5781F,
	-151.123F,
	-117.432F,
	-389.160F,
	-272.705F,
	-138.428F,
	-62.0117F,
	-193.604F,
	-123.779F,
	-137.695F,
	-71.0449F,
	-120.117F,
	-129.883F,
	122.559F,
	136.719F,
	-93.2617F,
	104.248F,
	146.484F,
	56.1523F,
	-55.4199F,
	116.455F,
	61.2793F,
	18.3105F,
	69.5801F,
	205.566F,
	198.486F,
	116.211F,
	-319.824F,
	-325.439F,
	45.4102F,
	92.0410F,
	-143.311F,
	-223.877F,
	156.982F,
	93.0176F,
	-289.551F,
	-135.010F,
	100.342F,
	20.0195F,
	-275.146F,
	-200.195F,
	-42.4805F,
	-131.836F,
	-147.461F,
	29.0527F,
	132.568F,
	50.0488F,
	-92.7734F,
	160.400F,
	221.924F,
	138.428F,
	27.3438F,
	-72.7539F,
	-91.3086F,
	27.8320F,
	-209.229F,
	-61.2793F,
	13.6719F,
	38.8184F,
	97.9004F,
	84.2285F,
	-8.30078F,
	-34.1797F,
	-27.0996F,
	-148.193F,
	10.0098F,
	149.902F,
	86.6699F,
	-27.8320F,
	-18.7988F,
	115.723F,
	141.113F,
	13.6719F,
	354.004F,
	225.586F,
	268.066F,
	346.680F,
	180.908F,
	97.6563F,
	60.0586F,
	5.37109F,
	143.555F,
	76.4160F,
	-29.5410F,
	79.8340F,
	202.881F,
	115.234F,
	-277.832F,
	-148.438F,
	208.984F,
	134.766F,
	-302.979F,
	-261.719F,
	155.762F,
	146.484F,
	-87.4023F,
	62.0117F,
	-81.2988F,
	-73.9746F,
	-157.715F,
	180.420F,
	87.4023F,
	18.0664F,
	299.316F,
	407.959F,
	298.096F,
	207.275F,
	547.119F,
	396.484F,
	239.990F,
	155.273F,
	449.463F,
	360.596F,
	182.861F,
	93.7500F,
	85.4492F,
	64.2090F,
	21.2402F,
	31.2500F,
	-464.355F,
	-229.736F,
	-35.1563F,
	-15.6250F,
	-423.340F,
	-62.2559F,
	70.3125F,
	-7.56836F,
	-645.508F,
	-302.246F,
	89.3555F,
	57.3730F,
	-401.123F,
	-266.602F,
	-328.125F,
	-74.2188F,
	-132.080F,
	-262.451F,
	-272.461F,
	30.0293F,
	-287.598F,
	-61.5234F,
	-199.219F,
	-43.9453F,
	-248.047F,
	130.127F,
	137.939F,
	56.8848F,
	-118.896F,
	-104.980F,
	-45.8984F,
	81.5430F,
	211.670F,
	301.758F,
	130.371F,
	41.7480F,
	-388.184F,
	-392.334F,
	155.029F,
	153.809F,
	-536.133F,
	75.6836F,
	225.586F,
	100.586F,
	-575.684F,
	-80.0781F,
	233.398F,
	129.150F,
	-644.287F,
	-92.0410F,
	153.809F,
	67.8711F,
	-635.254F,
	77.3926F,
	195.068F,
	72.9980F,
	-587.402F,
	32.4707F,
	83.0078F,
	7.56836F,
	-526.367F,
	-358.398F,
	31.9824F,
	30.5176F,
	-289.063F,
	-119.629F,
	-33.9355F,
	11.2305F,
	-181.641F,
	109.131F,
	217.529F,
	137.695F,
	16.3574F,
	-110.107F,
	157.715F,
	147.461F,
	-135.010F,
	-104.736F,
	-213.867F,
	96.6797F,
	39.5508F,
	-16.1133F,
	318.604F,
	223.389F,
	116.943F,
	141.357F,
	265.625F,
	193.848F,
	109.863F,
	67.8711F,
	138.184F,
	79.1016F,
	-258.057F,
	-37.5977F,
	36.1328F,
	-43.2129F,
	-621.338F,
	41.0156F,
	261.230F,
	144.531F,
	-573.975F,
	-10.2539F,
	199.951F,
	84.2285F,
	-572.266F,
	-172.607F,
	176.025F,
	61.0352F,
	-531.006F,
	-365.479F,
	-75.4395F,
	29.7852F,
	-19.0430F,
	-17.8223F,
	29.2969F,
	42.2363F,
	-0.976563F,
	63.9648F,
	-64.2090F,
	-63.7207F,
	-105.225F,
	-15.6250F,
	-98.8770F,
	-178.711F,
	-636.963F,
	28.3203F,
	-20.2637F,
	-47.1191F,
	-372.314F,
	-230.469F,
	-116.455F,
	-177.002F,
	-124.023F,
	74.9512F,
	41.5039F,
	41.9922F,
	203.125F,
	101.807F,
	203.125F,
	167.480F,
	-54.9316F,
	43.2129F,
	218.262F,
	199.707F,
	-117.676F,
	-94.9707F,
	312.256F,
	253.662F,
	-93.5059F,
	49.0723F,
	-85.4492F,
	9.76563F,
	178.223F,
	155.029F,
	55.1758F,
	128.418F,
	122.803F,
	112.793F,
	82.5195F,
	97.1680F,
	130.615F,
	174.316F,
	9.76563F,
	-68.8477F,
	361.816F,
	359.131F,
	264.893F,
	178.467F,
	381.104F,
	261.719F,
	221.924F,
	169.189F,
	346.436F,
	312.988F,
	217.041F,
	214.600F,
	281.494F,
	177.734F,
	289.551F,
	205.078F,
	-55.1758F,
	275.879F,
	231.689F,
	168.213F,
	-120.605F,
	-240.723F,
	-379.883F,
	-31.2500F,
	-138.672F,
	-176.025F,
	-174.072F,
	-6.34766F,
	77.3926F,
	127.930F,
	17.0898F,
	32.9590F,
	-98.8770F,
	-211.182F,
	-431.152F,
	-159.180F,
	-42.4805F,
	-195.557F,
	216.064F,
	188.721F,
	-37.3535F,
	-22.2168F,
	268.311F,
	183.350F,
	-123.535F,
	-280.518F,
	208.252F,
	157.715F,
	58.8379F,
	190.918F,
	126.709F,
	131.592F,
	452.393F,
	415.039F,
	268.799F,
	166.992F,
	-304.932F,
	-362.793F,
	-113.281F,
	45.8984F,
	-218.018F,
	-343.994F,
	-320.313F,
	-83.2520F,
	-32.9590F,
	106.934F,
	-42.7246F,
	4.39453F,
	271.240F,
	238.281F,
	77.8809F,
	50.7813F,
	-349.121F,
	-431.641F,
	20.2637F,
	111.816F,
	-129.395F,
	-244.141F,
	74.9512F,
	31.4941F,
	-205.078F,
	-3.66211F,
	-7.08008F,
	-86.9141F,
	-222.412F,
	-225.586F,
	-280.029F,
	-59.0820F,
	-29.0527F,
	-128.906F,
	31.0059F,
	-32.4707F,
	-185.791F,
	-186.768F,
	46.3867F,
	-20.2637F,
	-76.9043F,
	218.506F,
	127.441F,
	56.3965F,
	-54.1992F,
	24.9023F,
	-15.3809F,
	-104.492F,
	77.1484F,
	170.654F,
	92.5293F,
	17.0898F,
	6.10352F,
	174.805F,
	76.6602F,
	-26.3672F,
	123.779F,
	213.379F,
	138.184F,
	58.1055F,
	26.3672F,
	229.736F,
	126.709F,
	47.6074F,
	103.760F,
	-14.6484F,
	-104.248F,
	62.7441F,
	33.9355F,
	-25.1465F,
	-153.809F,
	108.887F,
	81.5430F,
	90.3320F,
	100.586F,
	11.7188F,
	-41.9922F,
	-168.457F,
	-69.0918F,
	135.986F,
	45.6543F,
	-69.8242F,
	38.5742F,
	117.920F,
	34.1797F,
	65.9180F,
	-83.9844F,
	-154.053F,
	225.586F,
	141.357F,
	-28.3203F,
	32.2266F,
	34.6680F,
	113.770F,
	-16.6016F,
	-15.6250F,
	56.1523F,
	-35.4004F,
	-73.7305F,
	-132.324F,
	-196.045F,
	-222.656F,
	248.535F,
	179.932F,
	-188.721F,
	247.803F,
	153.809F,
	72.5098F,
	-633.789F,
	23.1934F,
	108.643F,
	82.0313F,
	-518.066F,
	119.873F,
	124.512F,
	46.6309F,
	-305.908F,
	39.3066F,
	-0.488281F,
	-79.1016F,
	-354.004F,
	-154.541F,
	-173.828F,
	-25.6348F,
	-205.566F,
	-62.0117F,
	-100.342F,
	24.4141F,
	-156.250F,
	-70.8008F,
	246.582F,
	186.279F,
	-158.691F,
	76.4160F,
	285.400F,
	178.223F,
	34.1797F,
	123.291F,
	251.465F,
	187.012F,
	188.477F,
	70.0684F,
	260.498F,
	200.928F,
	120.850F,
	182.861F,
	74.4629F,
	78.8574F,
	-40.0391F,
	112.793F,
	19.0430F,
	97.4121F,
	-83.4961F,
	-213.379F,
	16.8457F,
	145.752F,
	-3.90625F,
	151.367F,
	151.611F,
	82.2754F,
	-33.6914F,
	-108.398F,
	-64.6973F,
	53.2227F,
	20.5078F,
	-109.863F,
	232.666F,
	162.598F,
	-54.1992F,
	-196.045F,
	132.080F,
	147.461F,
	-224.854F,
	-335.938F,
	59.5703F,
	28.3203F,
	-205.322F,
	-176.514F,
	153.809F,
	143.555F,
	34.1797F,
	161.865F,
	71.7773F,
	89.8438F,
	228.271F,
	255.371F,
	215.088F,
	185.303F,
	426.270F,
	357.422F,
	223.633F,
	153.320F,
	106.445F,
	235.107F,
	68.6035F,
	0.244141F,
	-29.0527F,
	18.0664F,
	132.324F,
	52.0020F,
	0.244141F,
	-138.428F,
	73.4863F,
	58.8379F,
	63.4766F,
	106.201F,
	54.1992F,
	96.6797F,
	228.516F,
	233.643F,
	270.508F,
	171.631F,
	124.512F,
	123.535F,
	197.266F,
	116.699F,
	146.729F,
	169.434F,
	234.375F,
	151.367F,
	237.305F,
	180.908F,
	239.258F,
	146.484F,
	203.613F,
	175.049F,
	187.256F,
	166.992F,
	156.982F,
	237.305F,
	228.271F,
	155.762F,
	122.314F,
	161.377F,
	175.781F,
	207.764F,
	-25.6348F,
	-154.297F,
	-73.9746F,
	-28.5645F,
	-104.736F,
	31.7383F,
	192.627F,
	107.910F,
	-127.441F,
	-45.8984F,
	171.875F,
	91.0645F,
	-185.303F,
	10.2539F,
	198.730F,
	127.686F,
	-129.639F,
	-277.588F,
	91.0645F,
	141.113F,
	-166.504F,
	-293.701F,
	-111.084F,
	69.5801F,
	-283.936F,
	-385.010F,
	-268.066F,
	10.7422F,
	19.7754F,
	-20.0195F,
	173.828F,
	88.6230F,
	116.455F,
	60.0586F,
	232.910F,
	151.855F,
	391.602F,
	395.996F,
	311.768F,
	217.529F,
	343.994F,
	209.717F,
	225.586F,
	217.773F,
	188.965F,
	254.150F,
	231.201F,
	278.809F,
	9.76563F,
	-133.301F,
	-18.3105F,
	70.3125F,
	-150.391F,
	-25.8789F,
	-170.166F,
	-6.34766F,
	-41.2598F,
	-39.0625F,
	-217.529F,
	-180.420F,
	-68.1152F,
	-93.7500F,
	-251.221F,
	-85.4492F,
	434.814F,
	319.336F,
	255.371F,
	199.219F,
	385.742F,
	374.268F,
	359.375F,
	287.598F,
	367.432F,
	262.695F,
	296.875F,
	219.482F,
	217.285F,
	220.703F,
	137.695F,
	159.668F,
	224.609F,
	168.945F,
	249.268F,
	208.984F,
	-120.361F,
	32.2266F,
	43.2129F,
	123.291F,
	17.3340F,
	47.6074F,
	-6.83594F,
	23.6816F,
	111.328F,
	85.6934F,
	-40.0391F,
	21.4844F,
	107.178F,
	67.8711F,
	-9.76563F,
	85.4492F,
	340.576F,
	231.689F,
	57.1289F,
	-23.1934F,
	-196.533F,
	-115.234F,
	9.27734F,
	-39.7949F,
	89.5996F,
	-23.9258F,
	119.385F,
	127.686F,
	250.244F,
	287.598F,
	295.898F,
	221.191F,
	77.8809F,
	320.801F,
	198.730F,
	112.549F,
	-30.0293F,
	-132.568F,
	-196.289F,
	109.131F,
	-182.617F,
	-79.1016F,
	-218.994F,
	-275.146F,
	-179.932F,
	-122.314F,
	-192.627F,
	-174.072F,
	174.561F,
	189.697F,
	302.490F,
	225.098F,
	475.830F,
	473.389F,
	333.984F,
	211.182F,
	178.223F,
	214.844F,
	185.059F,
	94.7266F,
	-212.646F,
	110.840F,
	4.15039F,
	-61.2793F,
	-93.0176F,
	-197.754F,
	-386.475F,
	58.3496F,
	-127.197F,
	-235.840F,
	-193.359F,
	63.2324F,
	-217.285F,
	-331.543F,
	-187.988F,
	-17.8223F,
	40.5273F,
	85.2051F,
	-51.7578F,
	78.8574F,
	-205.078F,
	-73.4863F,
	115.479F,
	106.201F,
	-165.771F,
	-113.281F,
	177.734F,
	85.6934F,
	-38.0859F,
	-48.5840F,
	162.842F,
	105.469F,
	7.08008F,
	-61.5234F,
	101.318F,
	117.188F,
	-178.467F,
	-92.5293F,
	35.4004F,
	136.475F,
	-128.906F,
	-154.053F,
	-282.715F,
	-38.8184F,
	108.643F,
	66.6504F,
	30.0293F,
	156.006F,
	91.0645F,
	-30.7617F,
	195.313F,
	138.672F,
	20.5078F,
	-39.5508F,
	175.781F,
	173.828F,
	-202.637F,
	-130.859F,
	-45.1660F,
	54.1992F,
	99.6094F,
	110.352F,
	122.314F,
	188.232F,
	-218.994F,
	-330.811F,
	-16.3574F,
	107.910F,
	-193.359F,
	-343.262F,
	138.184F,
	146.973F,
	40.7715F,
	-79.5898F,
	124.268F,
	80.5664F,
	-23.1934F,
	-152.832F,
	-178.223F,
	-83.9844F,
	407.227F,
	297.119F,
	190.186F,
	111.084F,
	321.289F,
	202.148F,
	142.578F,
	175.537F,
	98.6328F,
	-7.56836F,
	247.314F,
	192.627F,
	21.7285F,
	26.1230F,
	217.529F,
	134.033F,
	212.646F,
	385.986F,
	223.877F,
	163.818F,
	211.426F,
	361.084F,
	314.697F,
	208.496F,
	95.4590F,
	260.742F,
	273.926F,
	198.242F,
	19.0430F,
	-137.207F,
	84.2285F,
	137.451F,
	104.736F,
	-25.1465F,
	101.807F,
	192.139F,
	-29.7852F,
	-106.689F,
	100.342F,
	192.383F,
	-222.900F,
	-101.807F,
	146.973F,
	184.082F,
	-55.1758F,
	-3.90625F,
	36.8652F,
	185.547F,
	-170.898F,
	28.8086F,
	-25.3906F,
	-3.41797F,
	-275.391F,
	11.7188F,
	69.3359F,
	95.9473F,
	-95.2148F,
	-102.295F,
	-156.006F,
	-28.3203F,
	-222.168F,
	74.7070F,
	77.1484F,
	-3.17383F,
	294.678F,
	240.234F,
	200.439F,
	163.330F,
	-291.748F,
	-169.189F,
	34.1797F,
	-52.0020F,
	-215.820F,
	-101.563F,
	-48.5840F,
	-136.230F,
	-150.391F,
	59.8145F,
	-98.6328F,
	-162.109F,
	63.9648F,
	13.6719F,
	-150.635F,
	-176.758F,
	-20.7520F,
	-119.873F,
	-78.1250F,
	-160.156F,
	-139.160F,
	-202.881F,
	-31.4941F,
	-128.906F,
	-367.676F,
	-15.3809F,
	-89.5996F,
	-93.9941F,
	-87.4023F,
	-78.3691F,
	0.976563F,
	12.4512F,
	-89.3555F,
	-52.2461F,
	77.8809F,
	124.756F,
	35.6445F,
	163.818F,
	-4.15039F,
	-71.0449F,
	-26.8555F,
	113.281F,
	-33.9355F,
	-121.094F,
	-49.3164F,
	53.7109F,
	-76.1719F,
	-154.053F,
	-161.133F,
	-17.8223F,
	-159.912F,
	-200.195F,
	-161.621F,
	-159.424F,
	-314.453F,
	-209.229F,
	-104.980F,
	-232.666F,
	-234.131F,
	-64.4531F,
	-11.9629F,
	-114.258F,
	-17.5781F,
	-93.0176F,
	-85.4492F,
	-137.451F,
	-47.1191F,
	-99.3652F,
	13.4277F,
	-99.6094F,
	-196.045F,
	2.68555F,
	-75.4395F,
	158.447F,
	45.8984F,
	-48.3398F,
	-125.000F,
	112.549F,
	-19.2871F,
	-111.816F,
	-321.777F,
	-64.2090F,
	-32.7148F,
	-127.686F,
	-404.541F,
	-106.201F,
	-120.850F,
	-186.768F,
	13.9160F,
	-84.7168F,
	-101.074F,
	105.957F,
	-278.564F,
	-59.0820F,
	-162.109F,
	-209.229F,
	8.30078F,
	-16.6016F,
	-172.607F,
	-82.5195F

};
#define MR515_3_SIZE  128

/* third codebook for MR475, MR515 */
__device__ static const Float32 mr515_3_lsf[] =
{
	102.295F,
	39.7949F,
	-7.32422F,
	-63.9648F,
	-111.084F,
	-192.627F,
	-349.121F,
	-176.025F,
	245.605F,
	162.109F,
	65.6738F,
	6.10352F,
	151.123F,
	63.4766F,
	44.6777F,
	23.4375F,
	-236.328F,
	-331.543F,
	-94.7266F,
	32.9590F,
	-169.189F,
	203.857F,
	111.328F,
	37.5977F,
	269.775F,
	171.631F,
	138.916F,
	88.6230F,
	396.729F,
	323.730F,
	240.479F,
	182.617F,
	-53.7109F,
	53.4668F,
	18.5547F,
	-50.7813F,
	-355.225F,
	-405.762F,
	11.9629F,
	36.3770F,
	-235.352F,
	-41.9922F,
	-183.594F,
	-82.0313F,
	152.588F,
	51.0254F,
	-61.0352F,
	-16.1133F,
	-248.291F,
	-204.590F,
	-0.488281F,
	77.3926F,
	-529.297F,
	-362.549F,
	-33.6914F,
	30.0293F,
	-458.008F,
	-512.451F,
	-127.197F,
	20.7520F,
	-236.084F,
	-89.3555F,
	-169.678F,
	-215.088F,
	-224.854F,
	-246.826F,
	-186.279F,
	-231.689F,
	-30.2734F,
	-62.5000F,
	-85.9375F,
	-161.133F,
	43.4570F,
	113.037F,
	86.4258F,
	74.2188F,
	-425.781F,
	-144.287F,
	-68.8477F,
	19.2871F,
	-549.072F,
	42.7246F,
	211.670F,
	121.826F,
	-33.6914F,
	-43.9453F,
	-44.1895F,
	-5.12695F,
	-559.326F,
	-302.979F,
	-112.305F,
	-126.953F,
	-188.232F,
	110.107F,
	-2.44141F,
	-75.1953F,
	66.1621F,
	-15.8691F,
	0.976563F,
	52.2461F,
	-68.1152F,
	-106.201F,
	-10.4980F,
	-84.9609F,
	-163.574F,
	8.54492F,
	-15.8691F,
	-51.5137F,
	196.777F,
	130.615F,
	20.7520F,
	72.5098F,
	13.9160F,
	58.3496F,
	176.270F,
	120.361F,
	54.9316F,
	161.377F,
	205.078F,
	133.545F,
	-131.836F,
	-91.7969F,
	3.41797F,
	85.2051F,
	114.502F,
	176.025F,
	80.8105F,
	39.5508F,
	-132.813F,
	-183.594F,
	-15.1367F,
	-2.44141F,
	97.1680F,
	-21.4844F,
	176.758F,
	171.143F,
	-4.63867F,
	-130.127F,
	-22.9492F,
	146.729F,
	33.2031F,
	-17.3340F,
	-166.260F,
	-182.373F,
	-40.5273F,
	-83.9844F,
	63.7207F,
	-12.2070F,
	39.3066F,
	-12.6953F,
	118.408F,
	82.2754F,
	-408.936F,
	12.2070F,
	46.3867F,
	-22.7051F,
	-557.129F,
	-56.3965F,
	-47.3633F,
	-20.0195F,
	-23.1934F,
	-145.264F,
	-37.5977F,
	31.2500F,
	218.262F,
	122.314F,
	143.555F,
	111.572F,
	-84.2285F,
	50.2930F,
	29.7852F,
	26.8555F,
	-154.053F,
	-55.4199F,
	-138.916F,
	0.732422F,
	99.6094F,
	58.3496F,
	96.9238F,
	55.1758F,
	-48.0957F,
	-0.488281F,
	31.2500F,
	119.873F,
	312.744F,
	220.703F,
	71.2891F,
	52.4902F,
	131.348F,
	74.7070F,
	63.2324F,
	124.268F,
	-165.283F,
	-255.615F,
	3.17383F,
	78.3691F,
	-165.771F,
	-143.555F,
	-87.4023F,
	-51.7578F,
	-136.230F,
	59.3262F,
	157.715F,
	116.943F,
	118.652F,
	83.4961F,
	154.785F,
	129.883F,
	26.1230F,
	195.801F,
	80.8105F,
	33.2031F,
	-27.3438F,
	-97.1680F,
	-251.709F,
	-69.8242F,
	-79.5898F,
	-172.119F,
	70.3125F,
	66.4063F,
	317.139F,
	279.297F,
	287.598F,
	209.961F,
	-103.271F,
	29.5410F,
	-93.9941F,
	-36.1328F,
	-72.0215F,
	-73.7305F,
	-203.613F,
	-199.951F,
	3.90625F,
	-5.85938F,
	-49.0723F,
	-116.211F,
	135.498F,
	22.2168F,
	-59.8145F,
	71.7773F,
	-9.27734F,
	-92.5293F,
	-234.863F,
	-298.096F,
	-290.771F,
	-370.605F,
	-66.6504F,
	-96.4355F,
	-95.2148F,
	-247.314F,
	-157.471F,
	139.893F,
	-449.951F,
	-251.465F,
	123.291F,
	114.258F,
	181.641F,
	231.201F,
	148.682F,
	120.361F,
	-168.213F,
	-286.133F,
	-153.320F,
	-32.9590F,
	-250.488F,
	47.6074F,
	100.342F,
	47.8516F,
	386.230F,
	280.029F,
	140.381F,
	82.2754F,
	-302.490F,
	-189.697F,
	-158.203F,
	-34.6680F,
	145.264F,
	201.416F,
	236.084F,
	179.443F,
	-294.434F,
	-236.816F,
	-19.7754F,
	-83.4961F,
	-181.885F,
	3.17383F,
	-17.5781F,
	91.5527F,
	110.840F,
	4.63867F,
	343.506F,
	224.854F,
	-402.100F,
	-41.9922F,
	210.205F,
	137.207F,
	226.563F,
	375.244F,
	259.521F,
	180.664F,
	-603.516F,
	-232.422F,
	64.4531F,
	20.0195F,
	-122.559F,
	-235.596F,
	-325.684F,
	30.0293F,
	211.670F,
	301.758F,
	130.371F,
	41.7480F,
	-566.406F,
	-112.305F,
	190.430F,
	88.6230F,
	-290.527F,
	-150.635F,
	61.5234F,
	-14.8926F,
	-42.4805F,
	8.30078F,
	246.826F,
	192.383F,
	-569.580F,
	60.3027F,
	103.271F,
	37.3535F,
	-3.90625F,
	-86.6699F,
	63.9648F,
	109.619F,
	-384.766F,
	-261.963F,
	-132.813F,
	-90.5762F,
	-150.146F,
	-74.4629F,
	256.592F,
	196.533F,
	167.725F,
	128.906F,
	1.46484F,
	-44.4336F,
	228.271F,
	213.623F,
	244.629F,
	197.510F,
	48.5840F,
	62.7441F,
	30.7617F,
	18.5547F,
	-142.578F,
	-277.832F,
	146.240F,
	135.742F,
	-269.775F,
	-339.600F,
	-388.428F,
	-126.709F,
	-238.525F,
	-323.486F,
	26.3672F,
	84.7168F,
	-176.270F,
	-238.037F,
	89.1113F,
	24.6582F,
	-35.4004F,
	166.260F,
	60.7910F,
	-37.3535F,
	0.000000F,
	-81.5430F,
	-139.160F,
	38.8184F,
	100.586F,
	69.5801F,
	-82.0313F,
	-150.635F,
	-232.666F,
	-235.840F,
	216.553F,
	168.213F,
	-305.420F,
	20.5078F,
	-45.1660F,
	-97.1680F,
	-144.531F,
	105.713F,
	254.883F,
	159.424F,
	20.7520F,
	80.3223F,
	-9.76563F,
	88.1348F,
	-105.713F,
	-172.119F,
	113.770F,
	140.137F,
	-37.5977F,
	159.668F,
	144.531F,
	70.8008F,
	-40.7715F,
	17.5781F,
	85.2051F,
	42.7246F,
	164.551F,
	72.5098F,
	238.525F,
	175.781F,
	301.514F,
	293.945F,
	184.814F,
	119.141F,
	-97.6563F,
	-65.6738F,
	131.348F,
	90.8203F,
	-329.590F,
	-338.623F,
	-291.504F,
	-22.2168F,
	308.105F,
	213.867F,
	189.209F,
	170.898F,
	-146.240F,
	-9.27734F,
	-104.980F,
	-176.270F,
	482.422F,
	397.949F,
	241.943F,
	148.438F,
	27.0996F,
	67.3828F,
	-55.1758F,
	-23.4375F,
	-231.201F,
	-94.7266F,
	-2.68555F,
	-1.70898F,
	-73.9746F,
	-129.639F,
	-204.834F,
	82.5195F,
	423.340F,
	417.480F,
	343.018F,
	247.314F,
	-125.977F,
	-208.740F,
	-157.471F,
	51.2695F,
	-167.969F,
	-101.563F,
	125.244F,
	56.1523F,
	-200.684F,
	-155.518F,
	-279.785F,
	-78.1250F,
	-232.422F,
	-160.645F,
	-169.434F,
	44.6777F,
	-27.8320F,
	-152.100F,
	199.707F,
	164.551F,
	-46.6309F,
	-49.8047F,
	178.467F,
	155.029F,
	12.4512F,
	298.096F,
	215.576F,
	140.625F,
	-232.910F,
	-105.225F,
	201.660F,
	145.996F,
	-83.4961F,
	-184.326F,
	-219.727F,
	-99.3652F,
	-274.902F,
	-86.4258F,
	-50.2930F,
	-125.000F,
	-133.545F,
	-197.754F,
	-87.1582F,
	-151.367F,
	16.1133F,
	125.732F,
	-17.8223F,
	-100.098F,
	-212.891F,
	-230.713F,
	-352.539F,
	-299.561F,
	46.6309F,
	-4.15039F,
	-132.813F,
	-56.3965F,
	-375.977F,
	-132.813F,
	-219.971F,
	-216.309F

};
#define MR795_1_SIZE  512

/* first codebook for MR795 */
__device__ static const Float32 mr795_1_lsf[] =
{
	-217.285F,
	-378.418F,
	-620.361F,
	-199.951F,
	-236.816F,
	42.7246F,
	-201.660F,
	-301.270F,
	-186.035F,
	-146.240F,
	-5.37109F,
	154.785F,
	-197.998F,
	-240.967F,
	-220.215F,
	-78.8574F,
	49.5605F,
	6.34766F,
	-93.5059F,
	-57.3730F,
	-190.674F,
	-97.4121F,
	308.105F,
	221.191F,
	-227.539F,
	-341.553F,
	-336.914F,
	-152.344F,
	22.7051F,
	21.2402F,
	-101.074F,
	-131.592F,
	-168.701F,
	9.03320F,
	154.541F,
	124.512F,
	-94.4824F,
	-116.211F,
	-324.707F,
	97.4121F,
	16.1133F,
	64.2090F,
	-99.3652F,
	-11.9629F,
	-81.7871F,
	-101.807F,
	254.150F,
	455.322F,
	-190.186F,
	-265.869F,
	-351.563F,
	-182.129F,
	-209.473F,
	203.125F,
	-141.846F,
	-185.303F,
	-90.5762F,
	-164.307F,
	-123.535F,
	509.766F,
	-136.719F,
	-154.785F,
	-287.842F,
	66.1621F,
	58.8379F,
	3.41797F,
	-106.934F,
	-59.5703F,
	-96.9238F,
	113.037F,
	293.457F,
	255.615F,
	-147.949F,
	-194.580F,
	-351.074F,
	-12.4512F,
	-78.8574F,
	117.432F,
	-54.6875F,
	-142.578F,
	-128.662F,
	120.605F,
	215.088F,
	166.504F,
	-105.713F,
	-74.7070F,
	-244.629F,
	135.254F,
	160.889F,
	54.1992F,
	41.7480F,
	-39.0625F,
	-86.1816F,
	166.260F,
	438.965F,
	382.080F,
	-208.008F,
	-288.330F,
	-413.818F,
	-82.0313F,
	-162.598F,
	27.8320F,
	-141.846F,
	-184.570F,
	-181.641F,
	-47.6074F,
	91.5527F,
	121.338F,
	-113.525F,
	-196.289F,
	-268.066F,
	37.5977F,
	68.8477F,
	-31.9824F,
	-12.2070F,
	-46.6309F,
	-175.537F,
	78.8574F,
	178.711F,
	376.465F,
	-176.270F,
	-199.951F,
	-342.773F,
	25.6348F,
	-61.0352F,
	45.1660F,
	-43.4570F,
	-122.559F,
	-181.152F,
	78.3691F,
	124.512F,
	271.240F,
	-78.8574F,
	-138.428F,
	-235.840F,
	31.0059F,
	118.164F,
	82.5195F,
	-39.0625F,
	12.6953F,
	-82.5195F,
	178.711F,
	333.740F,
	379.395F,
	-152.832F,
	-195.801F,
	-414.063F,
	-69.8242F,
	-143.066F,
	165.039F,
	-169.678F,
	-83.7402F,
	-90.3320F,
	-119.629F,
	72.0215F,
	462.158F,
	-153.809F,
	-140.137F,
	-247.559F,
	-19.5313F,
	157.471F,
	-16.8457F,
	-1.46484F,
	-77.6367F,
	-88.8672F,
	190.918F,
	354.004F,
	253.418F,
	-76.4160F,
	-178.955F,
	-340.576F,
	29.2969F,
	14.6484F,
	116.455F,
	-64.4531F,
	-142.822F,
	-30.0293F,
	173.584F,
	303.955F,
	154.541F,
	-22.2168F,
	-86.6699F,
	-248.047F,
	188.232F,
	185.059F,
	63.7207F,
	61.7676F,
	19.7754F,
	-115.723F,
	227.051F,
	540.771F,
	419.922F,
	-197.266F,
	-268.311F,
	-469.971F,
	-136.719F,
	-190.918F,
	41.2598F,
	-196.289F,
	-262.207F,
	-45.8984F,
	-152.832F,
	-13.4277F,
	343.018F,
	-169.434F,
	-174.805F,
	-291.504F,
	-161.133F,
	86.4258F,
	80.3223F,
	-125.488F,
	-13.4277F,
	-132.568F,
	89.3555F,
	252.197F,
	288.574F,
	-160.645F,
	-234.131F,
	-331.299F,
	-13.4277F,
	-44.9219F,
	22.7051F,
	-147.705F,
	-69.8242F,
	-161.621F,
	98.6328F,
	109.619F,
	201.904F,
	-69.8242F,
	-85.4492F,
	-308.350F,
	153.320F,
	74.7070F,
	55.4199F,
	-3.90625F,
	35.8887F,
	-152.100F,
	45.4102F,
	225.342F,
	523.926F,
	-164.551F,
	-217.285F,
	-392.090F,
	-108.154F,
	-55.6641F,
	82.7637F,
	-90.0879F,
	-192.871F,
	-99.8535F,
	56.3965F,
	20.9961F,
	358.643F,
	-109.375F,
	-141.846F,
	-259.033F,
	145.020F,
	109.863F,
	-43.2129F,
	-30.2734F,
	-41.5039F,
	-109.131F,
	163.818F,
	282.959F,
	342.773F,
	-116.211F,
	-162.842F,
	-368.896F,
	-18.7988F,
	-33.6914F,
	174.805F,
	-43.2129F,
	-90.8203F,
	-93.0176F,
	110.107F,
	228.027F,
	223.389F,
	-61.0352F,
	-105.469F,
	-200.684F,
	66.4063F,
	202.148F,
	108.887F,
	6.34766F,
	4.63867F,
	-7.56836F,
	170.410F,
	413.086F,
	529.297F,
	-157.715F,
	-238.525F,
	-469.727F,
	-43.7012F,
	-115.479F,
	65.4297F,
	-92.5293F,
	-181.885F,
	-168.701F,
	2.68555F,
	31.0059F,
	252.197F,
	-119.141F,
	-223.877F,
	-201.416F,
	14.8926F,
	78.8574F,
	32.9590F,
	35.8887F,
	-35.4004F,
	-167.480F,
	167.236F,
	191.895F,
	410.645F,
	-123.535F,
	-207.031F,
	-316.650F,
	8.54492F,
	21.9727F,
	54.1992F,
	-5.61523F,
	-84.4727F,
	-163.574F,
	111.084F,
	144.287F,
	314.209F,
	-49.5605F,
	-144.775F,
	-265.137F,
	159.180F,
	85.9375F,
	106.689F,
	9.52148F,
	15.3809F,
	-111.572F,
	205.322F,
	308.838F,
	513.916F,
	-126.953F,
	-215.332F,
	-386.719F,
	-80.0781F,
	-173.584F,
	346.924F,
	-145.508F,
	-83.4961F,
	-17.0898F,
	51.0254F,
	42.2363F,
	470.703F,
	-103.271F,
	-145.996F,
	-224.854F,
	102.783F,
	147.705F,
	-9.27734F,
	-0.488281F,
	-59.8145F,
	-31.0059F,
	218.750F,
	480.713F,
	277.100F,
	-92.5293F,
	-126.465F,
	-385.498F,
	42.2363F,
	28.8086F,
	183.838F,
	-13.4277F,
	-93.0176F,
	-12.6953F,
	240.479F,
	249.268F,
	183.838F,
	-0.488281F,
	-71.0449F,
	-217.529F,
	183.838F,
	242.188F,
	103.271F,
	64.4531F,
	31.9824F,
	-47.8516F,
	218.506F,
	555.176F,
	620.850F,
	-155.029F,
	-265.625F,
	-610.107F,
	-129.150F,
	-239.746F,
	128.418F,
	-186.523F,
	-202.637F,
	-133.789F,
	-106.445F,
	77.1484F,
	146.240F,
	-164.795F,
	-229.492F,
	-182.129F,
	-13.9160F,
	57.6172F,
	-2.68555F,
	-49.0723F,
	-19.7754F,
	-194.824F,
	3.90625F,
	206.299F,
	380.371F,
	-179.932F,
	-240.479F,
	-295.898F,
	-114.258F,
	4.15039F,
	70.8008F,
	-68.1152F,
	-142.578F,
	-170.898F,
	44.6777F,
	200.684F,
	172.119F,
	-64.6973F,
	-120.117F,
	-289.795F,
	102.783F,
	37.1094F,
	114.258F,
	-95.2148F,
	40.5273F,
	-65.4297F,
	9.52148F,
	378.418F,
	456.055F,
	-155.029F,
	-235.840F,
	-383.545F,
	-110.596F,
	-120.117F,
	222.168F,
	-69.3359F,
	-250.732F,
	-18.3105F,
	-44.1895F,
	-32.4707F,
	452.148F,
	-108.643F,
	-152.344F,
	-286.621F,
	102.539F,
	89.5996F,
	-11.9629F,
	-94.9707F,
	-51.7578F,
	-41.2598F,
	172.607F,
	261.963F,
	294.922F,
	-131.592F,
	-173.340F,
	-353.760F,
	20.2637F,
	-39.7949F,
	118.164F,
	-57.6172F,
	-132.568F,
	-86.6699F,
	82.5195F,
	286.865F,
	198.730F,
	-60.0586F,
	-75.4395F,
	-233.887F,
	147.949F,
	185.547F,
	14.6484F,
	40.5273F,
	-1.95313F,
	-39.7949F,
	-74.7070F,
	451.416F,
	625.732F,
	-182.373F,
	-250.244F,
	-435.303F,
	-102.295F,
	-108.887F,
	51.0254F,
	-175.293F,
	-138.184F,
	-130.371F,
	-123.535F,
	169.189F,
	209.229F,
	-113.037F,
	-170.166F,
	-264.160F,
	79.3457F,
	105.225F,
	-50.2930F,
	-3.66211F,
	-1.95313F,
	-186.279F,
	133.057F,
	224.365F,
	370.605F,
	-149.170F,
	-191.162F,
	-320.557F,
	62.5000F,
	-13.4277F,
	50.7813F,
	-40.2832F,
	-84.9609F,
	-161.621F,
	78.3691F,
	166.016F,
	227.051F,
	-79.5898F,
	-104.736F,
	-232.178F,
	118.164F,
	108.887F,
	139.160F,
	-48.0957F,
	17.5781F,
	-17.8223F,
	221.924F,
	355.225F,
	425.049F,
	-137.451F,
	-179.932F,
	-481.934F,
	-30.2734F,
	-101.563F,
	175.293F,
	-116.699F,
	-98.6328F,
	-76.6602F,
	-3.90625F,
	108.887F,
	399.414F,
	-134.521F,
	-131.104F,
	-183.105F,
	-14.1602F,
	155.762F,
	52.2461F,
	13.4277F,
	-45.1660F,
	-66.1621F,
	280.273F,
	317.627F,
	295.898F,
	-117.920F,
	-163.818F,
	-308.594F,
	28.5645F,
	69.5801F,
	132.568F,
	-49.8047F,
	-95.4590F,
	-27.0996F,
	125.244F,
	375.488F,
	208.496F,
	-27.8320F,
	-46.3867F,
	-238.770F,
	214.111F,
	145.264F,
	113.281F,
	63.4766F,
	63.4766F,
	-75.9277F,
	182.617F,
	557.373F,
	541.016F,
	-126.221F,
	-230.713F,
	-530.029F,
	-79.5898F,
	-172.852F,
	92.2852F,
	-198.242F,
	-168.701F,
	-56.6406F,
	-136.719F,
	167.725F,
	343.994F,
	-178.711F,
	-168.457F,
	-204.102F,
	-87.6465F,
	157.471F,
	94.2383F,
	-64.6973F,
	15.1367F,
	-165.527F,
	35.4004F,
	401.367F,
	294.922F,
	-135.498F,
	-241.211F,
	-301.025F,
	-19.0430F,
	3.41797F,
	27.8320F,
	-79.8340F,
	-87.4023F,
	-119.385F,
	95.7031F,
	165.283F,
	170.166F,
	-49.0723F,
	-57.6172F,
	-278.320F,
	169.189F,
	109.619F,
	43.4570F,
	-59.3262F,
	62.5000F,
	-105.713F,
	149.170F,
	338.135F,
	599.609F,
	-149.414F,
	-219.971F,
	-357.422F,
	-74.9512F,
	-4.15039F,
	121.826F,
	-76.9043F,
	-162.842F,
	-62.0117F,
	62.5000F,
	104.492F,
	357.178F,
	-118.652F,
	-103.027F,
	-257.813F,
	159.912F,
	90.3320F,
	4.39453F,
	-24.9023F,
	-45.1660F,
	-67.3828F,
	184.326F,
	385.254F,
	325.928F,
	-119.141F,
	-147.217F,
	-346.191F,
	44.4336F,
	-22.7051F,
	212.402F,
	-17.8223F,
	-111.816F,
	-84.9609F,
	203.857F,
	210.449F,
	233.643F,
	-68.8477F,
	-81.2988F,
	-182.129F,
	133.545F,
	204.834F,
	104.492F,
	66.6504F,
	-21.7285F,
	3.17383F,
	229.492F,
	416.992F,
	628.906F,
	-102.051F,
	-264.648F,
	-429.199F,
	-10.7422F,
	-87.4023F,
	63.2324F,
	-121.338F,
	-156.982F,
	-136.719F,
	24.1699F,
	135.986F,
	234.619F,
	-102.783F,
	-187.012F,
	-223.877F,
	72.0215F,
	79.5898F,
	44.9219F,
	42.7246F,
	3.66211F,
	-152.832F,
	129.883F,
	214.355F,
	483.643F,
	-108.154F,
	-187.500F,
	-311.279F,
	53.9551F,
	38.0859F,
	65.4297F,
	9.52148F,
	-88.6230F,
	-123.291F,
	169.678F,
	188.477F,
	278.320F,
	-39.5508F,
	-112.061F,
	-222.656F,
	173.096F,
	108.398F,
	160.645F,
	6.10352F,
	73.9746F,
	-76.1719F,
	309.570F,
	344.238F,
	418.701F,
	-72.5098F,
	-187.012F,
	-448.242F,
	-64.2090F,
	-26.3672F,
	261.230F,
	-99.1211F,
	-3.17383F,
	-31.4941F,
	13.9160F,
	106.934F,
	667.480F,
	-91.3086F,
	-118.896F,
	-203.857F,
	74.2188F,
	169.922F,
	40.0391F,
	25.3906F,
	-57.3730F,
	1.22070F,
	393.311F,
	463.867F,
	341.553F,
	-55.9082F,
	-142.090F,
	-323.486F,
	98.8770F,
	46.8750F,
	199.463F,
	-21.2402F,
	-106.934F,
	27.0996F,
	250.977F,
	292.725F,
	242.432F,
	16.6016F,
	-42.7246F,
	-228.027F,
	252.197F,
	272.705F,
	110.107F,
	116.699F,
	48.8281F,
	-60.5469F,
	519.287F,
	658.203F,
	498.535F,
	-203.857F,
	-322.998F,
	-520.264F,
	-195.068F,
	-168.945F,
	113.770F,
	-198.242F,
	-251.953F,
	-114.502F,
	-151.855F,
	70.3125F,
	224.609F,
	-171.143F,
	-205.322F,
	-261.230F,
	-100.342F,
	125.000F,
	1.95313F,
	-95.2148F,
	-22.2168F,
	-181.641F,
	-7.32422F,
	254.639F,
	283.447F,
	-200.684F,
	-280.273F,
	-282.227F,
	-71.7773F,
	-11.2305F,
	26.8555F,
	-100.342F,
	-91.3086F,
	-165.527F,
	52.2461F,
	129.639F,
	163.086F,
	-99.1211F,
	-102.539F,
	-291.504F,
	118.896F,
	56.6406F,
	73.9746F,
	-77.6367F,
	22.2168F,
	-115.234F,
	30.0293F,
	300.781F,
	596.924F,
	-176.270F,
	-232.422F,
	-364.990F,
	-180.176F,
	-164.795F,
	325.195F,
	-132.568F,
	-147.949F,
	-51.5137F,
	-23.1934F,
	-23.9258F,
	368.164F,
	-134.033F,
	-125.488F,
	-291.260F,
	115.479F,
	51.5137F,
	17.8223F,
	-70.3125F,
	-27.3438F,
	-94.9707F,
	131.104F,
	325.195F,
	307.129F,
	-138.428F,
	-184.326F,
	-377.197F,
	17.3340F,
	-69.0918F,
	154.297F,
	-41.5039F,
	-117.432F,
	-120.361F,
	166.260F,
	244.629F,
	199.463F,
	-86.9141F,
	-80.8105F,
	-214.111F,
	102.295F,
	172.363F,
	84.4727F,
	58.8379F,
	-8.30078F,
	-79.5898F,
	92.0410F,
	476.074F,
	459.717F,
	-177.490F,
	-262.451F,
	-396.729F,
	-56.8848F,
	-132.568F,
	28.3203F,
	-127.930F,
	-196.777F,
	-142.822F,
	-17.8223F,
	116.699F,
	177.979F,
	-70.3125F,
	-225.830F,
	-279.053F,
	42.2363F,
	109.131F,
	-12.6953F,
	16.6016F,
	-55.9082F,
	-147.949F,
	109.619F,
	129.150F,
	438.721F,
	-144.287F,
	-213.623F,
	-332.764F,
	44.6777F,
	-35.1563F,
	79.1016F,
	-25.1465F,
	-110.352F,
	-162.598F,
	152.100F,
	119.141F,
	287.109F,
	-58.1055F,
	-124.756F,
	-245.117F,
	79.5898F,
	134.766F,
	111.816F,
	33.2031F,
	26.3672F,
	-77.8809F,
	152.832F,
	327.881F,
	459.717F,
	-119.629F,
	-157.715F,
	-422.363F,
	-45.4102F,
	-109.619F,
	240.234F,
	-180.176F,
	-18.5547F,
	-41.5039F,
	-134.277F,
	184.326F,
	625.000F,
	-121.094F,
	-124.512F,
	-231.201F,
	51.2695F,
	169.434F,
	-12.6953F,
	20.5078F,
	-78.6133F,
	-48.5840F,
	266.113F,
	396.729F,
	298.828F,
	-91.7969F,
	-147.217F,
	-340.820F,
	83.7402F,
	18.0664F,
	154.297F,
	-42.7246F,
	-122.559F,
	-7.81250F,
	237.305F,
	325.195F,
	179.199F,
	12.6953F,
	-72.0215F,
	-271.729F,
	260.010F,
	224.121F,
	39.0625F,
	95.9473F,
	26.1230F,
	-96.9238F,
	296.387F,
	646.729F,
	425.049F,
	-154.297F,
	-293.213F,
	-461.670F,
	-175.537F,
	-67.6270F,
	86.1816F,
	-158.936F,
	-214.844F,
	-29.7852F,
	-51.5137F,
	51.0254F,
	326.660F,
	-137.207F,
	-174.316F,
	-258.545F,
	-50.7813F,
	94.7266F,
	38.8184F,
	-78.1250F,
	-14.8926F,
	-134.521F,
	71.5332F,
	266.602F,
	352.295F,
	-158.203F,
	-211.182F,
	-305.908F,
	-11.9629F,
	-34.9121F,
	74.4629F,
	-97.9004F,
	-55.4199F,
	-142.822F,
	136.963F,
	129.883F,
	226.318F,
	-28.5645F,
	-108.154F,
	-290.039F,
	123.779F,
	106.445F,
	71.2891F,
	-19.2871F,
	56.8848F,
	-111.816F,
	163.818F,
	250.244F,
	584.961F,
	-154.541F,
	-205.566F,
	-372.314F,
	-75.1953F,
	-69.8242F,
	156.250F,
	-91.0645F,
	-151.611F,
	-99.3652F,
	102.051F,
	61.7676F,
	318.604F,
	-76.9043F,
	-141.846F,
	-277.588F,
	139.648F,
	167.236F,
	-68.6035F,
	14.8926F,
	-16.6016F,
	-90.5762F,
	241.943F,
	268.799F,
	365.723F,
	-120.361F,
	-166.748F,
	-332.520F,
	-11.4746F,
	40.0391F,
	171.875F,
	-62.5000F,
	-76.6602F,
	-65.4297F,
	154.053F,
	231.689F,
	256.836F,
	-28.8086F,
	-84.9609F,
	-203.369F,
	16.6016F,
	288.086F,
	138.672F,
	37.1094F,
	28.5645F,
	8.30078F,
	271.729F,
	464.355F,
	546.631F,
	-146.729F,
	-234.131F,
	-416.504F,
	-34.9121F,
	-119.385F,
	117.188F,
	-81.0547F,
	-159.912F,
	-140.137F,
	13.1836F,
	86.1816F,
	291.016F,
	-112.793F,
	-159.180F,
	-194.336F,
	36.6211F,
	134.033F,
	27.3438F,
	47.6074F,
	-27.0996F,
	-125.732F,
	165.771F,
	270.508F,
	402.100F,
	-136.230F,
	-182.861F,
	-297.119F,
	-2.19727F,
	66.4063F,
	83.2520F,
	-12.9395F,
	-64.6973F,
	-130.615F,
	119.385F,
	205.811F,
	316.895F,
	-29.2969F,
	-117.676F,
	-251.953F,
	154.297F,
	132.568F,
	99.6094F,
	43.7012F,
	74.7070F,
	-128.418F,
	274.414F,
	357.422F,
	547.852F,
	-101.807F,
	-191.895F,
	-381.348F,
	-54.6875F,
	-93.7500F,
	333.008F,
	-92.0410F,
	-112.061F,
	-6.10352F,
	93.9941F,
	119.385F,
	530.762F,
	-81.0547F,
	-158.936F,
	-202.393F,
	132.813F,
	135.010F,
	14.8926F,
	5.37109F,
	-27.5879F,
	-21.7285F,
	275.391F,
	421.143F,
	372.070F,
	-52.7344F,
	-91.0645F,
	-403.564F,
	39.3066F,
	77.1484F,
	221.680F,
	-40.2832F,
	-54.1992F,
	-16.3574F,
	332.520F,
	286.865F,
	192.627F,
	17.8223F,
	-61.5234F,
	-187.256F,
	180.176F,
	227.539F,
	150.391F,
	88.3789F,
	60.0586F,
	-30.7617F,
	192.139F,
	647.949F,
	739.014F,
	-168.701F,
	-270.020F,
	-534.668F,
	-137.939F,
	-143.555F,
	127.930F,
	-144.043F,
	-239.014F,
	-119.629F,
	-64.2090F,
	96.9238F,
	239.746F,
	-140.869F,
	-204.346F,
	-230.713F,
	-5.37109F,
	106.201F,
	-11.9629F,
	-46.3867F,
	-28.8086F,
	-153.564F,
	-21.4844F,
	302.734F,
	369.385F,
	-155.273F,
	-256.592F,
	-248.779F,
	-71.0449F,
	46.1426F,
	63.2324F,
	-62.7441F,
	-114.746F,
	-153.564F,
	35.4004F,
	230.713F,
	218.262F,
	-79.5898F,
	-88.8672F,
	-267.090F,
	132.568F,
	63.4766F,
	153.809F,
	-49.3164F,
	46.1426F,
	-51.0254F,
	87.1582F,
	336.670F,
	510.498F,
	-138.916F,
	-262.451F,
	-353.760F,
	-174.316F,
	-58.3496F,
	224.365F,
	-102.539F,
	-172.119F,
	-20.5078F,
	-26.6113F,
	-27.8320F,
	587.646F,
	-100.830F,
	-129.150F,
	-287.354F,
	117.676F,
	89.8438F,
	31.9824F,
	-45.4102F,
	-17.5781F,
	-31.9824F,
	210.205F,
	306.396F,
	297.852F,
	-149.170F,
	-160.645F,
	-327.393F,
	55.4199F,
	-29.5410F,
	154.053F,
	-42.9688F,
	-119.385F,
	-53.2227F,
	181.885F,
	286.865F,
	233.643F,
	-78.3691F,
	-36.1328F,
	-228.516F,
	163.818F,
	235.840F,
	52.7344F,
	83.0078F,
	-0.732422F,
	-34.9121F,
	114.502F,
	451.172F,
	594.971F,
	-177.979F,
	-234.619F,
	-410.889F,
	-52.0020F,
	-62.0117F,
	78.3691F,
	-124.756F,
	-106.934F,
	-127.197F,
	-30.7617F,
	177.002F,
	220.459F,
	-83.0078F,
	-167.236F,
	-251.953F,
	77.1484F,
	117.188F,
	4.88281F,
	5.61523F,
	-21.7285F,
	-134.521F,
	86.1816F,
	256.592F,
	436.768F,
	-132.813F,
	-184.814F,
	-333.008F,
	72.7539F,
	-6.10352F,
	106.445F,
	-24.4141F,
	-95.7031F,
	-126.709F,
	114.014F,
	184.082F,
	263.184F,
	-51.2695F,
	-97.1680F,
	-263.184F,
	151.367F,
	160.645F,
	153.809F,
	8.05664F,
	35.8887F,
	-43.4570F,
	224.854F,
	411.865F,
	468.994F,
	-79.3457F,
	-128.906F,
	-482.910F,
	0.488281F,
	-69.5801F,
	222.168F,
	-90.5762F,
	-119.629F,
	-56.1523F,
	0.000000F,
	145.752F,
	490.723F,
	-121.094F,
	-96.4355F,
	-203.613F,
	9.03320F,
	230.713F,
	59.8145F,
	44.1895F,
	-39.0625F,
	-35.1563F,
	361.572F,
	335.205F,
	331.299F,
	-86.6699F,
	-146.729F,
	-310.059F,
	72.7539F,
	78.6133F,
	164.063F,
	-47.1191F,
	-82.0313F,
	18.7988F,
	265.869F,
	374.268F,
	225.098F,
	43.2129F,
	-9.52148F,
	-274.658F,
	243.164F,
	190.674F,
	130.859F,
	111.328F,
	89.3555F,
	-105.469F,
	345.459F,
	595.703F,
	556.396F,
	-113.770F,
	-185.059F,
	-567.627F,
	-73.9746F,
	-124.268F,
	94.4824F,
	-177.490F,
	-135.986F,
	16.1133F,
	-35.4004F,
	156.982F,
	304.688F,
	-132.813F,
	-165.039F,
	-223.633F,
	-54.9316F,
	210.449F,
	143.555F,
	-37.1094F,
	9.76563F,
	-130.127F,
	103.271F,
	347.412F,
	380.371F,
	-139.648F,
	-205.811F,
	-279.541F,
	-31.2500F,
	20.7520F,
	112.549F,
	-58.1055F,
	-62.7441F,
	-142.578F,
	147.705F,
	182.617F,
	210.205F,
	5.85938F,
	-49.3164F,
	-343.994F,
	194.580F,
	118.896F,
	73.9746F,
	-44.1895F,
	88.8672F,
	-44.4336F,
	150.391F,
	336.426F,
	718.262F,
	-120.605F,
	-208.008F,
	-351.807F,
	-71.2891F,
	14.8926F,
	198.242F,
	-20.5078F,
	-176.514F,
	-44.4336F,
	135.498F,
	129.883F,
	367.676F,
	-89.1113F,
	-120.361F,
	-258.057F,
	200.684F,
	143.555F,
	2.68555F,
	-3.41797F,
	-4.39453F,
	-56.1523F,
	244.385F,
	342.041F,
	354.248F,
	-115.723F,
	-138.916F,
	-315.430F,
	73.7305F,
	15.1367F,
	259.277F,
	-17.0898F,
	-91.7969F,
	-54.1992F,
	239.746F,
	237.793F,
	280.518F,
	-47.8516F,
	-57.1289F,
	-194.092F,
	116.943F,
	268.066F,
	121.826F,
	88.3789F,
	14.1602F,
	17.0898F,
	280.029F,
	505.127F,
	697.510F,
	-118.896F,
	-214.355F,
	-445.313F,
	17.8223F,
	-70.3125F,
	84.9609F,
	-87.4023F,
	-122.070F,
	-124.023F,
	48.5840F,
	176.025F,
	303.223F,
	-19.0430F,
	-170.166F,
	-194.092F,
	88.1348F,
	130.859F,
	47.8516F,
	91.3086F,
	26.8555F,
	-179.443F,
	206.787F,
	256.592F,
	462.891F,
	-89.3555F,
	-174.072F,
	-288.574F,
	76.9043F,
	78.1250F,
	104.736F,
	17.5781F,
	-52.4902F,
	-109.863F,
	185.303F,
	216.309F,
	332.764F,
	-7.32422F,
	-104.492F,
	-203.613F,
	210.205F,
	153.076F,
	194.336F,
	28.8086F,
	114.258F,
	-68.1152F,
	330.811F,
	459.717F,
	462.158F,
	-45.8984F,
	-156.738F,
	-393.555F,
	15.3809F,
	-42.7246F,
	292.480F,
	-102.051F,
	-51.5137F,
	12.4512F,
	101.074F,
	143.311F,
	635.010F,
	-57.1289F,
	-135.986F,
	-209.473F,
	103.516F,
	217.041F,
	54.1992F,
	33.2031F,
	-24.6582F,
	20.2637F,
	344.971F,
	556.152F,
	337.646F,
	-20.5078F,
	-108.643F,
	-339.111F,
	101.074F,
	76.4160F,
	255.127F,
	7.08008F,
	-83.7402F,
	15.8691F,
	378.906F,
	402.100F,
	239.258F,
	44.6777F,
	-22.2168F,
	-202.393F,
	310.791F,
	344.971F,
	87.8906F,
	135.010F,
	66.4063F,
	-26.1230F,
	387.451F,
	768.799F,
	635.498F

};

/*
* Quantization tables for split_MQ of 2 sets of LSFs in a 20 ms frame.
*/
#define DICO1_SIZE_5 128
#define DICO2_SIZE_5 256
#define DICO3_SIZE_5 256
#define DICO4_SIZE_5 256
#define DICO5_SIZE_5 64
__device__ static const Float32 dico1_lsf_5[DICO1_SIZE_5 * 4] =
{
	-110.107F,
	-260.010F,
	-129.150F,
	-318.604F,
	-109.863F,
	-184.570F,
	-121.338F,
	-210.693F,
	-93.7500F,
	-151.123F,
	-100.830F,
	-163.330F,
	-77.3926F,
	-131.348F,
	-80.8105F,
	-135.742F,
	-101.074F,
	-124.023F,
	-103.516F,
	-92.2852F,
	-66.8945F,
	-79.1016F,
	-105.957F,
	-149.902F,
	-55.1758F,
	-122.070F,
	-56.6406F,
	-125.488F,
	-64.2090F,
	-92.0410F,
	-72.7539F,
	-100.098F,
	-36.8652F,
	-173.340F,
	-42.4805F,
	-199.707F,
	-36.3770F,
	-100.586F,
	-38.0859F,
	-104.736F,
	-70.3125F,
	-112.793F,
	-45.4102F,
	-49.5605F,
	-41.5039F,
	-73.7305F,
	-46.6309F,
	-78.3691F,
	-31.9824F,
	-35.8887F,
	-72.5098F,
	-96.4355F,
	-55.6641F,
	-52.2461F,
	-59.8145F,
	-46.8750F,
	-16.3574F,
	-77.1484F,
	-17.3340F,
	-79.8340F,
	-25.3906F,
	-50.0488F,
	-22.9492F,
	-44.6777F,
	-34.9121F,
	-9.27734F,
	-47.1191F,
	-23.1934F,
	3.90625F,
	-18.5547F,
	-30.2734F,
	-60.5469F,
	5.61523F,
	-57.8613F,
	5.85938F,
	-59.5703F,
	4.39453F,
	-33.2031F,
	10.7422F,
	-27.0996F,
	-8.05664F,
	-5.85938F,
	-6.10352F,
	0.000000F,
	36.3770F,
	4.63867F,
	5.61523F,
	-34.9121F,
	38.5742F,
	-41.2598F,
	42.4805F,
	-44.1895F,
	32.4707F,
	-13.4277F,
	40.2832F,
	-6.34766F,
	27.0996F,
	20.5078F,
	23.9258F,
	18.3105F,
	21.2402F,
	44.6777F,
	-28.0762F,
	-2.68555F,
	-1.95313F,
	31.7383F,
	2.68555F,
	41.5039F,
	62.0117F,
	18.7988F,
	50.0488F,
	4.15039F,
	44.6777F,
	27.3438F,
	63.9648F,
	47.3633F,
	49.3164F,
	70.0684F,
	23.1934F,
	46.1426F,
	-10.2539F,
	-25.6348F,
	57.1289F,
	43.7012F,
	9.52148F,
	45.4102F,
	39.7949F,
	84.2285F,
	81.0547F,
	48.5840F,
	72.9980F,
	39.3066F,
	-13.1836F,
	69.5801F,
	-19.0430F,
	68.6035F,
	-32.4707F,
	34.4238F,
	-44.4336F,
	27.0996F,
	60.7910F,
	83.2520F,
	66.1621F,
	88.8672F,
	22.7051F,
	98.3887F,
	18.3105F,
	95.4590F,
	22.4609F,
	124.512F,
	-33.6914F,
	53.7109F,
	-45.1660F,
	-7.08008F,
	-8.30078F,
	88.1348F,
	-28.0762F,
	78.1250F,
	0.732422F,
	135.254F,
	24.1699F,
	69.8242F,
	53.2227F,
	144.287F,
	-59.8145F,
	99.1211F,
	-65.4297F,
	110.596F,
	0.000000F,
	141.602F,
	6.10352F,
	147.949F,
	67.1387F,
	129.883F,
	36.1328F,
	109.863F,
	-17.8223F,
	180.420F,
	-69.5801F,
	126.465F,
	-70.3125F,
	22.9492F,
	-49.5605F,
	164.551F,
	-34.1797F,
	-18.0664F,
	50.0488F,
	174.316F,
	-27.8320F,
	72.9980F,
	42.9688F,
	225.342F,
	44.4336F,
	135.986F,
	58.5938F,
	172.119F,
	-3.90625F,
	125.244F,
	118.408F,
	144.775F,
	71.5332F,
	93.7500F,
	110.107F,
	150.635F,
	-9.27734F,
	12.2070F,
	137.451F,
	129.150F,
	73.9746F,
	51.0254F,
	112.061F,
	88.6230F,
	105.713F,
	110.352F,
	109.863F,
	110.840F,
	89.5996F,
	147.949F,
	116.455F,
	180.908F,
	105.469F,
	86.1816F,
	89.8438F,
	65.1855F,
	88.1348F,
	174.805F,
	66.6504F,
	142.334F,
	110.596F,
	40.5273F,
	124.512F,
	41.9922F,
	49.0723F,
	153.564F,
	66.8945F,
	46.6309F,
	138.672F,
	156.006F,
	73.7305F,
	72.7539F,
	154.785F,
	94.4824F,
	156.982F,
	85.4492F,
	143.311F,
	136.719F,
	149.414F,
	137.939F,
	146.484F,
	192.383F,
	118.896F,
	164.063F,
	125.000F,
	247.803F,
	78.3691F,
	81.2988F,
	87.1582F,
	208.496F,
	-30.5176F,
	100.830F,
	115.723F,
	173.828F,
	4.15039F,
	-36.8652F,
	137.695F,
	69.5801F,
	65.9180F,
	-58.8379F,
	237.061F,
	217.041F,
	119.385F,
	53.7109F,
	124.512F,
	218.750F,
	134.033F,
	225.586F,
	79.8340F,
	201.416F,
	70.8008F,
	222.412F,
	131.836F,
	270.508F,
	38.5742F,
	196.533F,
	48.5840F,
	233.643F,
	124.756F,
	178.223F,
	24.4141F,
	213.379F,
	3.17383F,
	193.115F,
	106.201F,
	154.297F,
	165.039F,
	237.305F,
	60.7910F,
	219.727F,
	114.014F,
	297.363F,
	190.674F,
	262.207F,
	142.822F,
	191.650F,
	-5.61523F,
	163.330F,
	65.1855F,
	254.639F,
	151.123F,
	264.648F,
	150.146F,
	279.541F,
	151.855F,
	220.947F,
	223.633F,
	256.104F,
	19.5313F,
	80.8105F,
	142.578F,
	262.451F,
	21.7285F,
	156.006F,
	241.211F,
	234.619F,
	187.988F,
	175.781F,
	194.824F,
	170.654F,
	120.117F,
	109.131F,
	219.482F,
	153.076F,
	66.1621F,
	290.039F,
	177.002F,
	325.439F,
	21.2402F,
	147.217F,
	203.125F,
	391.357F,
	150.391F,
	275.146F,
	217.285F,
	367.432F,
	244.141F,
	282.227F,
	211.426F,
	246.338F,
	242.920F,
	201.904F,
	280.518F,
	209.473F,
	199.463F,
	354.004F,
	188.721F,
	322.266F,
	122.070F,
	339.111F,
	76.1719F,
	281.494F,
	-4.88281F,
	264.648F,
	15.6250F,
	313.232F,
	0.488281F,
	286.133F,
	97.4121F,
	456.299F,
	125.488F,
	416.504F,
	122.559F,
	399.414F,
	216.309F,
	371.582F,
	101.563F,
	146.484F,
	276.123F,
	329.590F,
	311.279F,
	339.355F,
	217.041F,
	438.232F,
	223.145F,
	431.152F,
	55.4199F,
	288.818F,
	305.176F,
	445.801F,
	123.291F,
	452.637F,
	224.365F,
	574.463F,
	-48.5840F,
	105.225F,
	37.1094F,
	423.584F,
	-52.0020F,
	-6.83594F,
	95.7031F,
	325.684F,
	-37.3535F,
	-12.6953F,
	238.770F,
	281.006F,
	-78.8574F,
	-97.6563F,
	198.486F,
	415.771F,
	-33.2031F,
	20.5078F,
	353.760F,
	491.943F,
	-80.8105F,
	-34.9121F,
	-33.4473F,
	291.016F,
	-62.5000F,
	130.371F,
	-38.3301F,
	251.709F,
	-74.9512F,
	-107.178F,
	132.324F,
	178.467F,
	-80.3223F,
	-102.539F,
	-23.6816F,
	150.391F,
	-88.3789F,
	-41.0156F,
	-78.6133F,
	89.3555F,
	-60.3027F,
	-26.8555F,
	-51.5137F,
	21.7285F,
	-47.8516F,
	-75.4395F,
	4.88281F,
	14.4043F,
	-88.8672F,
	-113.037F,
	-69.8242F,
	21.7285F,
	-82.0313F,
	42.7246F,
	-105.469F,
	34.4238F,
	-92.5293F,
	-46.3867F,
	-105.957F,
	-47.8516F,
	-19.2871F,
	36.6211F,
	-67.8711F,
	-55.4199F,
	-68.3594F,
	40.5273F,
	-135.498F,
	-103.027F,
	-37.8418F,
	132.080F,
	-89.3555F,
	13.1836F,
	-7.08008F,
	-20.2637F,
	-73.4863F,
	-188.965F,
	45.4102F,
	153.320F,
	-96.9238F,
	-64.4531F,
	59.0820F,
	71.5332F,
	-48.0957F,
	-142.822F,
	30.2734F,
	100.098F,
	12.9395F,
	-32.4707F,
	2.44141F,
	83.0078F,
	-139.160F,
	-260.010F,
	15.8691F,
	-108.887F,
	16.6016F,
	-120.361F,
	93.5059F,
	228.760F,
	-87.1582F,
	-173.584F,
	-87.6465F,
	-61.0352F,
	-165.283F,
	-260.742F,
	71.2891F,
	-6.34766F,
	88.6230F,
	1.46484F,
	148.193F,
	320.557F,
	-31.0059F,
	-2.44141F,
	369.385F,
	460.449F,
	174.072F,
	237.305F,
	358.643F,
	532.471F,
	352.295F,
	492.188F

};
__device__ static const Float32 dico2_lsf_5[DICO2_SIZE_5 * 4] =
{
	-398.193F,
	-390.625F,
	-438.477F,
	-559.082F,
	-250.732F,
	-432.129F,
	-268.555F,
	-494.385F,
	-311.768F,
	-338.867F,
	-333.740F,
	-374.512F,
	-231.201F,
	-356.689F,
	-237.305F,
	-372.070F,
	-243.896F,
	-298.340F,
	-249.023F,
	-286.133F,
	-198.975F,
	-240.967F,
	-242.188F,
	-334.717F,
	-296.875F,
	-245.605F,
	-314.697F,
	-267.090F,
	-181.641F,
	-309.570F,
	-184.326F,
	-315.674F,
	-210.449F,
	-225.342F,
	-220.947F,
	-240.234F,
	-165.527F,
	-256.592F,
	-167.236F,
	-256.348F,
	-265.381F,
	-240.479F,
	-259.277F,
	-165.771F,
	-241.455F,
	-156.494F,
	-275.146F,
	-238.281F,
	-186.035F,
	-159.668F,
	-217.285F,
	-196.777F,
	-203.369F,
	-266.357F,
	-172.363F,
	-153.564F,
	-151.611F,
	-196.777F,
	-156.250F,
	-198.242F,
	-189.209F,
	-154.785F,
	-190.186F,
	-132.568F,
	-243.164F,
	-137.939F,
	-262.451F,
	-141.602F,
	-133.301F,
	-149.170F,
	-139.648F,
	-151.123F,
	-185.547F,
	-70.8008F,
	-214.600F,
	-128.418F,
	-200.928F,
	-112.793F,
	-194.092F,
	-61.7676F,
	-135.010F,
	-101.318F,
	-143.799F,
	-107.178F,
	-130.127F,
	-83.0078F,
	-168.945F,
	-228.271F,
	-123.291F,
	-188.477F,
	-171.387F,
	-276.123F,
	-64.2090F,
	-74.7070F,
	-237.061F,
	-117.920F,
	-108.643F,
	-18.0664F,
	-135.498F,
	-133.789F,
	-149.902F,
	-31.4941F,
	-169.189F,
	-57.1289F,
	-96.6797F,
	-60.0586F,
	-115.967F,
	-61.0352F,
	-64.6973F,
	-98.6328F,
	-91.7969F,
	-125.488F,
	-101.807F,
	-124.512F,
	-73.2422F,
	-76.4160F,
	-81.5430F,
	-162.109F,
	-113.037F,
	-198.730F,
	-94.2383F,
	-171.875F,
	-82.2754F,
	-150.146F,
	-57.1289F,
	-49.0723F,
	-56.8848F,
	-58.3496F,
	-40.7715F,
	-138.428F,
	-49.5605F,
	-151.123F,
	-35.8887F,
	-101.318F,
	-28.0762F,
	-85.9375F,
	-40.5273F,
	-183.105F,
	-41.7480F,
	-185.791F,
	-65.9180F,
	-214.600F,
	-64.4531F,
	-220.459F,
	-89.5996F,
	-181.641F,
	10.4980F,
	-115.967F,
	3.41797F,
	-159.424F,
	10.4980F,
	-163.574F,
	2.68555F,
	-109.375F,
	-14.4043F,
	-127.197F,
	-30.7617F,
	-29.0527F,
	-37.8418F,
	-149.658F,
	-10.2539F,
	-210.693F,
	-6.59180F,
	-227.295F,
	33.2031F,
	-117.920F,
	44.6777F,
	-114.258F,
	13.4277F,
	-72.7539F,
	13.4277F,
	-74.2188F,
	76.4160F,
	-148.682F,
	76.4160F,
	-175.781F,
	78.6133F,
	-40.7715F,
	24.4141F,
	-132.080F,
	-0.732422F,
	-29.0527F,
	-27.0996F,
	-45.6543F,
	56.8848F,
	-57.6172F,
	63.4766F,
	-57.1289F,
	6.34766F,
	-40.2832F,
	32.7148F,
	-10.9863F,
	-9.76563F,
	-134.033F,
	87.8906F,
	-49.5605F,
	92.2852F,
	-94.7266F,
	109.863F,
	-93.5059F,
	67.1387F,
	4.88281F,
	44.4336F,
	-25.1465F,
	60.0586F,
	-27.0996F,
	105.225F,
	9.03320F,
	112.793F,
	-35.6445F,
	118.896F,
	-38.3301F,
	-69.3359F,
	-14.4043F,
	122.803F,
	-44.9219F,
	5.85938F,
	12.9395F,
	-0.732422F,
	13.1836F,
	29.7852F,
	63.2324F,
	81.2988F,
	16.1133F,
	118.164F,
	25.3906F,
	106.445F,
	16.6016F,
	47.6074F,
	28.3203F,
	46.3867F,
	50.2930F,
	65.6738F,
	-2.19727F,
	117.676F,
	85.9375F,
	93.2617F,
	69.5801F,
	97.4121F,
	67.6270F,
	110.352F,
	62.5000F,
	16.8457F,
	45.4102F,
	3.17383F,
	72.5098F,
	-3.17383F,
	63.2324F,
	-23.1934F,
	7.32422F,
	13.6719F,
	96.1914F,
	47.8516F,
	103.760F,
	50.0488F,
	111.328F,
	68.6035F,
	140.869F,
	3.66211F,
	46.6309F,
	91.5527F,
	70.8008F,
	99.3652F,
	140.625F,
	-13.6719F,
	55.4199F,
	132.813F,
	98.8770F,
	0.000000F,
	134.033F,
	-22.4609F,
	128.906F,
	-55.9082F,
	85.6934F,
	-59.8145F,
	82.5195F,
	-88.3789F,
	106.201F,
	40.7715F,
	128.662F,
	-18.3105F,
	73.7305F,
	22.2168F,
	201.172F,
	31.4941F,
	146.240F,
	121.094F,
	165.771F,
	45.4102F,
	182.861F,
	37.3535F,
	179.932F,
	-68.6035F,
	146.484F,
	-84.9609F,
	150.146F,
	-57.6172F,
	187.744F,
	10.0098F,
	215.088F,
	9.27734F,
	217.285F,
	-53.7109F,
	205.322F,
	-87.1582F,
	215.576F,
	-95.9473F,
	220.459F,
	-154.785F,
	115.723F,
	-108.398F,
	207.520F,
	-42.7246F,
	165.527F,
	-120.361F,
	59.0820F,
	-126.709F,
	191.650F,
	-174.316F,
	142.090F,
	-132.080F,
	89.3555F,
	-132.568F,
	105.957F,
	-145.752F,
	122.070F,
	-186.768F,
	54.1992F,
	-171.387F,
	223.877F,
	-181.396F,
	234.863F,
	-212.158F,
	122.314F,
	-219.482F,
	133.789F,
	-92.5293F,
	48.8281F,
	-106.201F,
	38.3301F,
	-199.951F,
	52.2461F,
	-210.205F,
	38.3301F,
	-149.902F,
	9.76563F,
	-154.297F,
	22.9492F,
	-215.576F,
	-13.1836F,
	-180.908F,
	125.977F,
	-122.314F,
	72.7539F,
	-149.902F,
	-41.7480F,
	-212.402F,
	-39.3066F,
	-211.182F,
	-5.61523F,
	-199.707F,
	22.7051F,
	-247.803F,
	-65.1855F,
	-161.621F,
	-87.6465F,
	-134.033F,
	0.488281F,
	-107.910F,
	-29.5410F,
	-92.0410F,
	0.000000F,
	-55.4199F,
	8.05664F,
	-101.074F,
	-30.7617F,
	-31.4941F,
	51.7578F,
	-228.027F,
	8.30078F,
	-264.160F,
	-68.8477F,
	-273.193F,
	-65.4297F,
	-173.340F,
	-201.416F,
	-102.539F,
	-46.6309F,
	-262.695F,
	-226.563F,
	-223.877F,
	-22.7051F,
	-153.320F,
	-87.4023F,
	23.6816F,
	1.70898F,
	-50.2930F,
	-95.9473F,
	-24.6582F,
	5.85938F,
	-49.5605F,
	9.27734F,
	-41.0156F,
	20.2637F,
	-146.240F,
	-103.271F,
	-68.1152F,
	104.004F,
	-170.898F,
	28.8086F,
	-18.3105F,
	50.2930F,
	-239.502F,
	-164.307F,
	-166.016F,
	101.807F,
	-89.5996F,
	9.03320F,
	-68.1152F,
	115.723F,
	-31.4941F,
	-77.6367F,
	77.8809F,
	72.2656F,
	-152.832F,
	-9.52148F,
	83.7402F,
	146.973F,
	-169.922F,
	-9.52148F,
	-73.9746F,
	229.492F,
	25.3906F,
	56.8848F,
	-92.7734F,
	33.4473F,
	-8.78906F,
	65.6738F,
	-18.3105F,
	-52.2461F,
	29.2969F,
	10.4980F,
	-129.150F,
	-116.455F,
	112.061F,
	40.0391F,
	-49.3164F,
	-55.9082F,
	-11.9629F,
	-40.7715F,
	148.682F,
	193.359F,
	23.9258F,
	-53.7109F,
	223.389F,
	36.1328F,
	71.5332F,
	69.0918F,
	212.158F,
	22.2168F,
	140.381F,
	96.1914F,
	79.5898F,
	-19.0430F,
	175.049F,
	16.3574F,
	89.1113F,
	-78.8574F,
	150.391F,
	-8.78906F,
	178.467F,
	6.59180F,
	151.123F,
	58.1055F,
	154.297F,
	66.6504F,
	109.375F,
	24.1699F,
	195.557F,
	116.211F,
	212.158F,
	66.6504F,
	167.236F,
	15.6250F,
	192.627F,
	17.5781F,
	249.268F,
	52.9785F,
	193.604F,
	112.061F,
	179.199F,
	87.8906F,
	157.715F,
	117.188F,
	87.8906F,
	78.6133F,
	104.736F,
	113.281F,
	155.762F,
	104.980F,
	184.570F,
	88.6230F,
	244.141F,
	98.6328F,
	166.748F,
	128.906F,
	146.973F,
	150.146F,
	159.912F,
	100.830F,
	230.957F,
	167.725F,
	228.760F,
	146.973F,
	220.703F,
	147.461F,
	135.498F,
	179.932F,
	191.895F,
	161.621F,
	114.014F,
	159.668F,
	88.3789F,
	143.799F,
	226.807F,
	173.340F,
	121.582F,
	116.699F,
	101.318F,
	102.539F,
	169.189F,
	215.576F,
	198.486F,
	166.748F,
	190.674F,
	225.830F,
	222.900F,
	229.248F,
	177.246F,
	178.711F,
	119.873F,
	208.252F,
	129.639F,
	231.445F,
	179.199F,
	235.107F,
	76.9043F,
	197.266F,
	185.791F,
	184.326F,
	279.297F,
	185.547F,
	159.912F,
	262.695F,
	201.660F,
	258.057F,
	266.357F,
	204.590F,
	244.873F,
	197.266F,
	255.615F,
	276.611F,
	160.889F,
	268.799F,
	242.188F,
	256.348F,
	262.207F,
	262.451F,
	237.061F,
	169.434F,
	299.316F,
	257.324F,
	139.404F,
	205.322F,
	215.820F,
	342.773F,
	336.670F,
	267.578F,
	263.672F,
	210.205F,
	300.537F,
	179.443F,
	313.477F,
	185.547F,
	310.547F,
	241.943F,
	333.740F,
	257.080F,
	306.885F,
	170.898F,
	256.348F,
	130.371F,
	241.211F,
	110.596F,
	308.594F,
	146.240F,
	278.320F,
	165.771F,
	395.752F,
	198.975F,
	337.891F,
	127.197F,
	321.533F,
	95.9473F,
	381.836F,
	196.533F,
	353.516F,
	167.480F,
	260.742F,
	158.203F,
	213.623F,
	74.9512F,
	264.404F,
	88.1348F,
	255.615F,
	77.3926F,
	345.947F,
	235.352F,
	164.795F,
	139.404F,
	281.250F,
	19.2871F,
	271.973F,
	-11.4746F,
	373.535F,
	75.9277F,
	420.166F,
	76.6602F,
	284.668F,
	168.213F,
	125.488F,
	-22.9492F,
	85.2051F,
	68.8477F,
	344.727F,
	80.0781F,
	250.244F,
	118.896F,
	-15.8691F,
	13.9160F,
	196.533F,
	236.816F,
	8.78906F,
	15.1367F,
	187.744F,
	-64.2090F,
	193.115F,
	-84.4727F,
	155.518F,
	170.654F,
	-33.4473F,
	151.367F,
	130.371F,
	132.080F,
	-179.443F,
	47.3633F,
	173.584F,
	73.2422F,
	-65.4297F,
	-210.693F,
	226.074F,
	187.744F,
	-172.852F,
	-104.492F,
	123.535F,
	42.4805F,
	-217.773F,
	-153.809F,
	106.201F,
	133.545F,
	-350.342F,
	-62.9883F,
	151.611F,
	114.990F,
	-248.535F,
	-333.984F,
	-95.9473F,
	127.197F,
	-224.609F,
	-167.480F,
	-6.10352F,
	4.88281F,
	-239.746F,
	-282.227F,
	83.0078F,
	2.19727F,
	-380.371F,
	-277.100F,
	-85.9375F,
	11.7188F,
	-385.498F,
	-98.1445F,
	-216.553F,
	1.46484F,
	-282.227F,
	-216.797F,
	-133.789F,
	-85.9375F,
	-401.123F,
	-285.156F,
	-38.8184F,
	148.926F,
	-494.141F,
	-235.107F,
	-54.9316F,
	47.1191F,
	-404.297F,
	-478.516F,
	-59.8145F,
	-120.361F,
	-235.352F,
	-410.156F,
	-228.516F,
	-155.029F,
	-317.139F,
	-425.781F,
	-338.867F,
	-147.461F,
	-375.977F,
	-203.857F,
	-341.064F,
	-32.9590F,
	-387.695F,
	-70.8008F,
	-407.715F,
	-173.828F,
	-490.967F,
	-398.438F,
	-406.006F,
	-6.59180F,
	-551.270F,
	-197.998F,
	-282.471F,
	44.9219F,
	-308.838F,
	46.1426F,
	-333.740F,
	143.066F,
	-490.967F,
	49.0723F,
	-192.871F,
	173.828F,
	-295.410F,
	0.732422F,
	-252.197F,
	197.266F,
	-305.420F,
	202.637F,
	-27.0996F,
	155.029F,
	-399.414F,
	109.131F,
	-113.037F,
	-231.689F,
	-108.643F,
	-226.563F,
	-123.047F,
	-283.691F,
	-122.314F,
	-295.654F,
	35.1563F,
	-85.6934F,
	-90.8203F,
	-256.836F,
	-69.0918F,
	-258.545F,
	-68.1152F,
	-274.170F,
	-140.381F,
	-351.074F,
	-143.311F,
	-394.043F,
	-228.271F,
	-240.234F,
	55.9082F,
	168.457F,
	-224.854F,
	-175.537F,
	-98.3887F,
	332.520F,
	-167.236F,
	-113.525F,
	213.379F,
	96.9238F,
	-124.268F,
	-11.2305F,
	77.3926F,
	325.684F,
	-118.408F,
	111.328F,
	198.486F,
	107.178F,
	-100.342F,
	82.7637F,
	219.238F,
	260.498F,
	-103.760F,
	11.2305F,
	351.807F,
	121.338F,
	-221.924F,
	-195.313F,
	357.666F,
	255.371F,
	-62.0117F,
	-78.3691F,
	349.121F,
	284.424F,
	16.6016F,
	85.4492F,
	252.441F,
	162.598F,
	90.3320F,
	2.68555F,
	320.068F,
	192.871F,
	34.9121F,
	56.6406F,
	254.150F,
	381.348F,
	-27.8320F,
	161.865F,
	394.531F,
	263.184F,
	110.840F,
	141.357F,
	311.279F,
	253.906F,
	-18.5547F,
	221.924F,
	183.594F,
	260.498F,
	37.3535F,
	125.000F,
	84.9609F,
	296.387F,
	149.902F,
	93.9941F,
	449.951F,
	197.266F,
	65.6738F,
	252.441F,
	49.5605F,
	265.137F,
	159.180F,
	248.291F,
	435.303F,
	275.879F,
	104.736F,
	323.975F,
	94.4824F,
	337.891F,
	-11.9629F,
	288.818F,
	-17.5781F,
	296.631F,
	-101.563F,
	244.385F,
	132.813F,
	427.002F,
	-85.9375F,
	298.584F,
	-122.559F,
	292.725F,
	-143.799F,
	138.916F,
	-55.4199F,
	397.949F,
	-34.6680F,
	385.254F,
	-56.1523F,
	418.701F,
	-174.316F,
	314.453F,
	-204.590F,
	341.309F,
	276.123F,
	331.299F,
	-50.7813F,
	300.781F,
	106.689F,
	235.596F,
	-226.807F,
	199.707F,
	197.998F,
	344.238F,
	209.717F,
	367.920F,
	40.0391F,
	295.898F,
	338.623F,
	437.744F,
	118.164F,
	457.520F,
	111.328F,
	503.662F,
	243.164F,
	285.645F,
	323.730F,
	342.285F,
	321.289F,
	332.031F,
	277.100F,
	308.105F,
	301.270F,
	395.020F,
	332.275F,
	431.641F,
	346.924F,
	299.561F,
	386.719F,
	328.857F,
	208.496F,
	164.063F,
	411.377F,
	382.324F,
	278.076F,
	310.059F,
	492.188F,
	445.557F,
	432.861F,
	385.986F,
	374.023F,
	356.445F,
	363.037F,
	230.957F,
	405.029F,
	249.268F,
	425.781F,
	295.898F,
	339.844F,
	238.525F,
	432.617F,
	283.447F,
	445.801F,
	284.180F,
	419.434F,
	348.877F,
	481.689F,
	388.428F,
	289.307F,
	210.938F,
	520.508F,
	259.033F,
	439.209F,
	198.730F,
	448.730F,
	184.814F,
	513.672F,
	321.045F,
	501.465F,
	307.129F,
	515.869F,
	223.389F,
	569.092F,
	227.051F,
	358.154F,
	280.029F,
	632.324F,
	351.318F,
	548.096F,
	425.781F,
	510.254F,
	395.508F,
	575.684F,
	354.980F,
	650.879F,
	367.676F,
	458.008F,
	448.486F,
	505.371F,
	482.178F,
	424.561F,
	385.010F,
	166.504F,
	314.697F,
	386.719F,
	499.268F,
	354.980F,
	512.207F,
	609.863F,
	489.258F,
	661.865F,
	504.395F,
	177.246F,
	387.695F,
	672.852F,
	570.313F,
	55.6641F,
	206.787F,
	599.609F,
	405.029F,
	8.78906F,
	73.4863F,
	474.121F,
	477.783F,
	-108.887F,
	-23.4375F,
	525.879F,
	340.820F,
	374.268F,
	268.799F,
	3.41797F,
	148.438F,
	-225.342F,
	-178.711F,
	337.646F,
	483.887F,
	328.369F,
	232.422F,
	-166.016F,
	78.3691F,
	312.744F,
	309.570F,
	-389.160F,
	89.1113F,
	229.736F,
	230.957F,
	-424.072F,
	-200.684F,
	579.590F,
	680.420F,
	444.580F,
	680.664F

};
__device__ static const Float32 dico3_lsf_5[DICO3_SIZE_5 * 4] =
{
	-442.383F,
	-555.420F,
	-458.740F,
	-619.385F,
	-400.391F,
	-451.172F,
	-413.818F,
	-489.258F,
	-297.852F,
	-466.797F,
	-298.096F,
	-514.160F,
	-380.615F,
	-387.695F,
	-384.033F,
	-379.883F,
	-291.748F,
	-394.287F,
	-298.828F,
	-421.631F,
	-331.787F,
	-281.006F,
	-394.531F,
	-475.586F,
	-311.035F,
	-339.600F,
	-318.604F,
	-342.529F,
	-392.334F,
	-287.842F,
	-409.180F,
	-320.068F,
	-352.295F,
	-360.840F,
	-333.740F,
	-219.238F,
	-306.641F,
	-258.545F,
	-324.951F,
	-276.855F,
	-239.746F,
	-276.611F,
	-280.518F,
	-367.188F,
	-263.672F,
	-319.336F,
	-249.023F,
	-288.818F,
	-239.258F,
	-362.793F,
	-236.084F,
	-364.990F,
	-241.211F,
	-225.098F,
	-255.615F,
	-262.939F,
	-204.590F,
	-287.842F,
	-209.473F,
	-298.340F,
	-276.123F,
	-254.150F,
	-259.766F,
	-187.256F,
	-212.891F,
	-282.471F,
	-171.143F,
	-214.844F,
	-172.363F,
	-221.191F,
	-188.965F,
	-248.047F,
	-141.113F,
	-263.672F,
	-195.557F,
	-360.840F,
	-144.287F,
	-271.240F,
	-144.531F,
	-279.785F,
	-174.072F,
	-338.867F,
	-156.250F,
	-335.938F,
	-145.752F,
	-258.545F,
	-101.563F,
	-220.459F,
	-167.480F,
	-203.125F,
	-161.377F,
	-172.852F,
	-108.398F,
	-211.914F,
	-119.629F,
	-224.854F,
	-91.3086F,
	-189.453F,
	-151.123F,
	-285.645F,
	-142.822F,
	-134.033F,
	-187.744F,
	-194.092F,
	-106.201F,
	-160.889F,
	-129.395F,
	-180.908F,
	-121.582F,
	-204.346F,
	-87.1582F,
	-145.752F,
	-68.1152F,
	-212.646F,
	-59.3262F,
	-216.553F,
	-68.8477F,
	-162.354F,
	-68.3594F,
	-162.842F,
	-40.2832F,
	-136.719F,
	-96.1914F,
	-220.459F,
	-88.3789F,
	-100.098F,
	-109.375F,
	-142.334F,
	-99.8535F,
	-140.137F,
	-76.4160F,
	-87.1582F,
	-155.518F,
	-133.789F,
	-139.160F,
	-106.445F,
	-218.750F,
	-123.047F,
	-93.2617F,
	-184.814F,
	-14.1602F,
	-117.432F,
	-40.2832F,
	-150.879F,
	-46.6309F,
	-91.3086F,
	-57.1289F,
	-93.2617F,
	-54.1992F,
	-166.748F,
	-6.10352F,
	-117.188F,
	-102.051F,
	-87.6465F,
	-178.223F,
	-86.1816F,
	-79.1016F,
	-38.3301F,
	-105.469F,
	-78.6133F,
	-96.1914F,
	-73.9746F,
	-69.3359F,
	-25.3906F,
	-146.729F,
	-70.5566F,
	-135.742F,
	-47.8516F,
	-143.555F,
	-36.6211F,
	-160.889F,
	-148.438F,
	-115.479F,
	-5.85938F,
	-16.6016F,
	-109.375F,
	-115.723F,
	-1.95313F,
	-123.535F,
	-10.9863F,
	-182.617F,
	-44.9219F,
	-206.055F,
	-61.5234F,
	-219.971F,
	-22.2168F,
	-142.578F,
	-23.6816F,
	-159.180F,
	33.6914F,
	-186.523F,
	-31.9824F,
	-165.527F,
	-2.92969F,
	-163.574F,
	40.2832F,
	-63.2324F,
	-0.732422F,
	-205.078F,
	-26.1230F,
	-221.924F,
	9.03320F,
	-242.188F,
	10.7422F,
	-208.496F,
	-101.318F,
	-204.834F,
	3.17383F,
	-244.385F,
	-66.1621F,
	-250.488F,
	-75.4395F,
	-194.824F,
	-116.699F,
	-203.125F,
	-119.141F,
	-230.225F,
	41.0156F,
	-271.484F,
	-94.4824F,
	-289.307F,
	-24.6582F,
	-288.818F,
	-9.76563F,
	-229.736F,
	-77.1484F,
	-251.465F,
	-187.988F,
	-254.883F,
	-152.588F,
	-263.916F,
	-131.348F,
	-298.828F,
	-72.9980F,
	-320.313F,
	-106.445F,
	-292.236F,
	-161.865F,
	-284.912F,
	-39.3066F,
	-296.875F,
	-168.457F,
	-302.002F,
	-202.881F,
	-349.609F,
	-175.781F,
	-342.529F,
	-120.361F,
	-219.238F,
	-180.664F,
	-225.098F,
	-195.557F,
	-269.043F,
	-98.1445F,
	-385.498F,
	-235.352F,
	-259.033F,
	-155.762F,
	-309.814F,
	-351.074F,
	-365.967F,
	-228.027F,
	-366.699F,
	-218.506F,
	-390.137F,
	-137.695F,
	-420.654F,
	-175.049F,
	-147.949F,
	-145.752F,
	-284.668F,
	-264.893F,
	-334.229F,
	-114.258F,
	-475.098F,
	-364.502F,
	-448.730F,
	-232.666F,
	-471.680F,
	-227.295F,
	-365.967F,
	-45.8984F,
	-399.170F,
	-102.783F,
	-355.713F,
	-82.5195F,
	-353.516F,
	-5.37109F,
	-474.121F,
	-103.027F,
	-489.746F,
	-60.7910F,
	-121.094F,
	-27.8320F,
	-466.309F,
	-184.326F,
	-314.697F,
	42.4805F,
	-354.248F,
	-26.6113F,
	-117.676F,
	-62.7441F,
	-298.096F,
	-124.023F,
	-394.775F,
	36.8652F,
	-413.574F,
	50.7813F,
	-159.668F,
	26.1230F,
	-403.076F,
	7.08008F,
	-278.564F,
	68.1152F,
	-296.631F,
	74.7070F,
	-299.805F,
	-123.535F,
	-178.223F,
	-42.7246F,
	-301.758F,
	-24.6582F,
	-236.572F,
	134.521F,
	-212.402F,
	67.8711F,
	-200.928F,
	76.9043F,
	-137.451F,
	91.7969F,
	-256.592F,
	55.6641F,
	-123.779F,
	68.3594F,
	-146.240F,
	68.6035F,
	-185.059F,
	61.7676F,
	-74.4629F,
	92.5293F,
	-184.326F,
	-32.7148F,
	-149.170F,
	161.133F,
	-201.172F,
	130.859F,
	-199.463F,
	157.715F,
	-100.830F,
	11.9629F,
	-83.2520F,
	43.2129F,
	-110.596F,
	128.418F,
	-117.676F,
	143.799F,
	-17.3340F,
	82.7637F,
	-160.400F,
	64.4531F,
	-59.5703F,
	72.0215F,
	-57.8613F,
	76.9043F,
	-94.4824F,
	138.916F,
	-123.535F,
	-2.19727F,
	-92.0410F,
	3.41797F,
	-39.0625F,
	161.377F,
	-52.7344F,
	9.76563F,
	-75.1953F,
	-11.2305F,
	23.1934F,
	52.2461F,
	-59.0820F,
	40.7715F,
	-20.9961F,
	46.8750F,
	-13.6719F,
	6.59180F,
	-18.5547F,
	7.56836F,
	8.78906F,
	75.4395F,
	-25.8789F,
	-44.4336F,
	-27.5879F,
	18.0664F,
	-107.666F,
	-5.37109F,
	5.61523F,
	33.9355F,
	19.7754F,
	-2.68555F,
	10.7422F,
	3.66211F,
	-21.2402F,
	-33.4473F,
	-28.8086F,
	-50.5371F,
	-38.5742F,
	-14.1602F,
	66.4063F,
	-22.4609F,
	-38.0859F,
	-107.666F,
	1.95313F,
	-33.2031F,
	31.2500F,
	-53.9551F,
	24.6582F,
	-53.2227F,
	9.76563F,
	-48.0957F,
	-18.5547F,
	-111.328F,
	2.19727F,
	-108.643F,
	8.05664F,
	-103.271F,
	55.1758F,
	14.6484F,
	17.8223F,
	-54.1992F,
	38.0859F,
	-97.4121F,
	68.3594F,
	-77.6367F,
	59.8145F,
	-83.2520F,
	40.5273F,
	-121.826F,
	82.7637F,
	-46.3867F,
	79.8340F,
	-53.4668F,
	79.3457F,
	-33.4473F,
	-21.7285F,
	-145.508F,
	24.4141F,
	-153.076F,
	35.1563F,
	-165.283F,
	118.896F,
	6.83594F,
	61.5234F,
	-95.4590F,
	52.2461F,
	-10.0098F,
	68.8477F,
	-6.83594F,
	24.1699F,
	-69.8242F,
	80.8105F,
	11.9629F,
	112.061F,
	-94.7266F,
	137.939F,
	-90.0879F,
	106.445F,
	6.83594F,
	82.0313F,
	-2.19727F,
	96.9238F,
	-40.7715F,
	150.879F,
	8.30078F,
	145.508F,
	-4.15039F,
	136.963F,
	-34.1797F,
	72.9980F,
	19.2871F,
	127.441F,
	30.5176F,
	49.5605F,
	0.488281F,
	59.5703F,
	70.3125F,
	62.2559F,
	51.5137F,
	42.7246F,
	20.0195F,
	145.508F,
	45.6543F,
	126.221F,
	26.3672F,
	93.0176F,
	62.2559F,
	89.1113F,
	72.5098F,
	121.338F,
	85.9375F,
	79.8340F,
	-20.0195F,
	6.10352F,
	51.2695F,
	90.5762F,
	59.8145F,
	63.7207F,
	0.732422F,
	133.057F,
	109.619F,
	34.1797F,
	71.7773F,
	10.7422F,
	72.0215F,
	51.7578F,
	84.7168F,
	59.5703F,
	120.605F,
	80.8105F,
	128.906F,
	49.0723F,
	74.9512F,
	85.2051F,
	100.342F,
	149.658F,
	69.3359F,
	149.902F,
	100.830F,
	113.281F,
	78.6133F,
	152.344F,
	96.9238F,
	23.6816F,
	48.8281F,
	-39.0625F,
	93.7500F,
	36.3770F,
	88.3789F,
	120.850F,
	128.174F,
	65.6738F,
	142.822F,
	8.05664F,
	119.873F,
	-29.5410F,
	105.713F,
	104.248F,
	149.170F,
	121.582F,
	125.977F,
	41.7480F,
	108.154F,
	121.338F,
	162.598F,
	107.422F,
	67.1387F,
	138.184F,
	140.381F,
	35.6445F,
	156.006F,
	37.8418F,
	163.574F,
	-8.05664F,
	42.2363F,
	51.7578F,
	169.922F,
	-40.5273F,
	146.729F,
	-46.6309F,
	169.678F,
	-119.385F,
	122.803F,
	42.7246F,
	181.152F,
	52.2461F,
	116.211F,
	90.8203F,
	264.404F,
	141.113F,
	129.395F,
	143.066F,
	189.697F,
	103.760F,
	213.379F,
	76.9043F,
	205.322F,
	91.3086F,
	207.031F,
	-40.2832F,
	137.939F,
	8.54492F,
	241.943F,
	-9.52148F,
	259.277F,
	80.3223F,
	173.828F,
	191.895F,
	205.078F,
	157.471F,
	194.092F,
	161.377F,
	165.039F,
	139.404F,
	224.121F,
	154.297F,
	263.428F,
	164.307F,
	199.463F,
	77.6367F,
	94.7266F,
	213.379F,
	247.070F,
	137.695F,
	207.031F,
	214.844F,
	151.367F,
	135.986F,
	116.943F,
	163.818F,
	110.596F,
	168.945F,
	114.258F,
	205.078F,
	156.738F,
	206.055F,
	157.471F,
	123.535F,
	104.492F,
	218.994F,
	138.428F,
	204.346F,
	94.4824F,
	234.863F,
	121.826F,
	168.701F,
	136.963F,
	229.248F,
	226.074F,
	191.162F,
	72.2656F,
	192.871F,
	65.4297F,
	250.977F,
	129.395F,
	213.379F,
	80.3223F,
	133.789F,
	34.9121F,
	164.795F,
	71.0449F,
	122.803F,
	16.1133F,
	254.150F,
	87.6465F,
	191.895F,
	23.6816F,
	196.533F,
	8.05664F,
	204.346F,
	114.746F,
	124.756F,
	11.9629F,
	266.602F,
	79.8340F,
	286.621F,
	78.8574F,
	0.732422F,
	59.0820F,
	212.891F,
	115.723F,
	168.213F,
	104.736F,
	324.463F,
	165.527F,
	254.395F,
	151.367F,
	270.752F,
	162.109F,
	78.3691F,
	47.1191F,
	217.041F,
	231.934F,
	281.494F,
	213.379F,
	218.018F,
	155.029F,
	214.111F,
	210.449F,
	231.445F,
	222.900F,
	315.674F,
	162.354F,
	322.266F,
	156.006F,
	243.408F,
	193.604F,
	342.285F,
	251.465F,
	287.109F,
	247.070F,
	270.996F,
	234.131F,
	344.238F,
	225.830F,
	342.529F,
	223.389F,
	132.568F,
	210.449F,
	272.461F,
	298.340F,
	203.857F,
	290.527F,
	203.857F,
	290.527F,
	234.131F,
	280.273F,
	280.029F,
	335.938F,
	317.383F,
	291.260F,
	345.459F,
	300.537F,
	325.928F,
	327.393F,
	182.129F,
	266.602F,
	417.725F,
	313.232F,
	339.111F,
	261.963F,
	325.684F,
	382.324F,
	281.494F,
	360.107F,
	401.611F,
	277.588F,
	445.557F,
	297.852F,
	257.813F,
	337.402F,
	371.338F,
	422.363F,
	398.438F,
	377.197F,
	395.508F,
	376.465F,
	208.740F,
	389.648F,
	211.182F,
	406.982F,
	169.189F,
	216.064F,
	418.945F,
	370.850F,
	284.912F,
	316.406F,
	539.307F,
	429.688F,
	476.563F,
	364.502F,
	493.164F,
	361.816F,
	374.512F,
	455.566F,
	413.574F,
	490.234F,
	382.324F,
	182.617F,
	429.932F,
	201.416F,
	71.7773F,
	339.844F,
	264.648F,
	502.441F,
	151.611F,
	321.045F,
	89.1113F,
	314.209F,
	48.3398F,
	250.977F,
	119.141F,
	343.750F,
	60.7910F,
	98.3887F,
	247.559F,
	381.104F,
	79.1016F,
	88.6230F,
	401.611F,
	254.883F,
	47.1191F,
	89.5996F,
	496.582F,
	453.857F,
	-61.2793F,
	141.357F,
	183.105F,
	242.676F,
	-59.3262F,
	7.32422F,
	323.486F,
	214.600F,
	-6.83594F,
	-41.2598F,
	152.344F,
	223.877F,
	-110.596F,
	38.8184F,
	45.4102F,
	334.473F,
	-149.902F,
	1.46484F,
	131.104F,
	95.7031F,
	-22.9492F,
	-71.0449F,
	190.674F,
	55.9082F,
	-31.2500F,
	-72.7539F,
	59.8145F,
	119.873F,
	-171.143F,
	-158.203F,
	237.305F,
	192.627F,
	-122.314F,
	-156.250F,
	43.4570F,
	62.2559F,
	-89.1113F,
	-95.2148F,
	-62.2559F,
	77.3926F,
	-233.887F,
	-71.7773F,
	-46.6309F,
	55.6641F,
	-189.209F,
	-109.131F,
	38.3301F,
	-57.8613F,
	-160.400F,
	-175.781F,
	-99.3652F,
	22.4609F,
	-28.5645F,
	-149.170F,
	81.5430F,
	-56.1523F,
	-165.771F,
	-264.648F,
	-35.1563F,
	-77.3926F,
	-219.971F,
	-210.205F,
	-180.176F,
	-87.8906F,
	-20.7520F,
	-177.490F,
	-21.9727F,
	-192.139F,
	24.4141F,
	-5.37109F,
	-95.4590F,
	-64.2090F,
	-13.6719F,
	-17.8223F,
	-82.2754F,
	-184.082F,
	1.22070F,
	-46.1426F,
	-172.363F,
	-152.344F,
	21.7285F,
	-83.9844F,
	-32.9590F,
	-271.729F,
	-86.1816F,
	-57.8613F,
	-166.992F,
	-277.100F,
	-67.1387F,
	-269.043F,
	-65.6738F,
	-293.701F,
	37.1094F,
	35.4004F,
	-176.270F,
	-300.781F,
	11.9629F,
	19.5313F,
	-304.688F,
	-189.453F,
	-60.5469F,
	95.4590F,
	-178.711F,
	-133.545F,
	114.502F,
	53.2227F,
	-62.2559F,
	-210.938F,
	16.8457F,
	89.3555F,
	-40.5273F,
	-118.408F,
	-167.969F,
	46.6309F,
	-295.898F,
	-291.992F,
	-41.5039F,
	-41.2598F,
	-319.336F,
	-398.193F,
	78.3691F,
	114.746F,
	-346.436F,
	-303.467F,
	-15.6250F,
	66.4063F,
	-332.275F,
	-60.5469F,
	120.117F,
	137.939F,
	-176.025F,
	-148.682F,
	47.6074F,
	118.408F,
	-139.893F,
	-32.4707F,
	104.248F,
	49.3164F,
	-41.7480F,
	-28.8086F,
	48.5840F,
	140.381F,
	0.488281F,
	-7.56836F,
	169.434F,
	184.326F,
	-333.496F,
	-9.52148F,
	134.766F,
	135.986F,
	-119.385F,
	66.1621F,
	166.016F,
	131.104F,
	3.17383F,
	-110.596F,
	208.740F,
	232.910F,
	-32.4707F,
	-12.6953F,
	-19.7754F,
	180.176F,
	-285.400F,
	155.518F,
	257.568F,
	258.545F,
	-23.1934F,
	165.039F,
	307.373F,
	263.916F,
	119.385F,
	74.4629F,
	-109.619F,
	232.910F,
	-130.371F,
	243.164F,
	-236.572F,
	211.426F,
	-258.301F,
	258.545F,
	-315.918F,
	150.879F,
	-345.703F,
	150.635F,
	-111.816F,
	333.496F,
	-38.8184F,
	444.580F,
	-188.965F,
	-128.906F,
	-3.41797F,
	270.996F,
	-293.457F,
	-219.971F,
	-188.477F,
	105.713F,
	-306.641F,
	-306.396F,
	-246.826F,
	-73.7305F,
	-146.973F,
	-142.822F,
	-185.303F,
	-395.020F,
	-185.547F,
	-378.174F,
	-205.078F,
	-468.994F,
	-199.219F,
	-131.592F,
	-431.885F,
	-545.654F,
	-55.4199F,
	-8.78906F,
	-496.582F,
	-447.021F,
	-514.404F,
	-274.902F,
	-603.271F,
	-443.359F,
	-358.887F,
	61.5234F,
	-659.424F,
	-101.318F,
	-139.404F,
	-114.014F,
	368.408F,
	379.395F,
	532.227F,
	482.178F,
	567.871F,
	493.164F


};
__device__ static const Float32 dico4_lsf_5[DICO4_SIZE_5 * 4] =
{
	-453.369F,
	-410.400F,
	-453.369F,
	-428.467F,
	-501.953F,
	-280.762F,
	-520.996F,
	-403.809F,
	-395.264F,
	-268.311F,
	-416.016F,
	-276.123F,
	-328.369F,
	-392.578F,
	-331.787F,
	-399.902F,
	-326.660F,
	-315.674F,
	-323.486F,
	-308.838F,
	-406.250F,
	-402.588F,
	-363.037F,
	-207.764F,
	-328.613F,
	-447.266F,
	-344.971F,
	-534.180F,
	-312.988F,
	-166.260F,
	-435.791F,
	-402.588F,
	-235.840F,
	-264.160F,
	-288.818F,
	-409.180F,
	-257.324F,
	-261.963F,
	-278.809F,
	-282.715F,
	-294.678F,
	-181.641F,
	-311.035F,
	-243.408F,
	-228.027F,
	-337.646F,
	-226.318F,
	-345.703F,
	-246.582F,
	-318.604F,
	-191.162F,
	-233.154F,
	-256.104F,
	-219.727F,
	-242.432F,
	-199.463F,
	-179.932F,
	-200.928F,
	-237.305F,
	-290.283F,
	-180.176F,
	-267.090F,
	-180.176F,
	-281.738F,
	-191.406F,
	-195.557F,
	-197.754F,
	-191.895F,
	-217.773F,
	-126.953F,
	-244.141F,
	-199.707F,
	-157.227F,
	-235.596F,
	-140.869F,
	-215.332F,
	-132.080F,
	-169.434F,
	-163.818F,
	-223.877F,
	-145.264F,
	-156.738F,
	-157.715F,
	-150.146F,
	-233.398F,
	-151.611F,
	-225.830F,
	-125.732F,
	-177.490F,
	-117.920F,
	-198.975F,
	-118.408F,
	-205.078F,
	-141.113F,
	-107.422F,
	-174.072F,
	-141.113F,
	-79.3457F,
	-160.400F,
	-163.574F,
	-94.2383F,
	-139.160F,
	-107.666F,
	-162.598F,
	-125.488F,
	-192.139F,
	-95.7031F,
	-129.150F,
	-127.441F,
	-110.596F,
	-118.896F,
	-103.271F,
	-150.391F,
	-142.822F,
	-150.635F,
	-38.3301F,
	-161.621F,
	-65.4297F,
	-166.016F,
	-84.9609F,
	-78.6133F,
	-78.8574F,
	-154.297F,
	-108.398F,
	-74.2188F,
	-104.980F,
	-81.0547F,
	-111.816F,
	-67.6270F,
	-114.258F,
	-160.889F,
	-193.604F,
	-77.8809F,
	-155.273F,
	-55.4199F,
	-135.254F,
	-91.0645F,
	-84.7168F,
	-81.5430F,
	-51.2695F,
	-111.328F,
	-46.8750F,
	-129.395F,
	-59.0820F,
	-52.7344F,
	-48.3398F,
	-89.3555F,
	-90.3320F,
	-82.5195F,
	-39.3066F,
	-99.8535F,
	-182.617F,
	-26.1230F,
	-92.7734F,
	-71.7773F,
	-156.982F,
	-54.4434F,
	-162.354F,
	-57.1289F,
	-180.908F,
	-34.4238F,
	-121.094F,
	-31.7383F,
	-124.512F,
	-33.9355F,
	-79.8340F,
	-41.9922F,
	-74.4629F,
	-74.7070F,
	-141.602F,
	-40.0391F,
	-64.2090F,
	-63.9648F,
	-41.9922F,
	-16.3574F,
	-98.1445F,
	7.56836F,
	-89.3555F,
	-2.44141F,
	-106.445F,
	-20.9961F,
	-128.662F,
	17.3340F,
	-92.0410F,
	-5.37109F,
	-148.682F,
	-2.92969F,
	-165.527F,
	-16.3574F,
	-77.8809F,
	15.3809F,
	-46.6309F,
	8.54492F,
	-44.1895F,
	-9.52148F,
	-59.0820F,
	30.7617F,
	-40.7715F,
	-34.1797F,
	-132.813F,
	37.8418F,
	-72.5098F,
	42.4805F,
	-72.5098F,
	9.27734F,
	-1.95313F,
	28.5645F,
	-92.7734F,
	48.0957F,
	-110.352F,
	58.5938F,
	-127.441F,
	54.4434F,
	-25.1465F,
	26.8555F,
	-45.6543F,
	21.2402F,
	-37.8418F,
	41.2598F,
	-11.4746F,
	38.3301F,
	6.34766F,
	-20.2637F,
	-24.4141F,
	31.2500F,
	19.5313F,
	51.0254F,
	-15.1367F,
	1.46484F,
	1.70898F,
	5.37109F,
	1.22070F,
	77.6367F,
	-4.88281F,
	60.5469F,
	-10.9863F,
	-48.8281F,
	-15.3809F,
	38.0859F,
	-16.8457F,
	61.0352F,
	-44.6777F,
	90.0879F,
	-30.7617F,
	-27.5879F,
	-18.5547F,
	-34.6680F,
	-29.7852F,
	-15.6250F,
	-62.0117F,
	-7.56836F,
	8.54492F,
	-43.2129F,
	-17.3340F,
	-1.70898F,
	41.7480F,
	22.7051F,
	6.59180F,
	26.3672F,
	51.7578F,
	-80.5664F,
	-51.0254F,
	-30.0293F,
	-17.0898F,
	-68.1152F,
	23.1934F,
	-23.4375F,
	4.88281F,
	-45.8984F,
	-14.8926F,
	-76.6602F,
	21.2402F,
	-73.2422F,
	-19.0430F,
	-86.4258F,
	-32.7148F,
	2.68555F,
	29.7852F,
	-34.1797F,
	29.7852F,
	-67.1387F,
	37.1094F,
	-71.5332F,
	34.1797F,
	-20.0195F,
	33.6914F,
	-78.3691F,
	-27.0996F,
	-117.188F,
	-38.0859F,
	-87.6465F,
	18.5547F,
	-62.0117F,
	-9.76563F,
	-155.029F,
	-23.4375F,
	-127.441F,
	19.2871F,
	-123.779F,
	1.95313F,
	-65.4297F,
	73.9746F,
	-131.592F,
	16.6016F,
	-108.887F,
	14.8926F,
	-127.441F,
	74.7070F,
	27.0996F,
	46.1426F,
	-106.201F,
	29.7852F,
	-92.5293F,
	40.5273F,
	-139.404F,
	-97.1680F,
	-154.297F,
	-18.0664F,
	-182.373F,
	-23.1934F,
	-111.084F,
	47.3633F,
	-232.422F,
	20.2637F,
	-194.824F,
	46.8750F,
	-184.326F,
	46.8750F,
	-190.674F,
	-39.5508F,
	-151.123F,
	57.1289F,
	-161.865F,
	-72.5098F,
	-119.141F,
	-26.6113F,
	-235.352F,
	-32.2266F,
	-204.590F,
	-16.6016F,
	-205.811F,
	14.1602F,
	-271.484F,
	-20.9961F,
	-196.533F,
	-72.9980F,
	-230.469F,
	-61.7676F,
	-189.941F,
	-12.2070F,
	-235.596F,
	-134.033F,
	-85.9375F,
	-23.9258F,
	-242.188F,
	-83.7402F,
	-272.705F,
	-76.9043F,
	-272.705F,
	-74.9512F,
	-281.982F,
	-91.3086F,
	-155.518F,
	-56.1523F,
	-284.668F,
	-10.4980F,
	-317.139F,
	-24.4141F,
	-225.830F,
	-95.9473F,
	-311.035F,
	-146.484F,
	-168.213F,
	-31.7383F,
	-361.084F,
	-76.1719F,
	-322.510F,
	-62.0117F,
	-357.422F,
	-107.910F,
	-315.430F,
	-149.658F,
	-307.861F,
	-122.803F,
	-366.455F,
	-89.8438F,
	-322.754F,
	6.34766F,
	-349.609F,
	-16.1133F,
	-425.537F,
	-39.3066F,
	-401.367F,
	-114.014F,
	-429.688F,
	-133.789F,
	-340.088F,
	-138.672F,
	-379.883F,
	-212.646F,
	-364.990F,
	-252.441F,
	-338.623F,
	-139.404F,
	-468.018F,
	-128.906F,
	-435.303F,
	-30.0293F,
	-463.135F,
	-56.3965F,
	-501.465F,
	-78.8574F,
	-500.977F,
	-221.191F,
	-482.422F,
	-138.428F,
	-468.018F,
	-151.367F,
	-499.756F,
	-241.455F,
	-262.939F,
	-90.3320F,
	-495.850F,
	-171.875F,
	-574.951F,
	-182.861F,
	-668.945F,
	-265.869F,
	-466.064F,
	38.8184F,
	-491.211F,
	60.5469F,
	-152.832F,
	-30.0293F,
	-571.045F,
	-234.863F,
	-163.330F,
	-99.6094F,
	-336.670F,
	-286.621F,
	-110.352F,
	-88.8672F,
	-254.883F,
	-179.443F,
	-32.2266F,
	44.6777F,
	-395.508F,
	-183.594F,
	-133.545F,
	-74.9512F,
	-189.697F,
	-307.861F,
	-23.9258F,
	10.0098F,
	-214.844F,
	-266.357F,
	-62.7441F,
	23.6816F,
	-391.113F,
	-447.510F,
	7.56836F,
	-6.34766F,
	-157.227F,
	-136.963F,
	-43.9453F,
	-133.301F,
	-93.9941F,
	-267.334F,
	-100.098F,
	-195.801F,
	-101.074F,
	-201.904F,
	-111.572F,
	-236.816F,
	-119.629F,
	-270.752F,
	-52.4902F,
	-223.633F,
	-35.1563F,
	-228.760F,
	-120.361F,
	-309.814F,
	-126.221F,
	-367.920F,
	44.1895F,
	24.6582F,
	-81.0547F,
	-217.041F,
	-204.102F,
	-228.760F,
	-136.475F,
	-104.736F,
	-153.564F,
	-133.545F,
	-44.6777F,
	-82.2754F,
	-133.057F,
	-20.0195F,
	-61.0352F,
	-69.8242F,
	1.22070F,
	-32.2266F,
	-84.9609F,
	-61.5234F,
	-71.5332F,
	-115.234F,
	-38.5742F,
	24.4141F,
	-7.08008F,
	48.0957F,
	-57.6172F,
	-103.516F,
	-210.205F,
	-52.0020F,
	-34.1797F,
	-1.70898F,
	-104.248F,
	-108.154F,
	45.6543F,
	-23.6816F,
	-166.992F,
	-179.688F,
	-71.5332F,
	62.9883F,
	-89.8438F,
	-37.1094F,
	-36.6211F,
	95.7031F,
	-148.682F,
	42.7246F,
	-34.6680F,
	72.9980F,
	-33.6914F,
	37.1094F,
	-29.0527F,
	80.3223F,
	-118.652F,
	-12.6953F,
	71.5332F,
	48.3398F,
	-44.6777F,
	28.5645F,
	42.7246F,
	80.8105F,
	-14.1602F,
	-66.8945F,
	56.3965F,
	73.2422F,
	-70.3125F,
	80.5664F,
	-74.4629F,
	90.8203F,
	-27.0996F,
	99.8535F,
	-2.19727F,
	103.271F,
	20.2637F,
	62.5000F,
	16.3574F,
	89.5996F,
	-4.63867F,
	60.5469F,
	22.2168F,
	27.5879F,
	-8.54492F,
	99.1211F,
	-46.6309F,
	37.5977F,
	58.1055F,
	72.2656F,
	1.22070F,
	48.0957F,
	34.4238F,
	53.9551F,
	76.4160F,
	48.3398F,
	51.5137F,
	102.783F,
	59.5703F,
	81.5430F,
	21.4844F,
	104.004F,
	-59.3262F,
	110.840F,
	49.3164F,
	134.766F,
	-1.22070F,
	98.3887F,
	71.0449F,
	45.1660F,
	53.4668F,
	73.4863F,
	61.2793F,
	33.6914F,
	31.2500F,
	16.8457F,
	48.0957F,
	70.3125F,
	-34.1797F,
	-14.8926F,
	45.8984F,
	88.1348F,
	48.0957F,
	145.996F,
	107.910F,
	66.6504F,
	70.8008F,
	34.9121F,
	115.234F,
	117.676F,
	38.3301F,
	90.3320F,
	101.318F,
	78.3691F,
	90.8203F,
	93.9941F,
	98.1445F,
	134.766F,
	37.8418F,
	5.85938F,
	134.277F,
	64.2090F,
	-2.68555F,
	5.12695F,
	87.8906F,
	55.4199F,
	35.8887F,
	-62.0117F,
	103.516F,
	23.6816F,
	89.3555F,
	-3.17383F,
	91.5527F,
	34.4238F,
	109.619F,
	56.6406F,
	96.6797F,
	123.779F,
	115.723F,
	66.4063F,
	171.143F,
	79.1016F,
	88.3789F,
	-11.4746F,
	143.311F,
	36.1328F,
	132.568F,
	16.8457F,
	97.6563F,
	-12.4512F,
	136.963F,
	14.4043F,
	53.7109F,
	-2.44141F,
	85.9375F,
	35.8887F,
	50.2930F,
	51.5137F,
	159.424F,
	45.1660F,
	137.451F,
	72.5098F,
	137.939F,
	69.3359F,
	145.020F,
	29.5410F,
	187.012F,
	46.8750F,
	97.1680F,
	28.8086F,
	156.738F,
	105.957F,
	56.8848F,
	64.4531F,
	117.432F,
	114.014F,
	31.4941F,
	-40.2832F,
	170.654F,
	58.3496F,
	21.9727F,
	6.34766F,
	83.4961F,
	115.723F,
	-13.4277F,
	6.59180F,
	94.7266F,
	22.9492F,
	-41.9922F,
	0.000000F,
	177.002F,
	92.5293F,
	-14.6484F,
	82.2754F,
	90.3320F,
	113.525F,
	23.1934F,
	77.8809F,
	196.777F,
	145.264F,
	19.0430F,
	63.4766F,
	121.338F,
	207.764F,
	51.2695F,
	136.719F,
	111.816F,
	140.137F,
	-113.281F,
	49.3164F,
	121.338F,
	152.588F,
	-49.3164F,
	37.1094F,
	11.7188F,
	173.828F,
	-4.88281F,
	138.184F,
	24.4141F,
	174.561F,
	111.084F,
	114.258F,
	100.342F,
	147.705F,
	77.8809F,
	157.715F,
	47.6074F,
	150.146F,
	97.9004F,
	131.348F,
	166.016F,
	180.420F,
	49.0723F,
	162.842F,
	105.957F,
	232.910F,
	110.840F,
	103.760F,
	157.715F,
	119.873F,
	147.949F,
	166.260F,
	101.563F,
	124.023F,
	121.338F,
	200.684F,
	104.004F,
	198.975F,
	161.133F,
	157.959F,
	153.320F,
	174.805F,
	170.166F,
	113.770F,
	150.879F,
	111.572F,
	167.236F,
	112.305F,
	89.1113F,
	75.4395F,
	176.025F,
	138.428F,
	204.102F,
	146.729F,
	148.682F,
	73.2422F,
	201.416F,
	112.061F,
	230.225F,
	167.725F,
	166.260F,
	130.127F,
	223.389F,
	145.996F,
	144.287F,
	59.3262F,
	213.867F,
	110.107F,
	213.379F,
	102.539F,
	191.895F,
	77.3926F,
	178.711F,
	53.7109F,
	225.098F,
	77.3926F,
	270.508F,
	89.5996F,
	129.639F,
	113.770F,
	250.977F,
	158.447F,
	257.080F,
	150.146F,
	252.441F,
	135.010F,
	202.393F,
	146.973F,
	249.268F,
	195.068F,
	226.318F,
	196.045F,
	214.355F,
	186.279F,
	195.068F,
	121.094F,
	335.205F,
	188.721F,
	142.822F,
	187.988F,
	196.045F,
	227.051F,
	268.311F,
	193.604F,
	298.340F,
	210.449F,
	295.166F,
	218.506F,
	250.244F,
	177.490F,
	188.477F,
	206.299F,
	286.133F,
	272.217F,
	211.670F,
	249.268F,
	202.637F,
	247.314F,
	205.322F,
	222.168F,
	123.535F,
	171.631F,
	302.490F,
	262.939F,
	151.367F,
	199.951F,
	291.992F,
	264.404F,
	281.982F,
	263.916F,
	278.809F,
	221.436F,
	377.686F,
	273.682F,
	319.580F,
	158.203F,
	327.881F,
	149.414F,
	362.305F,
	241.211F,
	361.084F,
	228.760F,
	240.479F,
	324.219F,
	233.154F,
	327.393F,
	104.736F,
	222.168F,
	205.322F,
	326.660F,
	137.695F,
	287.842F,
	100.586F,
	282.227F,
	348.389F,
	322.266F,
	350.098F,
	324.707F,
	156.250F,
	185.547F,
	421.387F,
	344.238F,
	46.3867F,
	135.498F,
	261.963F,
	245.361F,
	104.004F,
	62.7441F,
	204.834F,
	239.258F,
	57.3730F,
	56.3965F,
	371.094F,
	284.912F,
	26.6113F,
	71.5332F,
	247.559F,
	383.057F,
	74.4629F,
	34.6680F,
	280.273F,
	131.592F,
	-71.0449F,
	-26.3672F,
	296.143F,
	237.305F,
	5.37109F,
	-52.7344F,
	162.842F,
	202.148F,
	-117.676F,
	106.934F,
	110.596F,
	349.365F,
	-141.846F,
	-103.027F,
	192.627F,
	94.4824F,
	-87.4023F,
	-110.840F,
	42.4805F,
	190.430F,
	-8.78906F,
	-90.8203F,
	95.2148F,
	-32.7148F,
	-153.564F,
	39.0625F,
	-74.7070F,
	183.350F,
	-307.129F,
	-80.8105F,
	43.2129F,
	127.441F,
	-60.5469F,
	140.137F,
	-61.2793F,
	156.006F,
	-129.639F,
	99.3652F,
	-145.508F,
	96.1914F,
	-102.295F,
	192.627F,
	-150.635F,
	195.557F,
	-240.723F,
	97.4121F,
	-209.229F,
	177.490F,
	-1.70898F,
	126.465F,
	-171.631F,
	75.6836F,
	-279.053F,
	-5.85938F,
	-244.629F,
	70.0684F,
	-234.375F,
	88.6230F,
	-317.139F,
	76.1719F,
	-374.512F,
	59.8145F,
	-380.127F,
	74.4629F,
	6.83594F,
	37.3535F,
	-209.717F,
	-42.7246F,
	-8.05664F,
	81.0547F,
	-341.309F,
	-37.5977F,
	51.7578F,
	100.098F,
	-144.775F,
	-48.0957F,
	-266.602F,
	-171.875F,
	-220.703F,
	-15.8691F,
	68.8477F,
	89.5996F,
	-224.121F,
	-167.480F,
	84.2285F,
	22.7051F,
	-62.9883F,
	-87.1582F,
	169.922F,
	157.227F,
	-169.189F,
	-6.83594F,
	109.375F,
	120.361F,
	-66.6504F,
	47.1191F,
	128.662F,
	133.301F,
	-59.3262F,
	-125.244F,
	93.7500F,
	-33.2031F,
	66.6504F,
	-86.1816F,
	125.000F,
	-34.6680F,
	131.104F,
	-48.3398F,
	229.736F,
	183.105F,
	20.2637F,
	60.5469F,
	141.113F,
	210.205F,
	-13.6719F,
	144.531F,
	205.566F,
	10.7422F,
	217.773F,
	5.85938F,
	8.05664F,
	217.285F,
	-3.90625F,
	239.746F,
	202.881F,
	341.309F,
	374.756F,
	463.379F,
	418.945F,
	335.938F,
	475.586F,
	357.666F
};
__device__ static const Float32 dico5_lsf_5[DICO5_SIZE_5 * 4] =
{
	-244.629F,
	-226.807F,
	-267.578F,
	-293.701F,
	-156.494F,
	-227.295F,
	-147.461F,
	-234.619F,
	-190.186F,
	-164.307F,
	-203.857F,
	-192.383F,
	-101.563F,
	-162.109F,
	-111.816F,
	-187.012F,
	-159.180F,
	-127.197F,
	-161.621F,
	-120.850F,
	-249.756F,
	-124.268F,
	-249.756F,
	-104.492F,
	-108.398F,
	-134.766F,
	-89.8438F,
	-109.619F,
	-116.943F,
	-51.5137F,
	-257.324F,
	-220.459F,
	-77.1484F,
	-60.7910F,
	-138.916F,
	-144.287F,
	-138.916F,
	-67.1387F,
	-132.080F,
	-46.6309F,
	-174.805F,
	-45.8984F,
	-205.566F,
	-64.4531F,
	-81.2988F,
	-60.5469F,
	-77.6367F,
	-55.6641F,
	-67.1387F,
	0.244141F,
	-138.428F,
	-55.6641F,
	-28.0762F,
	-53.9551F,
	-58.1055F,
	-91.3086F,
	-48.0957F,
	-123.779F,
	-54.1992F,
	-141.357F,
	-62.9883F,
	-105.469F,
	-14.8926F,
	-59.5703F,
	-84.2285F,
	0.488281F,
	-82.5195F,
	9.52148F,
	-52.4902F,
	-41.2598F,
	-14.1602F,
	0.000000F,
	-13.6719F,
	-1.46484F,
	-49.5605F,
	-31.9824F,
	0.244141F,
	-45.4102F,
	-1.22070F,
	-51.5137F,
	1.46484F,
	-92.7734F,
	2.68555F,
	-102.051F,
	-28.3203F,
	31.9824F,
	-32.7148F,
	27.5879F,
	21.7285F,
	-0.976563F,
	17.3340F,
	-0.488281F,
	-4.63867F,
	-46.8750F,
	63.9648F,
	5.85938F,
	46.1426F,
	36.8652F,
	-32.4707F,
	-26.6113F,
	45.4102F,
	-37.3535F,
	40.5273F,
	-53.4668F,
	9.03320F,
	33.9355F,
	47.1191F,
	41.7480F,
	82.2754F,
	30.2734F,
	38.5742F,
	-14.8926F,
	34.4238F,
	55.1758F,
	-3.17383F,
	46.3867F,
	56.3965F,
	8.30078F,
	86.4258F,
	26.6113F,
	77.1484F,
	49.0723F,
	59.5703F,
	40.0391F,
	80.5664F,
	-20.7520F,
	95.2148F,
	-20.5078F,
	62.0117F,
	79.8340F,
	62.7441F,
	81.7871F,
	119.873F,
	35.8887F,
	116.211F,
	25.6348F,
	13.1836F,
	18.7988F,
	106.689F,
	90.3320F,
	102.783F,
	76.6602F,
	109.619F,
	83.4961F,
	80.3223F,
	30.7617F,
	164.307F,
	71.2891F,
	139.404F,
	94.7266F,
	59.3262F,
	47.1191F,
	159.424F,
	78.1250F,
	151.611F,
	68.3594F,
	47.3633F,
	92.7734F,
	126.221F,
	141.846F,
	10.9863F,
	78.8574F,
	27.0996F,
	103.027F,
	119.385F,
	96.4355F,
	179.199F,
	130.371F,
	151.855F,
	133.301F,
	118.652F,
	122.559F,
	77.6367F,
	139.648F,
	46.1426F,
	134.277F,
	93.9941F,
	103.027F,
	-38.3301F,
	37.3535F,
	-30.5176F,
	93.2617F,
	-48.0957F,
	94.2383F,
	-64.2090F,
	81.5430F,
	55.6641F,
	170.166F,
	-45.8984F,
	0.244141F,
	12.4512F,
	72.5098F,
	-123.779F,
	52.0020F,
	-91.7969F,
	96.9238F,
	-5.85938F,
	62.2559F,
	-133.545F,
	21.7285F,
	-122.559F,
	-22.9492F,
	94.4824F,
	43.7012F,
	-151.367F,
	16.6016F,
	-166.992F,
	27.3438F,
	-156.738F,
	-85.4492F,
	-63.4766F,
	41.9922F,
	-106.934F,
	-79.1016F,
	64.4531F,
	158.203F,
	-235.352F,
	-0.976563F,
	-273.682F,
	1.70898F,
	-32.7148F,
	32.7148F,
	-276.611F,
	-74.7070F,
	34.9121F,
	23.4375F,
	-102.539F,
	-121.338F,
	-298.096F,
	-85.4492F,
	-372.803F,
	-167.236F,
	-39.3066F,
	17.5781F,
	213.135F,
	168.701F,
	178.711F,
	69.0918F,
	224.854F,
	86.1816F,
	81.5430F,
	115.967F,
	267.334F,
	200.439F,
	210.938F,
	127.930F,
	205.811F,
	121.338F,
	174.316F,
	173.584F,
	192.383F,
	183.105F,
	262.695F,
	174.316F,
	293.945F,
	183.838F,

};

/* Table for MR475 gain */
#define MR475_VQ_SIZE 256

/* The table contains the following data:
*
*    g_pitch(0)         // for sub-
*    g_fac(0)           // frame 0 and 2
*    g_pitch(1)         // for sub-
*    g_fac(1)           // frame 1 and 3
*
*/
__device__ static const Float32 table_gain_MR475[MR475_VQ_SIZE * 4] =
{
	0.049561F, 0.031250F,
	0.033081F, 0.034180F,
	0.175354F, 0.277100F,
	0.138306F, 0.830566F,
	0.126160F, 0.137451F,
	0.773743F, 0.157959F,
	0.252197F, 0.438965F,
	0.341858F, 1.290283F,
	0.469299F, 0.091309F,
	0.227966F, 0.107666F,
	0.666016F, 0.644043F,
	0.720642F, 0.608887F,
	1.250610F, 0.194580F,
	0.318481F, 0.164795F,
	0.410400F, 2.039551F,
	0.322388F, 0.414063F,
	0.090820F, 0.104492F,
	0.359009F, 0.110352F,
	0.325439F, 0.994141F,
	0.218689F, 0.309570F,
	0.150696F, 0.219971F,
	0.970093F, 0.245361F,
	0.914429F, 0.798584F,
	0.630554F, 1.186035F,
	0.221863F, 0.493408F,
	0.158447F, 0.203857F,
	0.754395F, 1.194336F,
	0.744995F, 0.416016F,
	0.819824F, 0.391602F,
	0.556519F, 0.571533F,
	0.242188F, 0.375488F,
	0.334412F, 2.425781F,
	0.231628F, 0.101807F,
	0.082947F, 0.101074F,
	0.222168F, 0.383057F,
	0.487976F, 0.864502F,
	0.696106F, 0.157471F,
	0.521973F, 0.155029F,
	0.247559F, 0.336182F,
	1.013672F, 1.495117F,
	0.697021F, 0.170898F,
	0.122498F, 0.148193F,
	0.757751F, 0.385254F,
	0.678650F, 1.136230F,
	0.834961F, 0.416992F,
	0.731812F, 0.300049F,
	0.488037F, 1.781494F,
	0.807556F, 1.395264F,
	0.148193F, 0.282959F,
	0.126526F, 0.473877F,
	0.379517F, 1.494385F,
	0.216431F, 0.440430F,
	0.544739F, 0.439941F,
	0.529724F, 0.385742F,
	0.850525F, 0.873047F,
	0.812561F, 1.522705F,
	0.374878F, 0.275879F,
	0.365845F, 0.423340F,
	0.863098F, 1.138184F,
	0.687927F, 0.810791F,
	0.746216F, 0.378662F,
	0.850281F, 0.736084F,
	0.310120F, 2.554688F,
	0.576416F, 1.637207F,
	0.103088F, 0.166748F,
	0.087646F, 0.318848F,
	0.440186F, 0.960205F,
	0.249146F, 0.662354F,
	0.475647F, 0.171875F,
	0.919800F, 0.195801F,
	0.384460F, 1.272461F,
	0.264709F, 1.307861F,
	0.407471F, 0.132080F,
	0.369995F, 0.152832F,
	0.833191F, 0.903320F,
	0.701782F, 0.587891F,
	0.986084F, 0.174805F,
	0.743225F, 0.183350F,
	0.492249F, 2.804932F,
	0.385376F, 0.550781F,
	0.272583F, 0.121094F,
	0.445129F, 0.127686F,
	0.623352F, 0.935791F,
	0.512329F, 0.741455F,
	0.512878F, 0.235840F,
	0.868408F, 0.458984F,
	0.531189F, 1.320557F,
	1.000671F, 1.187256F,
	0.452881F, 0.483154F,
	0.371643F, 0.300293F,
	0.571960F, 1.073730F,
	0.888550F, 0.821045F,
	0.827576F, 0.701416F,
	0.803406F, 0.357666F,
	0.337769F, 0.409668F,
	0.801880F, 3.606201F,
	0.447876F, 0.146484F,
	0.080444F, 0.133789F,
	0.259521F, 0.864014F,
	0.613037F, 0.577148F,
	0.646179F, 0.151855F,
	0.798828F, 0.163330F,
	0.862183F, 0.860840F,
	0.307556F, 2.388672F,
	0.936157F, 0.151123F,
	0.190125F, 0.144043F,
	1.003540F, 0.735596F,
	0.948608F, 1.017578F,
	0.948303F, 0.393311F,
	0.940247F, 0.299805F,
	0.977966F, 2.270264F,
	0.459839F, 1.214844F,
	0.121460F, 0.296143F,
	0.698669F, 0.282471F,
	0.763672F, 1.347412F,
	0.578308F, 0.645508F,
	0.470947F, 0.496582F,
	0.810547F, 0.546631F,
	0.977234F, 1.243408F,
	0.492310F, 1.650635F,
	0.615417F, 0.344971F,
	0.305298F, 0.572998F,
	0.764343F, 1.458740F,
	0.923218F, 0.707764F,
	1.114746F, 0.558838F,
	0.966003F, 0.616943F,
	0.992737F, 2.503418F,
	0.894226F, 2.763428F,
	0.109680F, 0.082275F,
	0.190125F, 0.096924F,
	0.214233F, 0.714844F,
	0.280273F, 0.651855F,
	0.458923F, 0.153320F,
	0.696716F, 0.160156F,
	0.362915F, 0.594482F,
	0.399414F, 1.798584F,
	0.502808F, 0.202393F,
	0.244141F, 0.210693F,
	0.612305F, 0.608398F,
	0.980042F, 0.866943F,
	1.111084F, 0.257324F,
	0.372498F, 0.354980F,
	0.359131F, 1.928711F,
	1.144531F, 0.846680F,
	0.113770F, 0.132813F,
	0.561401F, 0.166748F,
	0.709412F, 1.015625F,
	0.280396F, 0.401367F,
	0.192749F, 0.282471F,
	0.973694F, 0.625000F,
	0.753723F, 0.911377F,
	1.063232F, 1.284180F,
	0.372681F, 0.489258F,
	0.178040F, 0.425293F,
	1.005066F, 1.283447F,
	1.024597F, 0.410156F,
	1.050110F, 0.429443F,
	0.291321F, 0.788818F,
	0.450806F, 1.473389F,
	0.875366F, 2.444336F,
	0.246277F, 0.107910F,
	0.255981F, 0.111816F,
	0.562378F, 0.547363F,
	0.453308F, 1.029541F,
	0.784912F, 0.195557F,
	0.682739F, 0.201416F,
	0.771973F, 0.508789F,
	0.790771F, 1.600098F,
	0.580139F, 0.243164F,
	0.404602F, 0.240479F,
	0.643127F, 0.610840F,
	0.933167F, 1.222168F,
	0.769165F, 0.501709F,
	0.945068F, 0.403564F,
	0.988403F, 1.689697F,
	0.868591F, 1.413574F,
	0.160278F, 0.202148F,
	0.342712F, 0.411621F,
	0.833923F, 1.410645F,
	0.223877F, 0.379395F,
	0.690491F, 0.642822F,
	0.596313F, 0.356201F,
	0.854675F, 1.155518F,
	0.970276F, 1.535889F,
	0.383179F, 0.456543F,
	0.482788F, 0.557861F,
	1.036255F, 1.115967F,
	1.011719F, 0.939697F,
	0.930664F, 0.564209F,
	0.977966F, 0.791992F,
	0.882507F, 4.347656F,
	0.723083F, 0.674561F,
	0.120911F, 0.343506F,
	0.085449F, 0.213867F,
	0.264587F, 0.865967F,
	0.268005F, 1.027832F,
	0.329895F, 0.166016F,
	1.065735F, 0.190674F,
	0.396790F, 1.249512F,
	0.493835F, 1.874268F,
	0.448914F, 0.193848F,
	0.508606F, 0.288574F,
	0.918030F, 0.771484F,
	0.911133F, 0.741943F,
	1.246399F, 0.214844F,
	0.887756F, 0.208008F,
	0.752991F, 3.590820F,
	0.421387F, 0.468750F,
	0.257874F, 0.227783F,
	0.501587F, 0.265381F,
	0.650574F, 0.997070F,
	0.615356F, 1.106689F,
	0.166931F, 0.205078F,
	1.260803F, 0.263916F,
	1.019958F, 1.456543F,
	0.968811F, 1.117676F,
	0.663513F, 0.628418F,
	0.230286F, 0.284668F,
	0.886169F, 0.987305F,
	1.263367F, 0.641357F,
	0.928894F, 0.667480F,
	0.932251F, 0.533691F,
	0.381897F, 0.787598F,
	0.801086F, 4.755859F,
	0.439209F, 0.227051F,
	0.150269F, 0.395020F,
	0.275574F, 0.754883F,
	0.845459F, 1.044189F,
	0.638428F, 0.203369F,
	1.058289F, 0.197754F,
	1.030945F, 0.558838F,
	0.948853F, 2.006104F,
	0.830261F, 0.411133F,
	0.195129F, 0.447754F,
	0.973389F, 0.688477F,
	0.965088F, 1.300537F,
	1.037964F, 0.595215F,
	1.024658F, 0.323730F,
	0.956482F, 1.991211F,
	0.715698F, 2.088867F,
	0.229614F, 0.501221F,
	0.583679F, 0.321533F,
	0.827698F, 1.657715F,
	0.746277F, 0.472656F,
	0.499268F, 0.866699F,
	0.810974F, 0.434082F,
	0.994812F, 1.611084F,
	0.994324F, 1.894043F,
	0.520081F, 0.622803F,
	0.440979F, 0.645752F,
	1.115051F, 1.828369F,
	1.030579F, 0.548828F,
	1.091431F, 0.704102F,
	1.053772F, 0.812500F,
	0.574768F, 4.922363F,
	0.673950F, 2.031250F,
	0.078491F, 0.151367F,
	0.087341F, 0.142334F,
	0.365784F, 0.558838F,
	0.242798F, 0.885254F,
	0.313965F, 0.183594F,
	0.818420F, 0.202637F,
	0.338928F, 0.698242F,
	0.718018F, 1.442383F,
	0.655334F, 0.136719F,
	0.332397F, 0.137695F,
	0.813049F, 0.734375F,
	0.729126F, 0.899170F,
	1.213806F, 0.194824F,
	0.599670F, 0.177734F,
	0.833923F, 2.135742F,
	0.451111F, 0.745361F,
	0.153503F, 0.189941F,
	0.369263F, 0.203369F,
	0.394836F, 1.238770F,
	0.506897F, 0.601318F,
	0.374817F, 0.455322F,
	0.934326F, 0.308105F,
	0.879395F, 1.110107F,
	0.833923F, 1.102295F,
	0.191467F, 0.728271F,
	0.151306F, 0.307373F,
	0.920898F, 1.134521F,
	0.938843F, 0.636475F,
	0.884521F, 0.583984F,
	0.760620F, 0.619385F,
	0.460144F, 0.719971F,
	0.787903F, 2.944336F,
	0.333740F, 0.166992F,
	0.191711F, 0.176270F,
	0.310120F, 0.311035F,
	0.777100F, 1.025391F,
	0.933960F, 0.166260F,
	0.477234F, 0.144531F,
	0.398804F, 0.493408F,
	1.005737F, 2.133057F,
	0.815674F, 0.215332F,
	0.329407F, 0.219482F,
	0.894531F, 0.531738F,
	0.899719F, 1.031982F,
	0.870972F, 0.316895F,
	0.850159F, 0.495361F,
	0.944641F, 1.826660F,
	0.965271F, 1.116211F,
	0.153870F, 0.491455F,
	0.308960F, 0.440430F,
	0.314880F, 1.606934F,
	0.435181F, 0.878174F,
	0.666504F, 0.393311F,
	0.715881F, 0.416992F,
	1.031677F, 0.843506F,
	0.992920F, 1.621094F,
	0.567993F, 0.245850F,
	0.571838F, 0.514160F,
	1.170776F, 1.229736F,
	0.759338F, 1.042236F,
	0.971619F, 0.325195F,
	0.937317F, 0.857422F,
	0.726196F, 3.452393F,
	0.982727F, 1.673340F,
	0.122681F, 0.179932F,
	0.230652F, 0.210205F,
	0.699097F, 0.703125F,
	0.217529F, 0.864258F,
	0.552795F, 0.302979F,
	0.756287F, 0.218750F,
	0.521606F, 1.130127F,
	0.705627F, 1.410156F,
	0.496155F, 0.143799F,
	0.501587F, 0.143555F,
	1.143066F, 0.916748F,
	0.791809F, 0.768799F,
	0.960022F, 0.185059F,
	1.015259F, 0.184082F,
	0.929077F, 2.719238F,
	0.968689F, 0.539063F,
	0.285217F, 0.148926F,
	0.623657F, 0.165527F,
	0.931213F, 1.012207F,
	0.349670F, 0.812256F,
	0.511292F, 0.407715F,
	1.212280F, 0.566650F,
	0.942993F, 1.345459F,
	0.857788F, 1.338135F,
	0.349609F, 0.705078F,
	0.462646F, 0.328613F,
	0.877930F, 1.300049F,
	0.990967F, 0.964355F,
	0.922729F, 0.914063F,
	0.934204F, 0.350342F,
	0.890930F, 0.993652F,
	0.750793F, 3.832031F,
	0.464905F, 0.414795F,
	0.132446F, 0.215820F,
	0.272156F, 1.114990F,
	1.104370F, 0.807129F,
	0.777710F, 0.198975F,
	0.911011F, 0.221436F,
	0.916504F, 1.045166F,
	0.947144F, 2.042969F,
	1.098267F, 0.265381F,
	0.143921F, 0.211182F,
	0.993713F, 0.924561F,
	0.956970F, 1.122070F,
	0.998291F, 0.374512F,
	1.012207F, 0.539551F,
	1.027405F, 2.367432F,
	0.972229F, 1.101807F,
	0.200012F, 0.264893F,
	0.588562F, 0.533936F,
	0.730774F, 1.481445F,
	0.561462F, 1.089355F,
	0.546570F, 0.397705F,
	0.627991F, 0.747559F,
	1.005920F, 1.258545F,
	0.943970F, 1.725098F,
	0.834839F, 0.620850F,
	0.321838F, 0.555908F,
	1.022095F, 1.516846F,
	1.016541F, 0.832031F,
	1.239258F, 0.821045F,
	1.140625F, 0.484619F,
	0.864990F, 3.141357F,
	0.924927F, 3.833740F,
	0.273010F, 0.249023F,
	0.102600F, 0.216309F,
	0.263123F, 1.050049F,
	0.546387F, 0.892822F,
	0.359680F, 0.280029F,
	0.710876F, 0.354492F,
	0.969604F, 0.543701F,
	0.279663F, 1.622070F,
	0.422913F, 0.294189F,
	0.379639F, 0.195068F,
	0.757751F, 0.832275F,
	0.974609F, 0.946533F,
	1.212097F, 0.514893F,
	0.591370F, 0.522705F,
	0.899780F, 2.155762F,
	0.883789F, 0.634521F,
	0.110901F, 0.302246F,
	0.474304F, 0.198486F,
	1.164490F, 1.076660F,
	0.338989F, 0.503906F,
	0.225037F, 0.694336F,
	1.064148F, 0.550781F,
	1.019104F, 1.095215F,
	0.988708F, 1.315430F,
	0.489990F, 0.674561F,
	0.207825F, 0.517334F,
	1.063599F, 1.337158F,
	0.836060F, 0.680176F,
	1.213318F, 0.664063F,
	0.555298F, 0.947266F,
	1.109131F, 1.179932F,
	1.058105F, 2.980225F,
	0.312256F, 0.243164F,
	0.301208F, 0.241211F,
	0.603516F, 0.752197F,
	0.367065F, 1.311279F,
	0.969299F, 0.406982F,
	0.513000F, 0.288818F,
	0.920837F, 0.577637F,
	1.207092F, 1.709473F,
	0.730164F, 0.381348F,
	0.444275F, 0.275391F,
	1.028992F, 0.374023F,
	0.962036F, 1.313721F,
	0.897705F, 0.504150F,
	1.227112F, 0.526123F,
	1.047241F, 2.012939F,
	1.093201F, 1.542480F,
	0.333679F, 0.367188F,
	0.250244F, 0.628418F,
	1.063293F, 1.662598F,
	0.346252F, 0.705078F,
	1.015381F, 0.825684F,
	0.547791F, 0.447021F,
	1.230408F, 1.156494F,
	1.193237F, 1.780762F,
	0.406372F, 0.678955F,
	0.700195F, 0.810791F,
	1.183899F, 1.233887F,
	1.152222F, 1.152832F,
	1.003357F, 0.579346F,
	1.246948F, 1.070801F,
	0.692932F, 6.476074F,
	0.707581F, 0.749023F,
	0.174927F, 0.382324F,
	0.311768F, 0.261230F,
	0.586792F, 1.199951F,
	0.301453F, 0.863281F,
	0.460266F, 0.214355F,
	1.264465F, 0.207764F,
	0.423462F, 1.072998F,
	1.025330F, 1.887939F,
	0.618713F, 0.248779F,
	0.600891F, 0.235352F,
	0.945679F, 0.965576F,
	0.943542F, 0.837402F,
	1.151306F, 0.239746F,
	1.228027F, 0.235107F,
	1.030029F, 3.146240F,
	0.874878F, 1.025391F,
	0.402771F, 0.297852F,
	0.562866F, 0.198730F,
	1.034058F, 1.253418F,
	0.345520F, 1.195801F,
	0.334961F, 0.438965F,
	1.236450F, 0.967285F,
	1.037903F, 1.508301F,
	1.094299F, 1.447510F,
	0.571594F, 0.834961F,
	0.456177F, 0.481201F,
	1.192444F, 1.263916F,
	1.159851F, 0.733887F,
	1.004272F, 0.924805F,
	0.980835F, 0.577881F,
	0.528809F, 0.669678F,
	0.576477F, 6.435059F,
	0.662598F, 0.314209F,
	0.216980F, 0.246338F,
	0.342163F, 0.884277F,
	1.187317F, 1.345703F,
	0.760071F, 0.194580F,
	1.259399F, 0.222412F,
	0.941589F, 0.748535F,
	1.039856F, 2.508545F,
	1.152527F, 0.642822F,
	0.238831F, 0.309570F,
	1.191345F, 0.822998F,
	1.101807F, 1.276855F,
	1.177429F, 0.409668F,
	1.190674F, 0.774414F,
	1.103027F, 2.625488F,
	1.014709F, 1.671143F,
	0.191284F, 0.561035F,
	0.663391F, 0.594971F,
	0.950928F, 1.687744F,
	0.768860F, 0.825439F,
	0.678467F, 0.804932F,
	1.023071F, 0.591797F,
	1.150696F, 1.639404F,
	1.048035F, 2.413818F,
	0.777771F, 0.635986F,
	0.545471F, 0.766602F,
	1.161682F, 1.895508F,
	1.119812F, 0.947266F,
	1.249695F, 0.898926F,
	1.196411F, 0.825195F,
	0.796143F, 4.729736F,
	0.642456F, 5.645508F,

};

/*
*    g_pitch        ,
*    g_fac          , (g_code = g_code0*g_fac),
*/
/* table used in 'high' rates: MR67 MR74 MR102 */
#define VQ_SIZE_HIGHRATES 128
__device__ static const Float32 table_highrates[VQ_SIZE_HIGHRATES * 2] =
{
	/*g_pit,    g_fac,   */
	0.0352173F,   0.161621F,
	0.0491943F,   0.448242F,
	0.189758F,   0.256836F,
	0.255188F,   0.338623F,
	0.144836F,   0.347900F,
	0.198242F,   0.484619F,
	0.111511F,   0.566406F,
	0.0574341F,   0.809082F,
	0.143494F,   0.726807F,
	0.220703F,   0.590820F,
	0.210632F,   0.755859F,
	0.180359F,   1.05005F,
	0.112793F,   1.09863F,
	0.237061F,   1.32227F,
	0.0724487F,   1.76025F,
	0.188171F,   2.19727F,
	0.450684F,   0.215576F,
	0.363892F,   0.367676F,
	0.314636F,   0.520996F,
	0.484863F,   0.490479F,
	0.397156F,   0.549316F,
	0.468140F,   0.671875F,
	0.363281F,   0.736328F,
	0.298950F,   0.918945F,
	0.426575F,   0.875977F,
	0.498901F,   0.971191F,
	0.370117F,   1.07520F,
	0.470520F,   1.24194F,
	0.337097F,   1.46997F,
	0.474182F,   1.73975F,
	0.369873F,   1.93799F,
	0.341431F,   2.80444F,
	0.645813F,   0.331055F,
	0.552307F,   0.389893F,
	0.597778F,   0.496826F,
	0.546021F,   0.589600F,
	0.628418F,   0.630859F,
	0.574158F,   0.667480F,
	0.531006F,   0.785645F,
	0.595520F,   0.828857F,
	0.621155F,   0.950195F,
	0.559692F,   1.10547F,
	0.619629F,   1.22168F,
	0.556274F,   1.40015F,
	0.640869F,   1.52979F,
	0.617065F,   1.86304F,
	0.539795F,   2.13062F,
	0.546631F,   3.05078F,
	0.788818F,   0.238281F,
	0.697937F,   0.428467F,
	0.740845F,   0.568359F,
	0.695068F,   0.578125F,
	0.653076F,   0.748047F,
	0.752686F,   0.698486F,
	0.715454F,   0.812256F,
	0.687866F,   0.903320F,
	0.662903F,   1.07739F,
	0.737427F,   1.10669F,
	0.688660F,   1.27075F,
	0.729980F,   1.53931F,
	0.681580F,   1.83936F,
	0.740234F,   2.03345F,
	0.669495F,   2.63110F,
	0.628662F,   4.24219F,
	0.848328F,   0.410400F,
	0.767822F,   0.499268F,
	0.809631F,   0.595459F,
	0.856506F,   0.729736F,
	0.821045F,   0.756348F,
	0.756592F,   0.893066F,
	0.824585F,   0.922852F,
	0.786133F,   1.04297F,
	0.825989F,   1.18677F,
	0.773132F,   1.33228F,
	0.845581F,   1.49072F,
	0.795349F,   1.58276F,
	0.827454F,   1.88501F,
	0.790833F,   2.27319F,
	0.837036F,   2.82007F,
	0.768494F,   3.71240F,
	0.922424F,   0.375977F,
	0.919922F,   0.569580F,
	0.886658F,   0.613037F,
	0.896729F,   0.781006F,
	0.938843F,   0.869141F,
	0.862610F,   0.966797F,
	0.921753F,   1.03418F,
	0.874756F,   1.17773F,
	0.906128F,   1.33081F,
	0.934204F,   1.48511F,
	0.874573F,   1.68164F,
	0.919189F,   1.87720F,
	0.879272F,   2.30127F,
	0.939148F,   2.37817F,
	0.904785F,   3.48413F,
	0.830078F,   6.08862F,
	1.00073F,   0.480713F,
	1.02643F,   0.691406F,
	0.959045F,   0.694092F,
	0.982910F,   0.814453F,
	1.00000F,   0.967529F,
	1.03394F,   1.11792F,
	0.958923F,   1.12280F,
	0.990112F,   1.33008F,
	1.02734F,   1.55811F,
	0.960999F,   1.74341F,
	0.996460F,   1.82349F,
	1.01385F,   2.10547F,
	1.03931F,   2.54346F,
	0.970764F,   2.88501F,
	1.03015F,   3.58643F,
	1.00800F,   5.09521F,
	1.10730F,   0.508545F,
	1.18414F,   0.775879F,
	1.06860F,   0.836426F,
	1.22400F,   0.983154F,
	1.10284F,   1.03735F,
	1.15674F,   1.23682F,
	1.08099F,   1.31885F,
	1.21063F,   1.51172F,
	1.09558F,   1.71240F,
	1.30115F,   1.92310F,
	1.09314F,   2.26782F,
	1.16846F,   2.26807F,
	1.25226F,   2.77856F,
	1.10321F,   3.53638F,
	1.22064F,   4.36572F,
	1.15002F,   7.99902F
};


/* table used in 'low' rates: MR475, MR515, MR59 */
#define VQ_SIZE_LOWRATES 64
__device__ static const Float32 table_lowrates[VQ_SIZE_LOWRATES * 2] =
{
	/*g_pit,    g_fac */
	0.659973F,   7.01978F,
	1.25000F,   0.679932F,
	1.14996F,   1.60986F,
	0.379944F,   1.80981F,
	1.04999F,   2.54980F,
	1.31995F,   0.309814F,
	1.28998F,   1.07983F,
	0.689941F,   0.379883F,
	1.15997F,   3.12988F,
	1.06000F,   0.609863F,
	1.08997F,   1.17993F,
	0.609985F,   0.609863F,
	1.06995F,   1.91992F,
	0.869995F,   0.459961F,
	0.969971F,   0.769775F,
	0.409973F,   0.439941F,
	1.10999F,   4.92993F,
	1.09998F,   0.739990F,
	1.01996F,   1.42993F,
	0.539978F,   0.979980F,
	0.969971F,   2.18994F,
	1.09998F,   0.339844F,
	1.01996F,   1.00000F,
	0.500000F,   0.159912F,
	0.929993F,   3.39990F,
	0.869995F,   0.759766F,
	0.859985F,   1.13989F,
	0.329956F,   0.659912F,
	0.819946F,   1.59985F,
	0.759949F,   0.219971F,
	0.759949F,   0.649902F,
	0.229980F,   0.159912F,
	0.899963F,   5.73999F,
	1.16998F,   0.599854F,
	1.22998F,   1.23999F,
	0.419983F,   1.00000F,
	1.25000F,   2.08984F,
	1.19995F,   0.179932F,
	1.15997F,   1.03979F,
	0.479980F,   0.509766F,
	0.699951F,   3.00000F,
	0.969971F,   0.359863F,
	0.959961F,   1.12988F,
	0.559998F,   0.349854F,
	0.979980F,   1.70996F,
	0.904968F,   0.179932F,
	0.919983F,   0.549805F,
	0.309998F,   0.299805F,
	0.809998F,   4.22998F,
	1.00995F,   0.569824F,
	0.919983F,   1.41992F,
	0.239990F,   0.899902F,
	0.869995F,   2.09985F,
	1.02997F,   0.189941F,
	0.919983F,   0.929932F,
	0.369995F,   0.149902F,
	0.569946F,   2.25977F,
	0.809998F,   0.429932F,
	0.809998F,   0.859863F,
	0.149963F,   0.479980F,
	0.699951F,   1.34985F,
	0.639954F,   0.179932F,
	0.709961F,   0.779785F,
	0.0899658F,   0.189941F
};


#define DTX_VQ_SIZE 47
__device__ static const Word32 qua_gain_code_MR122[NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + DTX_VQ_SIZE + 1] =
{
	-3776,
	-3394,
	-3005,
	-2615,
	-2345,
	-2138,
	-1932,
	-1726,
	-1518,
	-1314,
	-1106,
	-900,
	-694,
	-487,
	-281,
	-75,
	133,
	339,
	545,
	752,
	958,
	1165,
	1371,
	1577,
	1784,
	1991,
	2197,
	2404,
	2673,
	3060,
	3448,
	3836,
	/* high_rates */
	-2692,
	-1185,
	-2008,
	-1600,
	-1560,
	-1070,
	-840,
	-313,
	-471,
	-777,
	-414,
	72,
	139,
	413,
	835,
	1163,
	-2267,
	-1478,
	-963,
	-1052,
	-885,
	-588,
	-452,
	-125,
	-196,
	-43,
	107,
	320,
	569,
	818,
	977,
	1523,
	-1633,
	-1391,
	-1033,
	-780,
	-681,
	-597,
	-356,
	-277,
	-75,
	148,
	296,
	497,
	628,
	919,
	1117,
	1648,
	-2119,
	-1252,
	-835,
	-810,
	-429,
	-530,
	-307,
	-150,
	110,
	150,
	354,
	637,
	900,
	1049,
	1429,
	2135,
	-1316,
	-1026,
	-766,
	-465,
	-413,
	-167,
	-119,
	62,
	253,
	424,
	590,
	678,
	937,
	1213,
	1532,
	1938,
	-1445,
	-832,
	-723,
	-365,
	-207,
	-50,
	50,
	242,
	422,
	584,
	768,
	930,
	1231,
	1280,
	1844,
	2669,
	-1082,
	-545,
	-539,
	-303,
	-49,
	165,
	171,
	421,
	655,
	821,
	888,
	1100,
	1379,
	1565,
	1887,
	2406,
	-999,
	-375,
	-264,
	-25,
	54,
	314,
	409,
	610,
	795,
	966,
	1210,
	1210,
	1510,
	1866,
	2177,
	3072,
	/* low_rates */
	2879,
	-570,
	703,
	876,
	1383,
	-1731,
	113,
	-1430,
	1686,
	-731,
	244,
	-731,
	964,
	-1147,
	-387,
	-1213,
	2357,
	-445,
	528,
	-30,
	1158,
	-1594,
	0,
	-2708,
	1808,
	-406,
	193,
	-614,
	694,
	-2237,
	-637,
	-2708,
	2582,
	-755,
	318,
	0,
	1089,
	-2534,
	58,
	-995,
	1623,
	-1510,
	180,
	-1552,
	793,
	-2534,
	-884,
	-1780,
	2131,
	-831,
	518,
	-156,
	1096,
	-2454,
	-107,
	-2804,
	1204,
	-1247,
	-223,
	-1084,
	443,
	-2534,
	-367,
	-2454,
	/* MR475 */
	-5120,
	-4988,
	-1896,
	-274,
	-2932,
	-2726,
	-1216,
	376,
	-3536,
	-3293,
	-650,
	-733,
	-2418,
	-2664,
	1053,
	-1303,
	-3337,
	-3256,
	-9,
	-1732,
	-2237,
	-2076,
	-332,
	252,
	-1044,
	-2350,
	262,
	-1296,
	-1385,
	-827,
	-1447,
	1309,
	-3375,
	-3386,
	-1418,
	-215,
	-2731,
	-2754,
	-1610,
	594,
	-2610,
	-2821,
	-1409,
	189,
	-1292,
	-1779,
	853,
	492,
	-1865,
	-1103,
	593,
	-1211,
	-1213,
	-1407,
	-201,
	621,
	-1903,
	-1270,
	191,
	-310,
	-1435,
	-453,
	1386,
	728,
	-2646,
	-1689,
	-60,
	-609,
	-2602,
	-2409,
	356,
	396,
	-2991,
	-2775,
	-150,
	-785,
	-2577,
	-2506,
	1524,
	-881,
	-3119,
	-3041,
	-98,
	-442,
	-2134,
	-1151,
	411,
	254,
	-1075,
	-1777,
	105,
	-291,
	-524,
	-1519,
	-1318,
	1895,
	-2838,
	-2972,
	-216,
	-812,
	-2785,
	-2677,
	-221,
	1286,
	-2792,
	-2863,
	-454,
	26,
	-1379,
	-1780,
	1211,
	287,
	-1798,
	-1868,
	440,
	-647,
	-1034,
	-892,
	322,
	740,
	-1572,
	-823,
	558,
	-511,
	-860,
	-714,
	1356,
	1502,
	-3690,
	-3448,
	-496,
	-632,
	-2770,
	-2706,
	-768,
	867,
	-2360,
	-2301,
	-734,
	-211,
	-2005,
	-1530,
	970,
	-246,
	-2982,
	-2646,
	23,
	-1349,
	-1868,
	-694,
	-137,
	369,
	-1056,
	-1263,
	369,
	-1317,
	-1249,
	-351,
	572,
	1320,
	-3289,
	-3237,
	-890,
	43,
	-2411,
	-2367,
	-998,
	694,
	-2089,
	-2105,
	-728,
	296,
	-1019,
	-1341,
	775,
	511,
	-2362,
	-1311,
	508,
	-1432,
	-653,
	-1525,
	214,
	634,
	-1158,
	-862,
	162,
	-92,
	-846,
	-345,
	2171,
	-582,
	-1579,
	-2279,
	-213,
	40,
	-2653,
	-2448,
	329,
	928,
	-2424,
	-1836,
	-383,
	-441,
	-2272,
	-2320,
	1888,
	-1119,
	-2186,
	-1960,
	-4,
	150,
	-2341,
	-1968,
	555,
	164,
	-686,
	-1856,
	-19,
	-656,
	-597,
	-928,
	-353,
	2304,
	-2190,
	-1372,
	-416,
	64,
	-2353,
	-2394,
	-860,
	1028,
	-1313,
	-1187,
	-551,
	388,
	-767,
	-1666,
	1017,
	1088,
	-1020,
	-1676,
	747,
	-1107,
	-211,
	-1233,
	704,
	943,
	-700,
	-646,
	891,
	-886,
	-518,
	-307,
	2354,
	1047,
	-2789,
	-2880,
	-860,
	-180,
	-2504,
	-2358,
	-531,
	541,
	-2940,
	-2929,
	-456,
	-157,
	-2416,
	-2552,
	1121,
	-434,
	-2454,
	-2353,
	316,
	-752,
	-1162,
	-1739,
	154,
	144,
	-469,
	-1743,
	186,
	-668,
	-795,
	-708,
	-485,
	1595,
	-2644,
	-2564,
	-1725,
	37,
	-2651,
	-2858,
	-1044,
	1119,
	-2269,
	-2240,
	-933,
	47,
	-1698,
	-1038,
	890,
	162,
	-1049,
	-1211,
	701,
	-192,
	-1379,
	-1292,
	-251,
	714,
	-2073,
	-983,
	305,
	61,
	-1660,
	-227,
	1830,
	760,
	-2534,
	-2304,
	-520,
	-216,
	-1764,
	-2245,
	181,
	508,
	-2865,
	-2868,
	-128,
	-389,
	-2492,
	-2500,
	1478,
	-913,
	-2813,
	-2657,
	18,
	-307,
	-1326,
	-839,
	438,
	430,
	-516,
	-1644,
	388,
	-54,
	-133,
	-1550,
	-9,
	1985,
	-1300,
	-2265,
	161,
	-317,
	-2385,
	-2227,
	65,
	1055,
	-1960,
	-2297,
	-116,
	170,
	-1451,
	-912,
	1273,
	143,
	-1963,
	-927,
	581,
	126,
	-1362,
	-430,
	340,
	806,
	-704,
	-868,
	615,
	-272,
	-291,
	-1070,
	1691,
	1985,
	-2054,
	-2262,
	72,
	-168,
	-1881,
	-1532,
	-900,
	715,
	-1808,
	-2415,
	-271,
	-81,
	-981,
	-959,
	1135,
	-672,
	-1768,
	-2389,
	109,
	-1013,
	-539,
	-881,
	134,
	405,
	-582,
	-974,
	429,
	-569,
	-605,
	-80,
	244,
	1613,
	-2089,
	-2101,
	-421,
	400,
	-1328,
	-1835,
	-811,
	792,
	-1424,
	-1905,
	-1453,
	403,
	-1012,
	-949,
	1033,
	640,
	-1480,
	-686,
	751,
	-516,
	-283,
	-1190,
	215,
	852,
	-572,
	-310,
	310,
	210,
	-806,
	101,
	2760,
	-427,
	-1420,
	-1983,
	269,
	-217,
	-2275,
	-2321,
	104,
	939,
	-2055,
	-2137,
	-52,
	-262,
	-2110,
	-2139,
	1693,
	37,
	-1789,
	-2387,
	334,
	264,
	-1216,
	-49,
	607,
	546,
	-267,
	-1081,
	346,
	-457,
	-116,
	-810,
	-592,
	2750,
	-1710,
	-2070,
	-182,
	439,
	-2418,
	-2221,
	-428,
	1359,
	-653,
	-1732,
	-288,
	361,
	-1318,
	-378,
	1426,
	759,
	-854,
	-767,
	773,
	-283,
	-321,
	-775,
	730,
	1302,
	-669,
	-393,
	945,
	-80,
	-158,
	-284,
	2295,
	2557,
	/* dtx */
	-1921,
	-1878,
	-1836,
	-1793,
	-1751,
	-1708,
	-1666,
	-1623,
	-1581,
	-1538,
	-1495,
	-1453,
	-1410,
	-1368,
	-1325,
	-1283,
	-1240,
	-1198,
	-1155,
	-1113,
	-1070,
	-1028,
	-985,
	-943,
	-900,
	-858,
	-815,
	-773,
	-730,
	-688,
	-645,
	-602,
	-560,
	-517,
	-475,
	-432,
	-390,
	-347,
	-305,
	-262,
	-220,
	-177,
	-135,
	-92,
	-50,
	-7,
	0,
	/* init value */
	-2381
};


__device__ static const Word32 qua_gain_code[NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + DTX_VQ_SIZE + 3] =
{
	-22731,
	-20428,
	-18088,
	-15739,
	-14113,
	-12867,
	-11629,
	-10387,
	-9139,
	-7906,
	-6656,
	-5416,
	-4173,
	-2931,
	-1688,
	-445,
	801,
	2044,
	3285,
	4530,
	5772,
	7016,
	8259,
	9501,
	10745,
	11988,
	13231,
	14474,
	16096,
	18429,
	20763,
	23097,
	/* high rates */
	-16214,
	-7135,
	-12086,
	-9629,
	-9394,
	-6442,
	-5056,
	-1885,
	-2838,
	-4681,
	-2490,
	434,
	836,
	2484,
	5030,
	7002,
	-13647,
	-8900,
	-5800,
	-6335,
	-5327,
	-3537,
	-2724,
	-751,
	-1177,
	-260,
	645,
	1928,
	3426,
	4926,
	5885,
	9172,
	-9831,
	-8380,
	-6220,
	-4700,
	-4099,
	-3595,
	-2144,
	-1669,
	-454,
	891,
	1781,
	2993,
	3782,
	5534,
	6728,
	9921,
	-12753,
	-7539,
	-5024,
	-4872,
	-2580,
	-3192,
	-1848,
	-904,
	663,
	902,
	2132,
	3837,
	5420,
	6312,
	8604,
	12853,
	-7921,
	-6179,
	-4610,
	-2802,
	-2482,
	-1006,
	-713,
	374,
	1523,
	2552,
	3551,
	4084,
	5639,
	7304,
	9221,
	11667,
	-8700,
	-5007,
	-4352,
	-2197,
	-1247,
	-300,
	298,
	1454,
	2542,
	3518,
	4623,
	5602,
	7413,
	7706,
	11102,
	16067,
	-6517,
	-3283,
	-3248,
	-1825,
	-294,
	992,
	1030,
	2537,
	3945,
	4944,
	5343,
	6622,
	8303,
	9423,
	11360,
	14483,
	-6013,
	-2257,
	-1589,
	-151,
	326,
	1890,
	2461,
	3676,
	4784,
	5816,
	7283,
	7284,
	9089,
	11234,
	13108,
	18494,
	/* low_rates */
	17333,
	-3431,
	4235,
	5276,
	8325,
	-10422,
	683,
	-8609,
	10148,
	-4398,
	1472,
	-4398,
	5802,
	-6907,
	-2327,
	-7303,
	14189,
	-2678,
	3181,
	-180,
	6972,
	-9599,
	0,
	-16305,
	10884,
	-2444,
	1165,
	-3697,
	4180,
	-13468,
	-3833,
	-16305,
	15543,
	-4546,
	1913,
	0,
	6556,
	-15255,
	347,
	-5993,
	9771,
	-9090,
	1086,
	-9341,
	4772,
	-15255,
	-5321,
	-10714,
	12827,
	-5002,
	3118,
	-938,
	6598,
	-14774,
	-646,
	-16879,
	7251,
	-7508,
	-1343,
	-6529,
	2668,
	-15255,
	-2212,
	-14774,
	/* MR475 */
	-30825,
	-30028,
	-11416,
	-1652,
	-17651,
	-16414,
	-7323,
	2266,
	-21289,
	-19823,
	-3914,
	-4413,
	-14560,
	-16037,
	6338,
	-7842,
	-20089,
	-19604,
	-53,
	-10430,
	-13469,
	-12497,
	-2001,
	1517,
	-6283,
	-14145,
	1579,
	-7801,
	-8339,
	-4977,
	-8713,
	7881,
	-20321,
	-20385,
	-8535,
	-1296,
	-16442,
	-16581,
	-9696,
	3577,
	-15714,
	-16981,
	-8484,
	1135,
	-7780,
	-10708,
	5136,
	2962,
	-11229,
	-6643,
	3572,
	-7294,
	-7304,
	-8473,
	-1208,
	3739,
	-11455,
	-7646,
	1150,
	-1866,
	-8638,
	-2726,
	8342,
	4384,
	-15933,
	-10167,
	-362,
	-3665,
	-15663,
	-14504,
	2142,
	2387,
	-18006,
	-16707,
	-905,
	-4726,
	-15513,
	-15088,
	9173,
	-5305,
	-18778,
	-18307,
	-591,
	-2661,
	-12849,
	-6927,
	2472,
	1527,
	-6470,
	-10701,
	632,
	-1754,
	-3155,
	-9145,
	-7938,
	11408,
	-17085,
	-17891,
	-1301,
	-4889,
	-16764,
	-16117,
	-1333,
	7744,
	-16808,
	-17234,
	-2732,
	154,
	-8300,
	-10715,
	7291,
	1731,
	-10824,
	-11244,
	2652,
	-3894,
	-6227,
	-5372,
	1937,
	4457,
	-9466,
	-4954,
	3358,
	-3075,
	-5176,
	-4297,
	8162,
	9040,
	-22215,
	-20758,
	-2986,
	-3807,
	-16679,
	-16291,
	-4626,
	5220,
	-14210,
	-13852,
	-4420,
	-1271,
	-12073,
	-9212,
	5842,
	-1481,
	-17956,
	-15933,
	137,
	-8120,
	-11244,
	-4180,
	-826,
	2224,
	-6359,
	-7605,
	2219,
	-7927,
	-7518,
	-2111,
	3447,
	7949,
	-19803,
	-19487,
	-5360,
	259,
	-14515,
	-14253,
	-6011,
	4180,
	-12577,
	-12676,
	-4384,
	1784,
	-6135,
	-8071,
	4665,
	3078,
	-14220,
	-7896,
	3060,
	-8621,
	-3931,
	-9182,
	1285,
	3816,
	-6974,
	-5192,
	975,
	-554,
	-5091,
	-2075,
	13071,
	-3502,
	-9504,
	-13719,
	-1280,
	244,
	-15972,
	-14740,
	1981,
	5587,
	-14593,
	-11054,
	-2308,
	-2656,
	-13678,
	-13966,
	11370,
	-6739,
	-13158,
	-11799,
	-27,
	901,
	-14092,
	-11849,
	3344,
	989,
	-4132,
	-11176,
	-114,
	-3951,
	-3596,
	-5586,
	-2124,
	13869,
	-13187,
	-8262,
	-2502,
	384,
	-14166,
	-14416,
	-5176,
	6192,
	-7906,
	-7147,
	-3320,
	2336,
	-4615,
	-10032,
	6125,
	6551,
	-6144,
	-10092,
	4495,
	-6666,
	-1273,
	-7423,
	4241,
	5680,
	-4212,
	-3891,
	5366,
	-5337,
	-3121,
	-1847,
	14175,
	6302,
	-16793,
	-17341,
	-5176,
	-1085,
	-15076,
	-14199,
	-3195,
	3257,
	-17698,
	-17635,
	-2746,
	-946,
	-14548,
	-15365,
	6748,
	-2615,
	-14774,
	-14166,
	1904,
	-4525,
	-6998,
	-10472,
	928,
	865,
	-2821,
	-10493,
	1122,
	-4019,
	-4785,
	-4261,
	-2922,
	9604,
	-15920,
	-15438,
	-10388,
	222,
	-15959,
	-17204,
	-6283,
	6737,
	-13658,
	-13488,
	-5618,
	280,
	-10222,
	-6248,
	5358,
	977,
	-6319,
	-7294,
	4218,
	-1156,
	-8300,
	-7780,
	-1514,
	4296,
	-12479,
	-5917,
	1839,
	367,
	-9992,
	-1369,
	11020,
	4578,
	-15255,
	-13873,
	-3133,
	-1298,
	-10621,
	-13518,
	1087,
	3057,
	-17250,
	-17265,
	-774,
	-2339,
	-15006,
	-15053,
	8896,
	-5497,
	-16938,
	-15998,
	107,
	-1850,
	-7980,
	-5053,
	2639,
	2590,
	-3108,
	-9898,
	2333,
	-323,
	-800,
	-9329,
	-57,
	11948,
	-7827,
	-13638,
	967,
	-1906,
	-14361,
	-13410,
	392,
	6353,
	-11799,
	-13831,
	-698,
	1024,
	-8736,
	-5489,
	7665,
	861,
	-11816,
	-5582,
	3495,
	761,
	-8201,
	-2588,
	2045,
	4850,
	-4240,
	-5223,
	3705,
	-1636,
	-1754,
	-6443,
	10180,
	11952,
	-12365,
	-13618,
	433,
	-1009,
	-11322,
	-9225,
	-5421,
	4302,
	-10883,
	-14537,
	-1633,
	-489,
	-5904,
	-5771,
	6831,
	-4047,
	-10643,
	-14383,
	656,
	-6097,
	-3245,
	-5305,
	809,
	2438,
	-3502,
	-5862,
	2584,
	-3429,
	-3642,
	-482,
	1471,
	9712,
	-12577,
	-12649,
	-2533,
	2410,
	-7996,
	-11047,
	-4882,
	4768,
	-8575,
	-11470,
	-8747,
	2427,
	-6092,
	-5713,
	6222,
	3854,
	-8911,
	-4132,
	4521,
	-3108,
	-1704,
	-7162,
	1293,
	5132,
	-3445,
	-1866,
	1868,
	1264,
	-4855,
	608,
	16615,
	-2571,
	-8552,
	-11940,
	1620,
	-1308,
	-13699,
	-13976,
	626,
	5652,
	-12374,
	-12868,
	-312,
	-1579,
	-12703,
	-12877,
	10194,
	222,
	-10773,
	-14372,
	2009,
	1590,
	-7323,
	-296,
	3655,
	3289,
	-1605,
	-6506,
	2082,
	-2752,
	-696,
	-4878,
	-3567,
	16558,
	-10297,
	-12462,
	-1094,
	2640,
	-14560,
	-13370,
	-2577,
	8180,
	-3931,
	-10430,
	-1733,
	2173,
	-7938,
	-2274,
	8585,
	4567,
	-5141,
	-4619,
	4655,
	-1707,
	-1931,
	-4666,
	4396,
	7837,
	-4026,
	-2364,
	5687,
	-482,
	-948,
	-1709,
	13820,
	15394,
	/* dtx */
	-11560,
	-11304,
	-11048,
	-10792,
	-10536,
	-10280,
	-10024,
	-9768,
	-9512,
	-9256,
	-9000,
	-8744,
	-8488,
	-8232,
	-7976,
	-7720,
	-7464,
	-7208,
	-6952,
	-6696,
	-6440,
	-6184,
	-5928,
	-5672,
	-5416,
	-5160,
	-4904,
	-4648,
	-4392,
	-4136,
	-3880,
	-3624,
	-3368,
	-3112,
	-2856,
	-2600,
	-2344,
	-2088,
	-1832,
	-1576,
	-1320,
	-1064,
	-808,
	-552,
	-296,
	-40,
	0,
	/* init value */
	-14336,
	/* min */
	-32767,
	/* max */
	18284

};
/*
* LP analysis is performed twice per frame using two different asymmetric windows.
* The second window has its weight concentrated at the fourth subframe
* and it consists of two parts:
* the first part is half a Hamming window and
* the second part is a quarter of a cosine function cycle.
*/
__device__ static const Float32 window_200_40[240] =
{
	0.0800000F,
	0.0800570F,
	0.0802281F,
	0.0805132F,
	0.0809123F,
	0.0814251F,
	0.0820517F,
	0.0827919F,
	0.0836454F,
	0.0846121F,
	0.0856917F,
	0.0868840F,
	0.0881886F,
	0.0896053F,
	0.0911337F,
	0.0927733F,
	0.0945239F,
	0.0963849F,
	0.0983560F,
	0.100437F,
	0.102626F,
	0.104924F,
	0.107330F,
	0.109843F,
	0.112463F,
	0.115189F,
	0.118020F,
	0.120956F,
	0.123996F,
	0.127139F,
	0.130384F,
	0.133731F,
	0.137178F,
	0.140726F,
	0.144372F,
	0.148117F,
	0.151959F,
	0.155897F,
	0.159930F,
	0.164058F,
	0.168278F,
	0.172591F,
	0.176995F,
	0.181489F,
	0.186072F,
	0.190743F,
	0.195500F,
	0.200343F,
	0.205270F,
	0.210280F,
	0.215372F,
	0.220544F,
	0.225795F,
	0.231125F,
	0.236531F,
	0.242012F,
	0.247567F,
	0.253195F,
	0.258893F,
	0.264662F,
	0.270499F,
	0.276402F,
	0.282371F,
	0.288404F,
	0.294499F,
	0.300655F,
	0.306871F,
	0.313144F,
	0.319473F,
	0.325857F,
	0.332295F,
	0.338783F,
	0.345322F,
	0.351909F,
	0.358543F,
	0.365221F,
	0.371943F,
	0.378707F,
	0.385510F,
	0.392352F,
	0.399231F,
	0.406144F,
	0.413091F,
	0.420069F,
	0.427077F,
	0.434112F,
	0.441175F,
	0.448261F,
	0.455371F,
	0.462501F,
	0.469650F,
	0.476817F,
	0.484000F,
	0.491197F,
	0.498405F,
	0.505624F,
	0.512852F,
	0.520086F,
	0.527325F,
	0.534567F,
	0.541811F,
	0.549054F,
	0.556295F,
	0.563532F,
	0.570763F,
	0.577986F,
	0.585201F,
	0.592403F,
	0.599593F,
	0.606768F,
	0.613927F,
	0.621067F,
	0.628187F,
	0.635285F,
	0.642360F,
	0.649409F,
	0.656431F,
	0.663424F,
	0.670387F,
	0.677317F,
	0.684213F,
	0.691073F,
	0.697896F,
	0.704680F,
	0.711423F,
	0.718124F,
	0.724780F,
	0.731390F,
	0.737953F,
	0.744467F,
	0.750930F,
	0.757341F,
	0.763698F,
	0.770000F,
	0.776245F,
	0.782430F,
	0.788556F,
	0.794620F,
	0.800622F,
	0.806558F,
	0.812428F,
	0.818231F,
	0.823965F,
	0.829628F,
	0.835220F,
	0.840738F,
	0.846182F,
	0.851550F,
	0.856840F,
	0.862052F,
	0.867184F,
	0.872235F,
	0.877204F,
	0.882089F,
	0.886889F,
	0.891603F,
	0.896230F,
	0.900769F,
	0.905218F,
	0.909577F,
	0.913844F,
	0.918018F,
	0.922098F,
	0.926084F,
	0.929974F,
	0.933767F,
	0.937463F,
	0.941060F,
	0.944558F,
	0.947955F,
	0.951251F,
	0.954446F,
	0.957537F,
	0.960525F,
	0.963409F,
	0.966187F,
	0.968860F,
	0.971427F,
	0.973886F,
	0.976238F,
	0.978482F,
	0.980617F,
	0.982643F,
	0.984559F,
	0.986365F,
	0.988060F,
	0.989644F,
	0.991117F,
	0.992478F,
	0.993726F,
	0.994862F,
	0.995885F,
	0.996796F,
	0.997592F,
	0.998276F,
	0.998846F,
	0.999301F,
	0.999644F,
	0.999872F,
	0.999986F,
	1.00000F,
	0.999219F,
	0.996878F,
	0.992981F,
	0.987533F,
	0.980544F,
	0.972023F,
	0.961985F,
	0.950444F,
	0.937420F,
	0.922932F,
	0.907002F,
	0.889657F,
	0.870923F,
	0.850828F,
	0.829406F,
	0.806688F,
	0.782711F,
	0.757511F,
	0.731129F,
	0.703605F,
	0.674983F,
	0.645307F,
	0.614623F,
	0.582980F,
	0.550426F,
	0.517013F,
	0.482792F,
	0.447818F,
	0.412145F,
	0.375828F,
	0.338924F,
	0.301491F,
	0.263587F,
	0.225272F,
	0.186605F,
	0.147647F,
	0.108458F,
	0.0690994F,
	0.0296333F
};

/*
* LP analysis is performed twice per frame using two different asymmetric windows.
* The second window has its weight concentrated at the fourth subframe
* and it consists of two parts:
* the first part is half a Hamming window and
* the second part is a quarter of a cosine function cycle.
*/
__device__ static const Float32 window_232_8[240] =
{
	0.0800000F,
	0.0800424F,
	0.0801694F,
	0.0803812F,
	0.0806775F,
	0.0810585F,
	0.0815240F,
	0.0820739F,
	0.0827082F,
	0.0834267F,
	0.0842292F,
	0.0851157F,
	0.0860859F,
	0.0871398F,
	0.0882770F,
	0.0894975F,
	0.0908009F,
	0.0921870F,
	0.0936556F,
	0.0952064F,
	0.0968391F,
	0.0985534F,
	0.100349F,
	0.102226F,
	0.104183F,
	0.106220F,
	0.108338F,
	0.110534F,
	0.112810F,
	0.115165F,
	0.117598F,
	0.120108F,
	0.122696F,
	0.125361F,
	0.128102F,
	0.130919F,
	0.133812F,
	0.136779F,
	0.139820F,
	0.142935F,
	0.146123F,
	0.149384F,
	0.152717F,
	0.156121F,
	0.159596F,
	0.163140F,
	0.166754F,
	0.170437F,
	0.174188F,
	0.178007F,
	0.181892F,
	0.185843F,
	0.189859F,
	0.193939F,
	0.198084F,
	0.202291F,
	0.206561F,
	0.210892F,
	0.215283F,
	0.219734F,
	0.224245F,
	0.228813F,
	0.233439F,
	0.238121F,
	0.242859F,
	0.247652F,
	0.252498F,
	0.257397F,
	0.262349F,
	0.267351F,
	0.272404F,
	0.277506F,
	0.282656F,
	0.287854F,
	0.293098F,
	0.298388F,
	0.303722F,
	0.309100F,
	0.314520F,
	0.319981F,
	0.325484F,
	0.331025F,
	0.336606F,
	0.342223F,
	0.347877F,
	0.353567F,
	0.359290F,
	0.365048F,
	0.370837F,
	0.376657F,
	0.382508F,
	0.388387F,
	0.394295F,
	0.400229F,
	0.406189F,
	0.412174F,
	0.418182F,
	0.424213F,
	0.430265F,
	0.436337F,
	0.442428F,
	0.448537F,
	0.454663F,
	0.460805F,
	0.466961F,
	0.473131F,
	0.479313F,
	0.485507F,
	0.491710F,
	0.497922F,
	0.504142F,
	0.510369F,
	0.516601F,
	0.522837F,
	0.529077F,
	0.535318F,
	0.541561F,
	0.547803F,
	0.554043F,
	0.560281F,
	0.566516F,
	0.572745F,
	0.578969F,
	0.585185F,
	0.591393F,
	0.597591F,
	0.603779F,
	0.609955F,
	0.616119F,
	0.622268F,
	0.628402F,
	0.634520F,
	0.640620F,
	0.646702F,
	0.652764F,
	0.658805F,
	0.664825F,
	0.670822F,
	0.676794F,
	0.682741F,
	0.688662F,
	0.694556F,
	0.700421F,
	0.706257F,
	0.712062F,
	0.717835F,
	0.723576F,
	0.729282F,
	0.734954F,
	0.740590F,
	0.746189F,
	0.751750F,
	0.757272F,
	0.762755F,
	0.768196F,
	0.773595F,
	0.778951F,
	0.784263F,
	0.789530F,
	0.794751F,
	0.799925F,
	0.805051F,
	0.810129F,
	0.815156F,
	0.820133F,
	0.825059F,
	0.829932F,
	0.834751F,
	0.839517F,
	0.844227F,
	0.848881F,
	0.853478F,
	0.858018F,
	0.862499F,
	0.866920F,
	0.871282F,
	0.875582F,
	0.879820F,
	0.883996F,
	0.888109F,
	0.892157F,
	0.896141F,
	0.900059F,
	0.903911F,
	0.907696F,
	0.911413F,
	0.915061F,
	0.918641F,
	0.922151F,
	0.925590F,
	0.928958F,
	0.932255F,
	0.935480F,
	0.938632F,
	0.941710F,
	0.944714F,
	0.947644F,
	0.950499F,
	0.953278F,
	0.955981F,
	0.958607F,
	0.961157F,
	0.963628F,
	0.966022F,
	0.968338F,
	0.970574F,
	0.972731F,
	0.974809F,
	0.976806F,
	0.978723F,
	0.980559F,
	0.982314F,
	0.983988F,
	0.985579F,
	0.987089F,
	0.988516F,
	0.989861F,
	0.991123F,
	0.992302F,
	0.993398F,
	0.994410F,
	0.995338F,
	0.996183F,
	0.996943F,
	0.997619F,
	0.998212F,
	0.998719F,
	0.999143F,
	0.999481F,
	0.999735F,
	0.999905F,
	0.999989F,
	1.00000F,
	0.979530F,
	0.918958F,
	0.820763F,
	0.688967F,
	0.528964F,
	0.347305F,
	0.151428F
};

/*
* LP analysis is performed twice per frame using two different asymmetric windows.
* The first window has its weight concentrated at the second subframe
* and it consists of two halves of Hamming windows with different sizes
*/
__device__ static const Float32 window_160_80[240] =
{
	0.0800000F,
	0.0800898F,
	0.0803591F,
	0.0808079F,
	0.0814359F,
	0.0822430F,
	0.0832287F,
	0.0843928F,
	0.0857347F,
	0.0872539F,
	0.0889499F,
	0.0908220F,
	0.0928695F,
	0.0950914F,
	0.0974871F,
	0.100056F,
	0.102796F,
	0.105707F,
	0.108787F,
	0.112036F,
	0.115451F,
	0.119033F,
	0.122779F,
	0.126688F,
	0.130758F,
	0.134988F,
	0.139376F,
	0.143920F,
	0.148619F,
	0.153471F,
	0.158473F,
	0.163625F,
	0.168924F,
	0.174367F,
	0.179953F,
	0.185680F,
	0.191545F,
	0.197546F,
	0.203681F,
	0.209947F,
	0.216342F,
	0.222863F,
	0.229508F,
	0.236274F,
	0.243159F,
	0.250160F,
	0.257273F,
	0.264498F,
	0.271829F,
	0.279266F,
	0.286804F,
	0.294441F,
	0.302174F,
	0.310000F,
	0.317916F,
	0.325918F,
	0.334004F,
	0.342170F,
	0.350414F,
	0.358731F,
	0.367119F,
	0.375575F,
	0.384095F,
	0.392676F,
	0.401314F,
	0.410007F,
	0.418750F,
	0.427540F,
	0.436375F,
	0.445250F,
	0.454162F,
	0.463107F,
	0.472083F,
	0.481085F,
	0.490109F,
	0.499154F,
	0.508214F,
	0.517287F,
	0.526369F,
	0.535456F,
	0.544544F,
	0.553631F,
	0.562713F,
	0.571786F,
	0.580846F,
	0.589891F,
	0.598915F,
	0.607917F,
	0.616893F,
	0.625838F,
	0.634750F,
	0.643625F,
	0.652460F,
	0.661250F,
	0.669993F,
	0.678686F,
	0.687324F,
	0.695905F,
	0.704425F,
	0.712881F,
	0.721269F,
	0.729586F,
	0.737830F,
	0.745996F,
	0.754082F,
	0.762084F,
	0.770000F,
	0.777826F,
	0.785559F,
	0.793196F,
	0.800734F,
	0.808171F,
	0.815502F,
	0.822727F,
	0.829840F,
	0.836841F,
	0.843726F,
	0.850492F,
	0.857137F,
	0.863658F,
	0.870053F,
	0.876319F,
	0.882454F,
	0.888455F,
	0.894320F,
	0.900047F,
	0.905633F,
	0.911076F,
	0.916375F,
	0.921527F,
	0.926529F,
	0.931381F,
	0.936080F,
	0.940624F,
	0.945012F,
	0.949242F,
	0.953312F,
	0.957221F,
	0.960967F,
	0.964549F,
	0.967964F,
	0.971213F,
	0.974293F,
	0.977204F,
	0.979944F,
	0.982513F,
	0.984909F,
	0.987131F,
	0.989178F,
	0.991050F,
	0.992746F,
	0.994265F,
	0.995607F,
	0.996771F,
	0.997757F,
	0.998564F,
	0.999192F,
	0.999641F,
	0.999910F,
	1.00000F,
	1.00000F,
	0.999636F,
	0.998546F,
	0.996730F,
	0.994193F,
	0.990937F,
	0.986968F,
	0.982292F,
	0.976917F,
	0.970851F,
	0.964104F,
	0.956687F,
	0.948610F,
	0.939887F,
	0.930532F,
	0.920560F,
	0.909986F,
	0.898826F,
	0.887100F,
	0.874824F,
	0.862019F,
	0.848705F,
	0.834903F,
	0.820635F,
	0.805922F,
	0.790790F,
	0.775260F,
	0.759359F,
	0.743111F,
	0.726542F,
	0.709677F,
	0.692545F,
	0.675171F,
	0.657584F,
	0.639810F,
	0.621879F,
	0.603818F,
	0.585657F,
	0.567423F,
	0.549146F,
	0.530854F,
	0.512577F,
	0.494343F,
	0.476182F,
	0.458121F,
	0.440190F,
	0.422416F,
	0.404829F,
	0.387455F,
	0.370323F,
	0.353458F,
	0.336889F,
	0.320641F,
	0.304740F,
	0.289210F,
	0.274078F,
	0.259365F,
	0.245097F,
	0.231295F,
	0.217981F,
	0.205176F,
	0.192900F,
	0.181174F,
	0.170014F,
	0.159440F,
	0.149468F,
	0.140113F,
	0.131390F,
	0.123313F,
	0.115896F,
	0.109149F,
	0.103083F,
	0.0977077F,
	0.0930321F,
	0.0890632F,
	0.0858073F,
	0.0832696F,
	0.0814541F,
	0.0803637F,
	0.0800000F
};

/* correlation weights	*/
__device__ static const Float32 corrweight[251] =
{
	0.624805F,
	0.625813F,
	0.626820F,
	0.627827F,
	0.628834F,
	0.630024F,
	0.631031F,
	0.632221F,
	0.633229F,
	0.634419F,
	0.635426F,
	0.636616F,
	0.637623F,
	0.638813F,
	0.640034F,
	0.641224F,
	0.642415F,
	0.643605F,
	0.644826F,
	0.646016F,
	0.647206F,
	0.648427F,
	0.649617F,
	0.651021F,
	0.652211F,
	0.653615F,
	0.654805F,
	0.656209F,
	0.657430F,
	0.658834F,
	0.660207F,
	0.661611F,
	0.663015F,
	0.664418F,
	0.665822F,
	0.667226F,
	0.668630F,
	0.670217F,
	0.671621F,
	0.673208F,
	0.674612F,
	0.676229F,
	0.677816F,
	0.679434F,
	0.681021F,
	0.682607F,
	0.684225F,
	0.685812F,
	0.687613F,
	0.689230F,
	0.691031F,
	0.692831F,
	0.694632F,
	0.696432F,
	0.698233F,
	0.700034F,
	0.702017F,
	0.703818F,
	0.705832F,
	0.707816F,
	0.709616F,
	0.711814F,
	0.713828F,
	0.715812F,
	0.718009F,
	0.720237F,
	0.722221F,
	0.724631F,
	0.726829F,
	0.729026F,
	0.731437F,
	0.733818F,
	0.736229F,
	0.738609F,
	0.741234F,
	0.743614F,
	0.746208F,
	0.748833F,
	0.751610F,
	0.754234F,
	0.757012F,
	0.760033F,
	0.762810F,
	0.765831F,
	0.768822F,
	0.772027F,
	0.775018F,
	0.778222F,
	0.781610F,
	0.785028F,
	0.788415F,
	0.792016F,
	0.795618F,
	0.799219F,
	0.803034F,
	0.807031F,
	0.811029F,
	0.815027F,
	0.819239F,
	0.823634F,
	0.828028F,
	0.832636F,
	0.837428F,
	0.842219F,
	0.847224F,
	0.852412F,
	0.857814F,
	0.863216F,
	0.869015F,
	0.874813F,
	0.881039F,
	0.887417F,
	0.894040F,
	0.901028F,
	0.908231F,
	0.915616F,
	0.923429F,
	0.931639F,
	0.940214F,
	0.960021F,
	1.00000F,
	1.00000F,
	1.00000F,
	1.00000F,
	1.00000F,
	1.00000F,
	1.00000F,
	0.960021F,
	0.940214F,
	0.931639F,
	0.923429F,
	0.915616F,
	0.908231F,
	0.901028F,
	0.894040F,
	0.887417F,
	0.881039F,
	0.874813F,
	0.869015F,
	0.863216F,
	0.857814F,
	0.852412F,
	0.847224F,
	0.842219F,
	0.837428F,
	0.832636F,
	0.828028F,
	0.823634F,
	0.819239F,
	0.815027F,
	0.811029F,
	0.807031F,
	0.803034F,
	0.799219F,
	0.795618F,
	0.792016F,
	0.788415F,
	0.785028F,
	0.781610F,
	0.778222F,
	0.775018F,
	0.772027F,
	0.768822F,
	0.765831F,
	0.762810F,
	0.760033F,
	0.757012F,
	0.754234F,
	0.751610F,
	0.748833F,
	0.746208F,
	0.743614F,
	0.741234F,
	0.738609F,
	0.736229F,
	0.733818F,
	0.731437F,
	0.729026F,
	0.726829F,
	0.724631F,
	0.722221F,
	0.720237F,
	0.718009F,
	0.715812F,
	0.713828F,
	0.711814F,
	0.709616F,
	0.707816F,
	0.705832F,
	0.703818F,
	0.702017F,
	0.700034F,
	0.698233F,
	0.696432F,
	0.694632F,
	0.692831F,
	0.691031F,
	0.689230F,
	0.687613F,
	0.685812F,
	0.684225F,
	0.682607F,
	0.681021F,
	0.679434F,
	0.677816F,
	0.676229F,
	0.674612F,
	0.673208F,
	0.671621F,
	0.670217F,
	0.668630F,
	0.667226F,
	0.665822F,
	0.664418F,
	0.663015F,
	0.661611F,
	0.660207F,
	0.658834F,
	0.657430F,
	0.656209F,
	0.654805F,
	0.653615F,
	0.652211F,
	0.651021F,
	0.649617F,
	0.648427F,
	0.647206F,
	0.646016F,
	0.644826F,
	0.643605F,
	0.642415F,
	0.641224F,
	0.640034F,
	0.638813F,
	0.637623F,
	0.636616F,
	0.635426F,
	0.634419F,
	0.633229F,
	0.632221F,
	0.631031F,
	0.630024F,
	0.628834F,
	0.627827F,
	0.626820F,
	0.625813F,
	0.624805F,
	0.623615F,
	0.622608F,
	0.621632F,
	0.620624F
};


__device__ const struct
{
	Word8 max_frac_lag; /* lag up to which fractional lags are used */
	Word8 flag3; /* enable 1/3 instead of 1/6 fract. resolution */
	Word8 first_frac; /* first fractional to check */
	Word8 last_frac; /* last fractional to check */
	Word8 delta_int_low; /* integer lag below TO to start search from */
	Word8 delta_int_range; /* integer range around T0 */
	Word8 delta_frc_low; /* fractional below T0 */
	Word8 delta_frc_range; /* fractional range around T0 */
	Word8 pit_min; /* minimum pitch */

} static mode_dep_parm[8] =
{
	/*
	* MR475
	*/
	{
		84, 1, -2, 2, 5, 10, 5, 9, PIT_MIN
	},
	/*
	* MR515
	*/
	{
		84, 1, -2, 2, 5, 10, 5, 9, PIT_MIN
	},
	/*
	* MR59
	*/
	{
		84, 1, -2, 2, 3, 6, 5, 9, PIT_MIN
	},
	/*
	* MR67
	*/
	{
		84, 1, -2, 2, 3, 6, 5, 9, PIT_MIN
	},
	/*
	* MR74
	*/
	{
		84, 1, -2, 2, 3, 6, 5, 9, PIT_MIN
	},
	/*
	* MR795
	*/
	{
		84, 1, -2, 2, 3, 6, 10, 19, PIT_MIN
	},
	/*
	* MR102
	*/
	{
		84, 1, -2, 2, 3, 6, 5, 9, PIT_MIN
	},
	/*
	* MR122
	*/
	{
		94, 0, -3, 3, 3, 6, 5, 9, PIT_MIN_MR122
	}
};

/* table used inbase 2 logharithm computation */
__device__ static const Word32 log2_table[33] =
{
	0,
	1455,
	2866,
	4236,
	5568,
	6863,
	8124,
	9352,
	10549,
	11716,
	12855,
	13967,
	15054,
	16117,
	17156,
	18172,
	19167,
	20142,
	21097,
	22033,
	22951,
	23852,
	24735,
	25603,
	26455,
	27291,
	28113,
	28922,
	29716,
	30497,
	31266,
	32023,
	32767
};

/* table used in 2 to the power computation */
__device__ static const Word32 pow2_table[33] =
{
	16384,
	16743,
	17109,
	17484,
	17867,
	18258,
	18658,
	19066,
	19484,
	19911,
	20347,
	20792,
	21247,
	21713,
	22188,
	22674,
	23170,
	23678,
	24196,
	24726,
	25268,
	25821,
	26386,
	26964,
	27554,
	28158,
	28774,
	29405,
	30048,
	30706,
	31379,
	32066,
	32767
};


__device__ static Float64 Dotproduct40(Float32 *x, Float32 *y)
{
	Float64 acc;


	acc = x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];
	acc += x[4] * y[4] + x[5] * y[5] + x[6] * y[6] + x[7] * y[7];
	acc += x[8] * y[8] + x[9] * y[9] + x[10] * y[10] + x[11] * y[11];
	acc += x[12] * y[12] + x[13] * y[13] + x[14] * y[14] + x[15] * y[15];
	acc += x[16] * y[16] + x[17] * y[17] + x[18] * y[18] + x[19] * y[19];
	acc += x[20] * y[20] + x[21] * y[21] + x[22] * y[22] + x[23] * y[23];
	acc += x[24] * y[24] + x[25] * y[25] + x[26] * y[26] + x[27] * y[27];
	acc += x[28] * y[28] + x[29] * y[29] + x[30] * y[30] + x[31] * y[31];
	acc += x[32] * y[32] + x[33] * y[33] + x[34] * y[34] + x[35] * y[35];
	acc += x[36] * y[36] + x[37] * y[37] + x[38] * y[38] + x[39] * y[39];
	return(acc);
}


/*
* Autocorr
*
*
* Parameters:
*    x                 I: Input signal
*    r                 O: Autocorrelations
*    wind              I: Window for LPC analysis
* Function:
*    Calculate autocorrelation with window, LPC order = M
*
* Returns:
*    void
*/
__device__ static void Autocorr(Float32 x[], Float32 r[], const Float32 wind[])
{
	Word32 i, j;   /* Counters */
	Float32 y[L_WINDOW + M + 1];   /* Windowed signal */
	Float64 sum;   /* temp */


				   /*
				   * Windowing of signal
				   */
	for (i = 0; i < L_WINDOW; i++) {
		y[i] = x[i] * wind[i];
	}

	/*
	* Zero remaining memory
	*/
	memset(&y[L_WINDOW], 0, 44);

	/*
	* Autocorrelation
	*/
	for (i = 0; i <= M; i++) {
		sum = 0;

		for (j = 0; j < L_WINDOW; j += 40) {
			sum += Dotproduct40(&y[j], &y[j + i]);
		}
		r[i] = (Float32)sum;
	}
}


/*
* Levinson
*
*
* Parameters:
*    old_A             I: Vector of old LP coefficients [M+1]
*    r                 I: Vector of autocorrelations    [M+1]
*    a                 O: LP coefficients               [M+1]
*    rc                O: Reflection coefficients       [4]
* Function:
*    Levinson-Durbin algorithm
*
* Returns:
*    void
*
*/
__device__ static void Levinson(Float32 *old_A, Float32 *r, Float32 *A, Float32 *rc)
{
	Float32 sum, at, err;
	Word32 l, j, i;
	Float32 rct[M];   /* temporary reflection coefficients  0,...,m-1 */


	rct[0] = (-r[1]) / r[0];
	A[0] = 1.0F;
	A[1] = rct[0];
	err = r[0] + r[1] * rct[0];

	if (err <= 0.0)
		err = 0.01F;

	for (i = 2; i <= M; i++) {
		sum = 0.0F;

		for (j = 0; j < i; j++)
			sum += r[i - j] * A[j];
		rct[i - 1] = (-sum) / (err);

		for (j = 1; j <= (i / 2); j++) {
			l = i - j;
			at = A[j] + rct[i - 1] * A[l];
			A[l] += rct[i - 1] * A[j];
			A[j] = at;
		}
		A[i] = rct[i - 1];
		err += rct[i - 1] * sum;

		if (err <= 0.0)
			err = 0.01F;
	}
	memcpy(rc, rct, 4 * sizeof(Float32));
	memcpy(old_A, A, MP1 * sizeof(Float32));
}


/*
* lpc
*
*
* Parameters:
*    old_A             O: Vector of old LP coefficients [M+1]
*    x                 I: Input signal
*    x_12k2            I: Input signal 12.2k
*    a                 O: predictor coefficients
*    mode              I: AMR mode
* Function:
*    LP analysis
*
*    In 12.2 kbit/s mode linear prediction (LP) analysis is performed
*    twice per speech frame using the auto-correlation approach with
*    30 ms asymmetric windows. No lookahead is used in
*    the auto-correlation computation.
*
*    In other modes analysis is performed once per speech frame
*    using the auto-correlation approach with 30 ms asymmetric windows.
*    A lookahead of 40 samples (5 ms) is used in the auto-correlation computation.
*
*    The auto-correlations of windowed speech are converted to the LP
*    coefficients using the Levinson-Durbin algorithm.
*    Then the LP coefficients are transformed to the Line Spectral Pair
*    (LSP) domain  for quantization and interpolation purposes.
*    The interpolated quantified and unquantized filter coefficients
*    are converted back to the LP filter coefficients
*    (to construct the synthesis and weighting filters at each subframe).
*
* Returns:
*    void
*
*/
__device__ static void lpc(Float32 *old_A, Float32 x[], Float32 x_12k2[], Float32 a[], enum Mode
	mode)
{
	Word32 i;
	Float32 r[MP1];
	Float32 rc[4];


	if (mode == MR122) {
		Autocorr(x_12k2, r, window_160_80);

		/*
		* Lag windowing
		*/
		for (i = 1; i <= M; i++) {
			r[i] = r[i] * lag_wind[i - 1];
		}
		r[0] *= 1.0001F;

		if (r[0] < 1.0F)
			r[0] = 1.0F;

		/*
		* Levinson Durbin
		*/
		Levinson(old_A, r, &a[MP1], rc);

		/*
		* Autocorrelations
		*/
		Autocorr(x_12k2, r, window_232_8);

		/*
		* Lag windowing
		*/
		for (i = 1; i <= M; i++) {
			r[i] = r[i] * lag_wind[i - 1];
		}
		r[0] *= 1.0001F;

		if (r[0] < 1.0F)
			r[0] = 1.0F;

		/*
		* Levinson Durbin
		*/
		Levinson(old_A, r, &a[MP1 * 3], rc);
	}
	else {
		/*
		* Autocorrelations
		*/
		Autocorr(x, r, window_200_40);

		/*
		* a 60 Hz bandwidth expansion is used by lag windowing
		* the auto-correlations. Further, auto-correlation[0] is
		* multiplied by the white noise correction factor 1.0001
		* which is equivalent to adding a noise floor at -40 dB.
		*/
		for (i = 1; i <= M; i++) {
			r[i] = r[i] * lag_wind[i - 1];
		}
		r[0] *= 1.0001F;

		if (r[0] < 1.0F)
			r[0] = 1.0F;

		/*
		* Levinson Durbin
		*/
		Levinson(old_A, r, &a[MP1 * 3], rc);
	}
}


/*
* Chebps
*
*
* Parameters:
*    x                 I: Cosine value for the freqency given
*    f                 I: angular freqency
* Function:
*    Evaluates the Chebyshev polynomial series
*
* Returns:
*    result of polynomial evaluation
*/
__device__ static Float32 Chebps(Float32 x, Float32 f[])
{
	Float32 b0, b1, b2, x2;
	Word32 i;


	x2 = 2.0F * x;
	b2 = 1.0F;
	b1 = x2 + f[1];

	for (i = 2; i < 5; i++) {
		b0 = x2 * b1 - b2 + f[i];
		b2 = b1;
		b1 = b0;
	}
	return(x * b1 - b2 + f[i]);
}


/*
* Az_lsp
*
*
* Parameters:
*    a                 I: Predictor coefficients              [MP1]
*    lsp               O: Line spectral pairs                 [M]
*    old_lsp           I: Old lsp, in case not found 10 roots [M]
*
* Function:
*    LP to LSP conversion
*
*    The LP filter coefficients A[], are converted to the line spectral pair
*    (LSP) representation for quantization and interpolation purposes.
*
* Returns:
*    void
*/
__device__ static void Az_lsp(Float32 a[], Float32 lsp[], Float32 old_lsp[])
{
	Word32 i, j, nf, ip;
	Float32 xlow, ylow, xhigh, yhigh, xmid, ymid, xint;
	Float32 y;
	Float32 *coef;
	Float32 f1[6], f2[6];


	/*
	*  find the sum and diff. pol. F1(z) and F2(z)
	*/
	f1[0] = 1.0F;
	f2[0] = 1.0F;

	for (i = 0; i < (NC); i++) {
		f1[i + 1] = a[i + 1] + a[M - i] - f1[i];
		f2[i + 1] = a[i + 1] - a[M - i] + f2[i];
	}
	f1[NC] *= 0.5F;
	f2[NC] *= 0.5F;

	/*
	* find the LSPs using the Chebychev pol. evaluation
	*/
	nf = 0;   /* number of found frequencies */
	ip = 0;   /* indicator for f1 or f2 */
	coef = f1;
	xlow = grid[0];
	ylow = Chebps(xlow, coef);
	j = 0;

	while ((nf < M) && (j < 60)) {
		j++;
		xhigh = xlow;
		yhigh = ylow;
		xlow = grid[j];
		ylow = Chebps(xlow, coef);

		if (ylow * yhigh <= 0) {
			/* divide 4 times the interval */
			for (i = 0; i < 4; i++) {
				xmid = (xlow + xhigh) * 0.5F;
				ymid = Chebps(xmid, coef);

				if (ylow * ymid <= 0.0F) {
					yhigh = ymid;
					xhigh = xmid;
				}
				else {
					ylow = ymid;
					xlow = xmid;
				}
			}

			/*
			* Linear interpolation
			* xint = xlow - ylow*(xhigh-xlow)/(yhigh-ylow)
			*/
			y = yhigh - ylow;

			if (y == 0) {
				xint = xlow;
			}
			else {
				y = (xhigh - xlow) / (yhigh - ylow);
				xint = xlow - ylow * y;
			}
			lsp[nf] = xint;
			xlow = xint;
			nf++;

			if (ip == 0) {
				ip = 1;
				coef = f2;
			}
			else {
				ip = 0;
				coef = f1;
			}
			ylow = Chebps(xlow, coef);
		}
	}

	/* Check if M roots found */
	if (nf < M) {
		memcpy(lsp, old_lsp, M << 2);
	}
	return;
}


/*
* Get_lsp_pol
*
*
* Parameters:
*    lsp                 I: line spectral frequencies
*    f                   O: polynomial F1(z) or F2(z)
*
* Function:
*    Find the polynomial F1(z) or F2(z) from the LSPs.
*
*    F1(z) = product ( 1 - 2 lsp[i] z^-1 + z^-2 )
*             i=0,2,4,6,8
*    F2(z) = product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
*             i=1,3,5,7,9
*
*    where lsp[] is the LSP vector in the cosine domain.
*
*    The expansion is performed using the following recursion:
*
*    f[0] = 1
*    b = -2.0 * lsp[0]
*    f[1] = b
*    for i=2 to 5 do
*       b = -2.0 * lsp[2*i-2];
*       f[i] = b*f[i-1] + 2.0*f[i-2];
*       for j=i-1 down to 2 do
*          f[j] = f[j] + b*f[j-1] + f[j-2];
*       f[1] = f[1] + b;
*
* Returns:
*    void
*/
__device__ static void Get_lsp_pol(Float32 *lsp, Float32 *f)
{
	Word32 i, j;
	Float32 T0;


	f[0] = 1.0F;
	f[1] = -2.0F * lsp[0];

	for (i = 2; i <= 5; i++) {
		T0 = -2.0F * lsp[2 * i - 2];
		f[i] = (Float32)(T0 * f[i - 1] + 2.0F * f[i - 2]);

		for (j = i - 1; j >= 2; j--) {
			f[j] = f[j] + T0 * f[j - 1] + f[j - 2];
		}
		f[1] = f[1] + T0;
	}
	return;
}


/*
* Lsp_Az
*
*
* Parameters:
*    lsp                 I: Line spectral frequencies
*    a                   O: Predictor coefficients
*
* Function:
*    Converts from the line spectral pairs (LSP) to LP coefficients,
*    for a 10th order filter.
*
* Returns:
*    void
*/
__device__ static void Lsp_Az(Float32 lsp[], Float32 a[])
{
	Float32 f1[6], f2[6];
	Word32 i, j;


	Get_lsp_pol(&lsp[0], f1);
	Get_lsp_pol(&lsp[1], f2);

	for (i = 5; i > 0; i--) {
		f1[i] += f1[i - 1];
		f2[i] -= f2[i - 1];
	}
	a[0] = 1;

	for (i = 1, j = 10; i <= 5; i++, j--) {
		a[i] = (Float32)((f1[i] + f2[i]) * 0.5F);
		a[j] = (Float32)((f1[i] - f2[i]) * 0.5F);
	}
	return;
}


/*
* Int_lpc_1and3_2
*
*
* Parameters:
*    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
*    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
*    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
*    az             O: interpolated LP parameters in subframes 1 and 3
*                                                                [AZ_SIZE]
*
* Function:
*    Interpolation of the LPC parameters. Same as the Int_lpc
*    function but we do not recompute Az() for subframe 2 and
*	   4 because it is already available.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1and3_2(Float32 lsp_old[], Float32 lsp_mid[], Float32
	lsp_new[], Float32 az[])
{
	Float32 lsp[M];
	Word32 i;


	for (i = 0; i < M; i += 2) {
		lsp[i] = (lsp_mid[i] + lsp_old[i]) * 0.5F;
		lsp[i + 1] = (lsp_mid[i + 1] + lsp_old[i + 1])*0.5F;
	}

	/* Subframe 1 */
	Lsp_Az(lsp, az);
	az += MP1 * 2;

	for (i = 0; i < M; i += 2) {
		lsp[i] = (lsp_mid[i] + lsp_new[i]) * 0.5F;
		lsp[i + 1] = (lsp_mid[i + 1] + lsp_new[i + 1])*0.5F;
	}

	/* Subframe 3 */
	Lsp_Az(lsp, az);
	return;
}


/*
* Lsp_lsf
*
*
* Parameters:
*    lsp               I: LSP vector
*    lsf               O: LSF vector
*
* Function:
*    Transformation lsp to lsf, LPC order M
*
* Returns:
*    void
*/
__device__ static void Lsp_lsf(Float32 lsp[], Float32 lsf[])
{
	Word32 i;


	for (i = 0; i < M; i++) {
		lsf[i] = (Float32)(acos(lsp[i])*SCALE_LSP_FREQ);
	}
	return;
}


/*
* Lsf_wt
*
*
* Parameters:
*    lsf               I: LSF vector
*    wf                O: square of weighting factors
*
* Function:
*    Compute LSF weighting factors
*
* Returns:
*    void
*/
__device__ static void Lsf_wt(Float32 *lsf, Float32 *wf)
{
	Float32 temp;
	Word32 i;


	wf[0] = lsf[1];

	for (i = 1; i < 9; i++) {
		wf[i] = lsf[i + 1] - lsf[i - 1];
	}
	wf[9] = 4000.0F - lsf[8];

	for (i = 0; i < 10; i++) {
		if (wf[i] < 450.0F) {
			temp = 3.347F - SLOPE1_WGHT_LSF * wf[i];
		}
		else {
			temp = 1.8F - SLOPE2_WGHT_LSF * (wf[i] - 450.0F);
		}
		wf[i] = temp * temp;
	}
	return;
}


/*
* Vq_subvec
*
*
* Parameters:
*    lsf_r1            I: 1st LSF residual vector
*    lsf_r2            I: 2nd LSF residual vector
*    dico              I: quantization codebook
*    wf1               I: 1st LSF weighting factors
*    wf2               I: 2nd LSF weighting factors
*    dico_size         I: size of quantization codebook
* Function:
*    Quantization of a 4 dimensional subvector
*
* Returns:
*    index             quantization index
*/
__device__ static Word16 Vq_subvec(Float32 *lsf_r1, Float32 *lsf_r2, const Float32 *dico,
	Float32 *wf1, Float32 *wf2, Word16 dico_size)
{
	Float64 temp, dist, dist_min;
	const Float32 *p_dico;
	Word32 i, index = 0;


	dist_min = DBL_MAX;
	p_dico = dico;

	for (i = 0; i < dico_size; i++) {
		temp = lsf_r1[0] - *p_dico++;
		dist = temp * temp * wf1[0];
		temp = lsf_r1[1] - *p_dico++;
		dist += temp * temp * wf1[1];
		temp = lsf_r2[0] - *p_dico++;
		dist += temp * temp * wf2[0];
		temp = lsf_r2[1] - *p_dico++;
		dist += temp * temp * wf2[1];

		if (dist < dist_min) {
			dist_min = dist;
			index = i;
		}
	}

	/* Reading the selected vector */
	p_dico = &dico[index << 2];
	lsf_r1[0] = *p_dico++;
	lsf_r1[1] = *p_dico++;
	lsf_r2[0] = *p_dico++;
	lsf_r2[1] = *p_dico++;
	return(Word16)index;
}


/*
* Vq_subvec_s
*
*
* Parameters:
*    lsf_r1            I: 1st LSF residual vector
*    lsf_r2            I: 2nd LSF residual vector
*    dico              I: quantization codebook
*    wf1               I: 1st LSF weighting factors
*    wf2               I: 2nd LSF weighting factors
*    dico_size         I: size of quantization codebook
* Function:
*    Quantization of a 4 dimensional subvector with a signed codebook
*
* Returns:
*    index             quantization index
*/
__device__ static Word16 Vq_subvec_s(Float32 *lsf_r1, Float32 *lsf_r2, const Float32 *dico
	, Float32 *wf1, Float32 *wf2, Word16 dico_size)
{
	Float64 dist_min, dist1, dist2, temp1, temp2;
	const Float32 *p_dico;
	Word32 i, index = 0;
	Word16 sign = 0;


	dist_min = DBL_MAX;
	p_dico = dico;

	for (i = 0; i < dico_size; i++) {
		temp1 = lsf_r1[0] - *p_dico;
		temp2 = lsf_r1[0] + *p_dico++;
		dist1 = temp1 * temp1 * wf1[0];
		dist2 = temp2 * temp2 * wf1[0];
		temp1 = lsf_r1[1] - *p_dico;
		temp2 = lsf_r1[1] + *p_dico++;
		dist1 += temp1 * temp1 * wf1[1];
		dist2 += temp2 * temp2 * wf1[1];
		temp1 = lsf_r2[0] - *p_dico;
		temp2 = lsf_r2[0] + *p_dico++;
		dist1 += temp1 * temp1 * wf2[0];
		dist2 += temp2 * temp2 * wf2[0];
		temp1 = lsf_r2[1] - *p_dico;
		temp2 = lsf_r2[1] + *p_dico++;
		dist1 += temp1 * temp1 * wf2[1];
		dist2 += temp2 * temp2 * wf2[1];

		if (dist1 < dist_min) {
			dist_min = dist1;
			index = i;
			sign = 0;
		}

		if (dist2 < dist_min) {
			dist_min = dist2;
			index = i;
			sign = 1;
		}
	}

	/* Reading the selected vector */
	p_dico = &dico[index << 2];

	if (sign == 0) {
		lsf_r1[0] = *p_dico++;
		lsf_r1[1] = *p_dico++;
		lsf_r2[0] = *p_dico++;
		lsf_r2[1] = *p_dico++;
	}
	else {
		lsf_r1[0] = -(*p_dico++);
		lsf_r1[1] = -(*p_dico++);
		lsf_r2[0] = -(*p_dico++);
		lsf_r2[1] = -(*p_dico++);
	}
	index = index << 1;
	index = index + sign;
	return(Word16)index;
}


/*
* Reorder_lsf
*
*
* Parameters:
*    lsf               B: vector of LSFs
*    min_dist          I: minimum required distance
*
* Function:
*    Make sure that the LSFs are properly ordered and to keep a certain minimum
*    distance between adjacent LSFs. LPC order = M.
*
* Returns:
*    void
*/
__device__ static void Reorder_lsf(Float32 *lsf, Float32 min_dist)
{
	Float32 lsf_min;
	Word32 i;


	lsf_min = min_dist;

	for (i = 0; i < M; i++) {
		if (lsf[i] < lsf_min) {
			lsf[i] = lsf_min;
		}
		lsf_min = lsf[i] + min_dist;
	}
}


/*
* Lsf_lsp
*
*
* Parameters:
*    lsf               I: vector of LSFs
*    lsp	            O: vector of LSPs
*
* Function:
*    Transformation lsf to lsp, order M
*
* Returns:
*    void
*/
__device__ static void Lsf_lsp(Float32 lsf[], Float32 lsp[])
{
	Word32 i;


	for (i = 0; i < M; i++) {
		lsp[i] = (Float32)cos(SCALE_FREQ_LSP * lsf[i]);
	}
	return;
}


/*
* Vq_subvec3
*
*
* Parameters:
*    lsf_r1            I: 1st LSF residual vector
*    dico              I: quantization codebook
*    wf1               I: 1st LSF weighting factors
*    dico_size         I: size of quantization codebook
*    use_half          I: use every second entry in codebook
*
* Function:
*    Quantization of a 3 dimensional subvector
*
* Returns:
*    index             quantization index
*/
__device__ static Word16 Vq_subvec3(Float32 *lsf_r1, const Float32 *dico, Float32 *wf1,
	Word16 dico_size, Word32 use_half)
{
	Float64 dist, dist_min;
	Float32 temp;
	const Float32 *p_dico;
	Word32 i, index = 0;


	dist_min = FLT_MAX;
	p_dico = dico;

	if (use_half == 0) {
		for (i = 0; i < dico_size; i++) {
			temp = lsf_r1[0] - *p_dico++;
			temp *= wf1[0];
			dist = temp * temp;
			temp = lsf_r1[1] - *p_dico++;
			temp *= wf1[1];
			dist += temp * temp;
			temp = lsf_r1[2] - *p_dico++;
			temp *= wf1[2];
			dist += temp * temp;

			if (dist < dist_min) {
				dist_min = dist;
				index = i;
			}
		}
		p_dico = &dico[(3 * index)];
	}
	else {
		for (i = 0; i < dico_size; i++) {
			temp = lsf_r1[0] - *p_dico++;
			temp *= wf1[0];
			dist = temp * temp;
			temp = lsf_r1[1] - *p_dico++;
			temp *= wf1[1];
			dist += temp * temp;
			temp = lsf_r1[2] - *p_dico++;
			temp *= wf1[2];
			dist += temp * temp;

			if (dist < dist_min) {
				dist_min = dist;
				index = i;
			}
			p_dico = p_dico + 3;
		}
		p_dico = &dico[6 * index];
	}

	/* Reading the selected vector */
	lsf_r1[0] = *p_dico++;
	lsf_r1[1] = *p_dico++;
	lsf_r1[2] = *p_dico++;
	return(Word16)index;
}


/*
* Vq_subvec4
*
*
* Parameters:
*    lsf_r1            I: 1st LSF residual vector
*    dico              I: quantization codebook
*    wf1               I: 1st LSF weighting factors
*    dico_size         I: size of quantization codebook
*
* Function:
*    Quantization of a 4 dimensional subvector
*
* Returns:
*    index             quantization index
*/
__device__ static Word16 Vq_subvec4(Float32 *lsf_r1, const Float32 *dico, Float32 *wf1,
	Word16 dico_size)
{
	Float64 dist, dist_min;
	Float32 temp;
	const Float32 *p_dico;
	Word32 i, index = 0;


	dist_min = FLT_MAX;
	p_dico = dico;

	for (i = 0; i < dico_size; i++) {
		temp = lsf_r1[0] - *p_dico++;
		temp *= wf1[0];
		dist = temp * temp;
		temp = lsf_r1[1] - *p_dico++;
		temp *= wf1[1];
		dist += temp * temp;
		temp = lsf_r1[2] - *p_dico++;
		temp *= wf1[2];
		dist += temp * temp;
		temp = lsf_r1[3] - *p_dico++;
		temp *= wf1[3];
		dist += temp * temp;

		if (dist < dist_min) {
			dist_min = dist;
			index = i;
		}
	}

	/* Reading the selected vector */
	p_dico = &dico[index << 2];
	lsf_r1[0] = *p_dico++;
	lsf_r1[1] = *p_dico++;
	lsf_r1[2] = *p_dico++;
	lsf_r1[3] = *p_dico++;
	return(Word16)index;
}


/*
* Q_plsf_3
*
*
* Parameters:
*    mode              I: AMR mode
*    past_rq           B: past quantized residual
*    lsp1              I: 1st LSP vector
*    lsp1_q            O: quantized 1st LSP vector
*    indice            I: quantization indices of 5 matrices and
*                         one sign for 3rd
*    pred_init_i       O: init index for MA prediction in DTX mode
*
* Function:
*    Quantization of LSF parameters with 1st order MA prediction and
*    split by 3 vector quantization (split-VQ)
*
* Returns:
*    void
*/
__device__ static void Q_plsf_3(enum Mode mode, Float32 *past_rq, Float32 *lsp1, Float32 *
	lsp1_q, Word16 *indice, Word32 *pred_init_i)
{
	Float32 lsf1[M], wf1[M], lsf_p[M], lsf_r1[M];
	Float32 lsf1_q[M];
	Float32 pred_init_err;
	Float32 min_pred_init_err;
	Float32 temp_r1[M];
	Float32 temp_p[M];
	Word32 j, i;


	/* convert LSFs to normalize frequency domain */
	Lsp_lsf(lsp1, lsf1);

	/* compute LSF weighting factors */
	Lsf_wt(lsf1, wf1);

	/* Compute predicted LSF and prediction error */
	if (mode != MRDTX) {
		for (i = 0; i < M; i++) {
			lsf_p[i] = mean_lsf_3[i] + past_rq[i] * pred_fac[i];
			lsf_r1[i] = lsf1[i] - lsf_p[i];
		}
	}
	else {
		/*
		* DTX mode, search the init vector that yields
		* lowest prediction resuidual energy
		*/
		*pred_init_i = 0;
		min_pred_init_err = FLT_MAX;

		for (j = 0; j < PAST_RQ_INIT_SIZE; j++) {
			pred_init_err = 0;

			for (i = 0; i < M; i++) {
				temp_p[i] = mean_lsf_3[i] + past_rq_init[j * M + i];
				temp_r1[i] = lsf1[i] - temp_p[i];
				pred_init_err += temp_r1[i] * temp_r1[i];
			}   /* next i */

			if (pred_init_err < min_pred_init_err) {
				min_pred_init_err = pred_init_err;
				memcpy(lsf_r1, temp_r1, M << 2);
				memcpy(lsf_p, temp_p, M << 2);
				memcpy(past_rq, &past_rq_init[j * M], M << 2);
				*pred_init_i = j;
			}
		}
	}

	/* Split-VQ of prediction error */
	/* MR475, MR515 */
	if ((mode == MR475) || (mode == MR515)) {
		indice[0] = Vq_subvec3(&lsf_r1[0], dico1_lsf_3, &wf1[0], DICO1_SIZE_3, 0
		);
		indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3 / 2,
			1);
		indice[2] = Vq_subvec4(&lsf_r1[6], mr515_3_lsf, &wf1[6], MR515_3_SIZE);
	}

	/* MR795 */
	else if (mode == MR795) {
		indice[0] = Vq_subvec3(&lsf_r1[0], mr795_1_lsf, &wf1[0], MR795_1_SIZE, 0
		);
		indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3, 0
		);
		indice[2] = Vq_subvec4(&lsf_r1[6], dico3_lsf_3, &wf1[6], DICO3_SIZE_3);
	}

	/* MR59, MR67, MR74, MR102 , MRDTX */
	else {
		indice[0] = Vq_subvec3(&lsf_r1[0], dico1_lsf_3, &wf1[0], DICO1_SIZE_3, 0
		);
		indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf_3, &wf1[3], DICO2_SIZE_3, 0
		);
		indice[2] = Vq_subvec4(&lsf_r1[6], dico3_lsf_3, &wf1[6], DICO3_SIZE_3);
	}

	/* Compute quantized LSFs and update the past quantized residual */
	for (i = 0; i < M; i++) {
		lsf1_q[i] = lsf_r1[i] + lsf_p[i];
		past_rq[i] = lsf_r1[i];
	}

	/* verification that LSFs has mimimum distance of LSF_GAP 50 Hz */
	Reorder_lsf(lsf1_q, 50.0F);

	/*  convert LSFs to the cosine domain */
	Lsf_lsp(lsf1_q, lsp1_q);
}


/*
* Q_plsf_5
*
*
* Parameters:
*    past_rq           B: past quantized residual
*    lsp1              I: 1st LSP vector
*    lsp2              I: 2nd LSP vector
*    lsp1_q            O: quantized 1st LSP vector
*    lsp2_q            O: quantized 2nd LSP vector
*    indice	         I: quantization indices of 5 matrices and
*                         one sign for 3rd
*
* Function:
*    Quantization of 2 sets of LSF parameters using 1st order MA
*    prediction and split by 5 matrix quantization (split-MQ).
*
* Returns:
*    void
*/
__device__ static void Q_plsf_5(Float32 *past_rq, Float32 *lsp1, Float32 *lsp2, Float32 *
	lsp1_q, Float32 *lsp2_q, Word16 *indice)
{
	Float32 lsf1[M], lsf2[M], wf1[M], wf2[M], lsf_p[M], lsf_r1[M], lsf_r2[M];
	Float32 lsf1_q[M], lsf2_q[M];
	Word32 i;


	/* convert LSFs to normalize frequency domain */
	Lsp_lsf(lsp1, lsf1);
	Lsp_lsf(lsp2, lsf2);

	/* Compute LSF weighting factors */
	Lsf_wt(lsf1, wf1);
	Lsf_wt(lsf2, wf2);

	/* Compute predicted LSF and prediction error */
	for (i = 0; i < M; i++) {
		/* MR122 LSP prediction factor = 0.65 */
		lsf_p[i] = mean_lsf_5[i] + past_rq[i] * 0.65F;
		lsf_r1[i] = lsf1[i] - lsf_p[i];
		lsf_r2[i] = lsf2[i] - lsf_p[i];
	}

	/* Split-MQ of prediction error */
	indice[0] = Vq_subvec(&lsf_r1[0], &lsf_r2[0], dico1_lsf_5, &wf1[0], &wf2[0],
		DICO1_SIZE_5);
	indice[1] = Vq_subvec(&lsf_r1[2], &lsf_r2[2], dico2_lsf_5, &wf1[2], &wf2[2],
		DICO2_SIZE_5);
	indice[2] = Vq_subvec_s(&lsf_r1[4], &lsf_r2[4], dico3_lsf_5, &wf1[4], &wf2[4
	], DICO3_SIZE_5);
	indice[3] = Vq_subvec(&lsf_r1[6], &lsf_r2[6], dico4_lsf_5, &wf1[6], &wf2[6],
		DICO4_SIZE_5);
	indice[4] = Vq_subvec(&lsf_r1[8], &lsf_r2[8], dico5_lsf_5, &wf1[8], &wf2[8],
		DICO5_SIZE_5);

	/* Compute quantized LSFs and update the past quantized residual */
	for (i = 0; i < M; i++) {
		lsf1_q[i] = lsf_r1[i] + lsf_p[i];
		lsf2_q[i] = lsf_r2[i] + lsf_p[i];
		past_rq[i] = lsf_r2[i];
	}

	/* verification that LSFs has minimum distance of LSF_GAP 50hz */
	Reorder_lsf(lsf1_q, 50.0F);
	Reorder_lsf(lsf2_q, 50.0F);

	/*  convert LSFs to the cosine domain */
	Lsf_lsp(lsf1_q, lsp1_q);
	Lsf_lsp(lsf2_q, lsp2_q);
}


/*
* Int_lpc_1and3
*
*
* Parameters:
*    lsp_old        I: LSP vector at the 4th subfr. of past frame      [M]
*    lsp_mid        I: LSP vector at the 2nd subframe of present frame [M]
*    lsp_new        I: LSP vector at the 4th subframe of present frame [M]
*    az             O: interpolated LP parameters in subframes 1 and 3
*                                                                [AZ_SIZE]
*
* Function:
*    Interpolates the LSPs and converts to LPC parameters
*    to get a different LP filter in each subframe.
*
*    The 20 ms speech frame is divided into 4 subframes.
*    The LSPs are quantized and transmitted at the 2nd and
*    4th subframes (twice per frame) and interpolated at the
*    1st and 3rd subframe.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1and3(Float32 lsp_old[], Float32 lsp_mid[], Float32 lsp_new
	[], Float32 az[])
{
	Word32 i;
	Float32 lsp[M];


	for (i = 0; i < M; i++) {
		lsp[i] = (lsp_mid[i] + lsp_old[i]) * 0.5F;
	}

	/* Subframe 1 */
	Lsp_Az(lsp, az);
	az += MP1;

	/* Subframe 2 */
	Lsp_Az(lsp_mid, az);
	az += MP1;

	for (i = 0; i < M; i++) {
		lsp[i] = (lsp_mid[i] + lsp_new[i]) * 0.5F;
	}

	/* Subframe 3 */
	Lsp_Az(lsp, az);
	az += MP1;

	/* Subframe 4 */
	Lsp_Az(lsp_new, az);
	return;
}


/*
* Int_lpc_1to3_2
*
*
* Parameters:
*    lsp_old           I: LSP vector at the 4th subfr. of past frame      [M]
*    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
*    az                O: interpolated LP parameters in subframes 1, 2 and 3
*                                                                   [AZ_SIZE]
*
* Function:
*    Interpolation of the LPC parameters.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1to3_2(Float32 lsp_old[], Float32 lsp_new[], Float32 az[])
{
	Float32 lsp[M];
	Word32 i;


	for (i = 0; i < M; i += 2) {
		lsp[i] = lsp_new[i] * 0.25F + lsp_old[i] * 0.75F;
		lsp[i + 1] = lsp_new[i + 1] * 0.25F + lsp_old[i + 1] * 0.75F;
	}

	/* Subframe 1 */
	Lsp_Az(lsp, az);
	az += MP1;

	for (i = 0; i < M; i += 2) {
		lsp[i] = (lsp_old[i] + lsp_new[i]) * 0.5F;
		lsp[i + 1] = (lsp_old[i + 1] + lsp_new[i + 1])*0.5F;
	}

	/* Subframe 2 */
	Lsp_Az(lsp, az);
	az += MP1;

	for (i = 0; i < M; i += 2) {
		lsp[i] = lsp_old[i] * 0.25F + lsp_new[i] * 0.75F;
		lsp[i + 1] = lsp_old[i + 1] * 0.25F + lsp_new[i + 1] * 0.75F;
	}

	/* Subframe 3 */
	Lsp_Az(lsp, az);
	return;
}


/*
* Int_lpc_1to3
*
*
* Parameters:
*    lsp_old           I: LSP vector at the 4th subfr. of past frame      [M]
*    lsp_new           I: LSP vector at the 4th subframe of present frame [M]
*    az                O: interpolated LP parameters in all subframes
*                                                                   [AZ_SIZE]
*
* Function:
*    Interpolates the LSPs and converts to LPC parameters to get a different
*    LP filter in each subframe.
*
*    The 20 ms speech frame is divided into 4 subframes.
*    The LSPs are quantized and transmitted at the 4th
*    subframes (once per frame) and interpolated at the
*    1st, 2nd and 3rd subframe.
*
* Returns:
*    void
*/
__device__ static void Int_lpc_1to3(Float32 lsp_old[], Float32 lsp_new[], Float32 az[])
{
	Float32 lsp[M];
	Word32 i;


	for (i = 0; i < M; i++) {
		lsp[i] = lsp_new[i] * 0.25F + lsp_old[i] * 0.75F;
	}

	/* Subframe 1 */
	Lsp_Az(lsp, az);
	az += MP1;

	for (i = 0; i < M; i++) {
		lsp[i] = (lsp_old[i] + lsp_new[i]) * 0.5F;
	}

	/* Subframe 2 */
	Lsp_Az(lsp, az);
	az += MP1;

	for (i = 0; i < M; i++) {
		lsp[i] = lsp_old[i] * 0.25F + lsp_new[i] * 0.75F;
	}

	/* Subframe 3 */
	Lsp_Az(lsp, az);
	az += MP1;

	/* Subframe 4 */
	Lsp_Az(lsp_new, az);
	return;
}


/*
* lsp
*
*
* Parameters:
*    req_mode          I: requested mode
*    used_mode         I: used mode
*    lsp_old           B: old LSP vector
*    lsp_old_q         B: old quantized LSP vector
*    past_rq           B: past quantized residual
*    az                B: interpolated LP parameters
*    azQ               O: quantization interpol. LP parameters
*    lsp_new           O: new lsp vector
*    anap              O: analysis parameters
*
* Function:
*    From A(z) to lsp. LSP quantization and interpolation
*
* Returns:
*    void
*/
__device__ static void lsp(enum Mode req_mode, enum Mode used_mode, Float32 *lsp_old,
	Float32 *lsp_old_q, Float32 *past_rq, Float32 az[], Float32 azQ[], Float32
	lsp_new[], Word16 **anap)
{
	Float32 lsp_new_q[M];   /* LSPs at 4th subframe */
	Float32 lsp_mid[M], lsp_mid_q[M];   /* LSPs at 2nd subframe */
	Word32 pred_init_i;   /* init index for MA prediction in DTX mode */


	if (req_mode == MR122) {
		Az_lsp(&az[MP1], lsp_mid, lsp_old);
		Az_lsp(&az[MP1 * 3], lsp_new, lsp_mid);

		/*
		* Find interpolated LPC parameters in all subframes
		* (both quantized and unquantized).
		* The interpolated parameters are in array A_t[] of size (M+1)*4
		* and the quantized interpolated parameters are in array Aq_t[]
		*/
		Int_lpc_1and3_2(lsp_old, lsp_mid, lsp_new, az);

		if (used_mode != MRDTX) {
			/* LSP quantization (lsp_mid[] and lsp_new[] jointly quantized) */
			Q_plsf_5(past_rq, lsp_mid, lsp_new, lsp_mid_q, lsp_new_q, *anap);
			Int_lpc_1and3(lsp_old_q, lsp_mid_q, lsp_new_q, azQ);

			/* Advance analysis parameters pointer */
			(*anap) += 5;
		}
	}
	else {
		/* From A(z) to lsp */
		Az_lsp(&az[MP1 * 3], lsp_new, lsp_old);

		/*
		* Find interpolated LPC parameters in all subframes
		* (both quantized and unquantized).
		* The interpolated parameters are in array A_t[] of size (M+1)*4
		* and the quantized interpolated parameters are in array Aq_t[]
		*/
		Int_lpc_1to3_2(lsp_old, lsp_new, az);

		/* LSP quantization */
		if (used_mode != MRDTX) {
			Q_plsf_3(req_mode, past_rq, lsp_new, lsp_new_q, *anap, &pred_init_i);
			Int_lpc_1to3(lsp_old_q, lsp_new_q, azQ);

			/* Advance analysis parameters pointer */
			(*anap) += 3;
		}
	}

	/* update the LSPs for the next frame */
	memcpy(lsp_old, lsp_new, M << 2);
	memcpy(lsp_old_q, lsp_new_q, M << 2);
}


/*
* check_lsp
*
*
* Parameters:
*    count          B: counter for resonance
*    lsp            B: LSP vector
*
* Function:
*    Check the LSP's to detect resonances
*
*    Resonances in the LPC filter are monitored to detect possible problem
*    areas where divergence between the adaptive codebook memories in
*    the encoder and the decoder could cause unstable filters in areas
*    with highly correlated continuos signals. Typically, this divergence
*    is due to channel errors.
*    The monitoring of resonance signals is performed using unquantized LSPs
*    q(i), i = 1,...,10. The algorithm utilises the fact that LSPs are
*    closely located at a peak in the spectrum. First, two distances,
*    dist 1 and dist 2 ,are calculated in two different regions,
*    defined as
*
*    dist1 = min[q(i) - q(i + 1)],  i = 4,...,8
*    dist2 = min[q(i) - q(i + 1)],  i = 2,3
*
*    Either of these two minimum distance conditions must be fulfilled
*    to classify the frame as a resonance frame and increase the resonance
*    counter.
*
*    if(dist1 < TH1) || if (dist2 < TH2)
*       counter++
*    else
*       counter = 0
*
*    TH1 = 0.046
*    TH2 = 0.018, q(2) > 0.98
*    TH2 = 0.024, 0.93 < q(2) <= 0.98
*    TH2 = 0.018, otherwise
*
*    12 consecutive resonance frames are needed to indicate possible
*    problem conditions, otherwise the LSP_flag is cleared.
*
* Returns:
*    resonance flag
*/
__device__ static Word16 check_lsp(Word16 *count, Float32 *lsp)
{
	Float32 dist, dist_min1, dist_min2, dist_th;
	Word32 i;


	/*
	* Check for a resonance:
	* Find minimum distance between lsp[i] and lsp[i+1]
	*/
	dist_min1 = FLT_MAX;

	for (i = 3; i < 8; i++) {
		dist = lsp[i] - lsp[i + 1];

		if (dist < dist_min1) {
			dist_min1 = dist;
		}
	}
	dist_min2 = FLT_MAX;

	for (i = 1; i < 3; i++) {
		dist = lsp[i] - lsp[i + 1];

		if (dist < dist_min2) {
			dist_min2 = dist;
		}
	}

	if (lsp[1] > 0.98F) {
		dist_th = 0.018F;
	}
	else if (lsp[1] > 0.93F) {
		dist_th = 0.024F;
	}
	else {
		dist_th = 0.034F;
	}

	if ((dist_min1 < 0.046F) || (dist_min2 < dist_th)) {
		*count += 1;
	}
	else {
		*count = 0;
	}

	/* Need 12 consecutive frames to set the flag */
	if (*count >= 12) {
		*count = 12;
		return 1;
	}
	else {
		return 0;
	}
}


/*
* Weight_Ai
*
*
* Parameters:
*    a                 I: LPC coefficients                    [M+1]
*    fac               I: Spectral expansion factors.         [M+1]
*    a_exp             O: Spectral expanded LPC coefficients  [M+1]
*
* Function:
*    Spectral expansion of LP coefficients
*
* Returns:
*    void
*/
__device__ static void Weight_Ai(Float32 a[], const Float32 fac[], Float32 a_exp[])
{
	Word32 i;


	a_exp[0] = a[0];

	for (i = 1; i <= M; i++) {
		a_exp[i] = a[i] * fac[i - 1];
	}
	return;
}


/*
* Residu
*
*
* Parameters:
*    a                 I: prediction coefficients
*    x                 I: speech signal
*    y                 O: residual signal
*
* Function:
*    Computes the LTP residual signal.
*
* Returns:
*    void
*/
__device__ static void Residu(Float32 a[], Float32 x[], Float32 y[])
{
	Float32 s;
	Word32 i;


	for (i = 0; i < L_SUBFR; i += 4) {
		s = x[i] * a[0];
		s += x[i - 1] * a[1];
		s += x[i - 2] * a[2];
		s += x[i - 3] * a[3];
		s += x[i - 4] * a[4];
		s += x[i - 5] * a[5];
		s += x[i - 6] * a[6];
		s += x[i - 7] * a[7];
		s += x[i - 8] * a[8];
		s += x[i - 9] * a[9];
		s += x[i - 10] * a[10];
		y[i] = s;
		s = x[i + 1] * a[0];
		s += x[i] * a[1];
		s += x[i - 1] * a[2];
		s += x[i - 2] * a[3];
		s += x[i - 3] * a[4];
		s += x[i - 4] * a[5];
		s += x[i - 5] * a[6];
		s += x[i - 6] * a[7];
		s += x[i - 7] * a[8];
		s += x[i - 8] * a[9];
		s += x[i - 9] * a[10];
		y[i + 1] = s;
		s = x[i + 2] * a[0];
		s += x[i + 1] * a[1];
		s += x[i] * a[2];
		s += x[i - 1] * a[3];
		s += x[i - 2] * a[4];
		s += x[i - 3] * a[5];
		s += x[i - 4] * a[6];
		s += x[i - 5] * a[7];
		s += x[i - 6] * a[8];
		s += x[i - 7] * a[9];
		s += x[i - 8] * a[10];
		y[i + 2] = s;
		s = x[i + 3] * a[0];
		s += x[i + 2] * a[1];
		s += x[i + 1] * a[2];
		s += x[i] * a[3];
		s += x[i - 1] * a[4];
		s += x[i - 2] * a[5];
		s += x[i - 3] * a[6];
		s += x[i - 4] * a[7];
		s += x[i - 5] * a[8];
		s += x[i - 6] * a[9];
		s += x[i - 7] * a[10];
		y[i + 3] = s;
	}
	return;
}


/*
* Syn_filt
*
*
* Parameters:
*    a                 I: prediction coefficients [M+1]
*    x                 I: input signal
*    y                 O: output signal
*    mem               B: memory associated with this filtering
*    update            I: 0=no update, 1=update of memory.
*
* Function:
*    Perform synthesis filtering through 1/A(z).
*
* Returns:
*    void
*/
__device__ static void Syn_filt(Float32 a[], Float32 x[], Float32 y[], Float32 mem[],
	Word16 update)
{
	Float64 tmp[50];
	Float64 sum;
	Float64 *yy;
	Word32 i;


	/* Copy mem[] to yy[] */
	yy = tmp;

	for (i = 0; i < M; i++) {
		*yy++ = mem[i];
	}

	/* Do the filtering. */
	for (i = 0; i < L_SUBFR; i = i + 4) {
		sum = x[i] * a[0];
		sum -= a[1] * yy[-1];
		sum -= a[2] * yy[-2];
		sum -= a[3] * yy[-3];
		sum -= a[4] * yy[-4];
		sum -= a[5] * yy[-5];
		sum -= a[6] * yy[-6];
		sum -= a[7] * yy[-7];
		sum -= a[8] * yy[-8];
		sum -= a[9] * yy[-9];
		sum -= a[10] * yy[-10];
		*yy++ = sum;
		y[i] = (Float32)yy[-1];
		sum = x[i + 1] * a[0];
		sum -= a[1] * yy[-1];
		sum -= a[2] * yy[-2];
		sum -= a[3] * yy[-3];
		sum -= a[4] * yy[-4];
		sum -= a[5] * yy[-5];
		sum -= a[6] * yy[-6];
		sum -= a[7] * yy[-7];
		sum -= a[8] * yy[-8];
		sum -= a[9] * yy[-9];
		sum -= a[10] * yy[-10];
		*yy++ = sum;
		y[i + 1] = (Float32)yy[-1];
		sum = x[i + 2] * a[0];
		sum -= a[1] * yy[-1];
		sum -= a[2] * yy[-2];
		sum -= a[3] * yy[-3];
		sum -= a[4] * yy[-4];
		sum -= a[5] * yy[-5];
		sum -= a[6] * yy[-6];
		sum -= a[7] * yy[-7];
		sum -= a[8] * yy[-8];
		sum -= a[9] * yy[-9];
		sum -= a[10] * yy[-10];
		*yy++ = sum;
		y[i + 2] = (Float32)yy[-1];
		sum = x[i + 3] * a[0];
		sum -= a[1] * yy[-1];
		sum -= a[2] * yy[-2];
		sum -= a[3] * yy[-3];
		sum -= a[4] * yy[-4];
		sum -= a[5] * yy[-5];
		sum -= a[6] * yy[-6];
		sum -= a[7] * yy[-7];
		sum -= a[8] * yy[-8];
		sum -= a[9] * yy[-9];
		sum -= a[10] * yy[-10];
		*yy++ = sum;
		y[i + 3] = (Float32)yy[-1];
	}

	/* Update of memory if update==1 */
	if (update != 0) {
		for (i = 0; i < M; i++) {
			mem[i] = y[30 + i];
		}
	}
	return;
}


/*
* pre_big
*
*
* Parameters:
*    mode              I: AMR mode
*    gamma1            I: spectral exp. factor 1
*    gamma1_12k2       I: spectral exp. factor 1 for modes above MR795
*    gamma2            I: spectral exp. factor 2
*    A_t               I: A(z) unquantized, for 4 subframes
*    frame_offset      I: frameoffset, 1st or second big_sbf
*    speech            I: speech
*    mem_w             B: synthesis filter memory state
*    wsp               O: weighted speech
*
* Function:
*    Big subframe (2 subframes) preprocessing
*
*    Open-loop pitch analysis is performed in order to simplify the pitch
*    analysis and confine the closed-loop pitch search to a small number of
*    lags around the open-loop estimated lags.
*    Open-loop pitch estimation is based on the weighted speech signal Sw(n)
*    which is obtained by filtering the input speech signal through
*    the weighting filter
*
*    W(z) = A(z/g1) / A(z/g2)
*
*    That is, in a subframe of size L, the weighted speech is given by:
*
*                    10                           10
*    Sw(n) = S(n) + SUM[a(i) * g1(i) * S(n-i)] - SUM[a(i) * g2(i) * Sw(n-i)],
*                   i=1                          i=1
*    n = 0, ..., L-1
*
* Returns:
*    void
*/
__device__ static Word32 pre_big(enum Mode mode, const Float32 gamma1[], const Float32
	gamma1_12k2[], const Float32 gamma2[], Float32 A_t[], Word16 frame_offset,
	Float32 speech[], Float32 mem_w[], Float32 wsp[])
{
	Float32 Ap1[MP1], Ap2[MP1];
	Word32 offset, i;


	/* A(z) with spectral expansion */
	const Float32 *g1;


	g1 = gamma1_12k2;

	if (mode <= MR795) {
		g1 = gamma1;
	}
	offset = 0;

	if (frame_offset > 0) {
		offset = MP1 << 1;
	}

	/* process two subframes (which form the "big" subframe) */
	for (i = 0; i < 2; i++) {
		/* a(i) * g1(i) */
		Weight_Ai(&A_t[offset], g1, Ap1);

		/* a(i) * g2(i) */
		Weight_Ai(&A_t[offset], gamma2, Ap2);

		/*
		*       10
		*  S(n) + SUM[a(i) * g1(i) * S(n-i)]
		*       i=1
		*/
		Residu(Ap1, &speech[frame_offset], &wsp[frame_offset]);

		/*
		*          10                            10
		*  S(n) + SUM[a(i) * g1(i) * S(n-i)]    SUM[a(i) * g2(i) * Sn(n-i)]
		*         i=1                           i=1
		*/
		Syn_filt(Ap2, &wsp[frame_offset], &wsp[frame_offset], mem_w, 1);
		offset += MP1;
		frame_offset += L_SUBFR;
	}
	return 0;
}


/*
* comp_corr
*
*
* Parameters:
*    sig               I: signal
*    L_frame           I: length of frame to compute pitch
*    lag_max           I: maximum lag
*    lag_min           I: minimum lag
*    corr              O: correlation of selected lag
*
* Function:
*    Calculate all correlations in a given delay range.
*
* Returns:
*    void
*/
__device__ static void comp_corr(Float32 sig[], Word32 L_frame, Word32 lag_max, Word32
	lag_min, Float32 corr[])
{
	Word32 i, j;
	Float32 *p, *p1;
	Float32 T0;


	for (i = lag_max; i >= lag_min; i--) {
		p = sig;
		p1 = &sig[-i];
		T0 = 0.0F;

		for (j = 0; j < L_frame; j = j + 40, p += 40, p1 += 40) {
			T0 += p[0] * p1[0] + p[1] * p1[1] + p[2] * p1[2] + p[3] * p1[3];
			T0 += p[4] * p1[4] + p[5] * p1[5] + p[6] * p1[6] + p[7] * p1[7];
			T0 += p[8] * p1[8] + p[9] * p1[9] + p[10] * p1[10] + p[11] * p1[11];
			T0 += p[12] * p1[12] + p[13] * p1[13] + p[14] * p1[14] + p[15] * p1[15]
				;
			T0 += p[16] * p1[16] + p[17] * p1[17] + p[18] * p1[18] + p[19] * p1[19]
				;
			T0 += p[20] * p1[20] + p[21] * p1[21] + p[22] * p1[22] + p[23] * p1[23]
				;
			T0 += p[24] * p1[24] + p[25] * p1[25] + p[26] * p1[26] + p[27] * p1[27]
				;
			T0 += p[28] * p1[28] + p[29] * p1[29] + p[30] * p1[30] + p[31] * p1[31]
				;
			T0 += p[32] * p1[32] + p[33] * p1[33] + p[34] * p1[34] + p[35] * p1[35]
				;
			T0 += p[36] * p1[36] + p[37] * p1[37] + p[38] * p1[38] + p[39] * p1[39]
				;
		}
		corr[-i] = T0;
	}
	return;
}


/*
* vad_tone_detection
*
*
* Parameters:
*    st->tone          B: flags indicating presence of a tone
*    T0                I: autocorrelation maxima
*    t1                I: energy
*
* Function:
*    Set tone flag if pitch gain is high.
*    This is used to detect signaling tones and other signals
*    with high pitch gain.
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void vad_tone_detection(vadState *st, Float32 T0, Float32 t1)
{
	if ((t1 > 0) && (T0 > t1 * TONE_THR)) {
		st->tone = st->tone | 0x00004000;
	}
}
#endif

/*
* Lag_max
*
*
* Parameters:
*    vadSt          B: vad structure
*    corr           I: correlation vector
*    sig            I: signal
*    L_frame        I: length of frame to compute pitch
*    lag_max        I: maximum lag
*    lag_min        I: minimum lag
*    cor_max        O: maximum correlation
*    dtx            I: dtx on/off
*
* Function:
*    Compute the open loop pitch lag.
*
* Returns:
*    p_max             lag found
*/
#ifdef VAD2
__device__ static Word16 Lag_max(Float32 corr[], Float32 sig[], Word16 L_frame,
	Word32 lag_max, Word32 lag_min, Float32 *cor_max,
	Word32 dtx, Float32 *rmax, Float32 *r0)
#else
__device__ static Word16 Lag_max(vadState *vadSt, Float32 corr[], Float32 sig[], Word16
	L_frame, Word32 lag_max, Word32 lag_min, Float32 *cor_max, Word32 dtx)
#endif
{
	Float32 max, T0;
	Float32 *p;
	Word32 i, j, p_max;


	max = -FLT_MAX;
	p_max = lag_max;

	for (i = lag_max, j = (PIT_MAX - lag_max - 1); i >= lag_min; i--, j--) {
		if (corr[-i] >= max) {
			max = corr[-i];
			p_max = i;
		}
	}

	/* compute energy for normalization */
	T0 = 0.0F;
	p = &sig[-p_max];

	for (i = 0; i < L_frame; i++, p++) {
		T0 += *p * *p;
	}

	if (dtx) {
#ifdef VAD2
		*rmax = max;
		*r0 = T0;
#else
		/* check tone */
		vad_tone_detection(vadSt, max, T0);
#endif
	}

	if (T0 > 0.0F)
		T0 = 1.0F / (Float32)sqrt(T0);
	else
		T0 = 0.0F;

	/* max = max/sqrt(energy) */
	max *= T0;
	*cor_max = max;
	return((Word16)p_max);
}


/*
* hp_max
*
*
* Parameters:
*    corr           I: correlation vector
*    sig            I: signal
*    L_frame        I: length of frame to compute pitch
*    lag_max        I: maximum lag
*    lag_min        I: minimum lag
*    cor_hp_max     O: max high-pass filtered correlation
*
* Function:
*    Find the maximum correlation of scal_sig[] in a given delay range.
*
*    The correlation is given by
*       cor[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
*    The functions outputs the maximum correlation after normalization
*    and the corresponding lag.
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void hp_max(Float32 corr[], Float32 sig[], Word32 L_frame, Word32
	lag_max, Word32 lag_min, Float32 *cor_hp_max)
{
	Float32 T0, t1, max;
	Float32 *p, *p1;
	Word32 i;


	max = -FLT_MAX;
	T0 = 0;

	for (i = lag_max - 1; i > lag_min; i--) {
		/* high-pass filtering */
		T0 = ((corr[-i] * 2) - corr[-i - 1]) - corr[-i + 1];
		T0 = (Float32)fabs(T0);

		if (T0 >= max) {
			max = T0;
		}
	}

	/* compute energy */
	p = sig;
	p1 = &sig[0];
	T0 = 0;

	for (i = 0; i < L_frame; i++, p++, p1++) {
		T0 += *p * *p1;
	}
	p = sig;
	p1 = &sig[-1];
	t1 = 0;

	for (i = 0; i < L_frame; i++, p++, p1++) {
		t1 += *p * *p1;
	}

	/* high-pass filtering */
	T0 = T0 - t1;
	T0 = (Float32)fabs(T0);

	/* max/T0 */
	if (T0 != 0) {
		*cor_hp_max = max / T0;
	}
	else {
		*cor_hp_max = 0;
	}
}
#endif

/*
* vad_tone_detection_update
*
*
* Parameters:
*    st->tone          B: flags indicating presence of a tone
*    one_lag_per_frame I: 1 open-loop lag is calculated per each frame
*
* Function:
*    Update the tone flag register.
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void vad_tone_detection_update(vadState *st, Word16 one_lag_per_frame)
{
	/* Shift tone flags right by one bit */
	st->tone = st->tone >> 1;

	/*
	* If open-loop lag is calculated only once in each frame,
	* do extra update and assume that the other tone flag
	* of the frame is one.
	*/
	if (one_lag_per_frame != 0) {
		st->tone = st->tone >> 1;
		st->tone = st->tone | 0x00002000;
	}
}
#endif

/*
* Pitch_ol
*
*
* Parameters:
*    mode           I: AMR mode
*    vadSt          B: VAD state struct
*    signal         I: signal used to compute the open loop pitch
*                                                 [[-pit_max]:[-1]]
*    pit_min        I: minimum pitch lag
*    pit_max        I: maximum pitch lag
*    L_frame        I: length of frame to compute pitch
*    dtx            I: DTX flag
*    idx            I: frame index
*
* Function:
*    Compute the open loop pitch lag.
*
*    Open-loop pitch analysis is performed twice per frame (each 10 ms)
*    to find two estimates of the pitch lag in each frame.
*    Open-loop pitch analysis is performed as follows.
*    In the first step, 3 maxima of the correlation:
*
*          79
*    O(k) = SUM Sw(n)*Sw(n-k)
*          n=0
*
*    are found in the three ranges:
*       pit_min     ...      2*pit_min-1
*       2*pit_min   ...      4*pit_min-1
*       4*pit_min   ...      pit_max
*
*    The retained maxima O(t(i)), i = 1, 2, 3, are normalized by dividing by
*
*    SQRT[SUM[POW(Sw(n-t(i)), 2]], i = 1, 2, 3,
*         n
*
*    respectively.
*    The normalized maxima and corresponding delays are denoted by
*    (M(i), t(i)), i = 1, 2, 3. The winner, Top, among the three normalized
*    correlations is selected by favouring the delays with the values
*    in the lower range. This is performed by weighting the normalized
*    correlations corresponding to the longer delays. The best
*    open-loop delay Top is determined as follows:
*
*    Top = t(1)
*    M(Top) = M(1)
*    if M(2) > 0.85 * M(Top)
*       M(Top) = M(2)
*       Top = t(2)
*    end
*    if M(3) > 0.85 * M(Top)
*       M(Top) = M(3)
*       Top = t(3)
*    end
*
* Returns:
*    void
*/
__device__ static Word32 Pitch_ol(enum Mode mode, vadState *vadSt, Float32 signal[],
	Word32 pit_min, Word32 pit_max, Word16 L_frame, Word32 dtx, Word16 idx)
{
	Float32 corr[PIT_MAX + 1];
	Float32 max1, max2, max3, p_max1, p_max2, p_max3;
	Float32 *corr_ptr;
	Word32 i, j;
#ifdef VAD2
	Float32 r01, r02, r03;
	Float32 rmax1, rmax2, rmax3;
#else
	Float32 corr_hp_max;
#endif


#ifndef VAD2
	if (dtx) {
		/* update tone detection */
		if ((mode == MR475) || (mode == MR515)) {
			vad_tone_detection_update(vadSt, 1);
		}
		else {
			vad_tone_detection_update(vadSt, 0);
		}
	}
#endif

	corr_ptr = &corr[pit_max];

	/*        79             */
	/* O(k) = SUM Sw(n)*Sw(n-k)   */
	/*        n=0               */
	comp_corr(signal, L_frame, pit_max, pit_min, corr_ptr);

#ifdef VAD2
	/* Find a maximum for each section.	*/
	/* Maxima 1	*/
	j = pit_min << 2;
	p_max1 =
		Lag_max(corr_ptr, signal, L_frame, pit_max, j, &max1, dtx, &rmax1, &r01);

	/* Maxima 2	*/
	i = j - 1;
	j = pit_min << 1;
	p_max2 = Lag_max(corr_ptr, signal, L_frame, i, j, &max2, dtx, &rmax2, &r02);

	/* Maxima 3	*/
	i = j - 1;
	p_max3 =
		Lag_max(corr_ptr, signal, L_frame, i, pit_min, &max3, dtx, &rmax3, &r03);
#else
	/* Find a maximum for each section.	*/
	/* Maxima 1	*/
	j = pit_min << 2;
	p_max1 = Lag_max(vadSt, corr_ptr, signal, L_frame, pit_max, j, &max1, dtx);

	/* Maxima 2 */
	i = j - 1;
	j = pit_min << 1;
	p_max2 = Lag_max(vadSt, corr_ptr, signal, L_frame, i, j, &max2, dtx);

	/* Maxima 3 */
	i = j - 1;
	p_max3 = Lag_max(vadSt, corr_ptr, signal, L_frame, i, pit_min, &max3, dtx);

	if (dtx) {
		if (idx == 1) {
			/* calculate max high-passed filtered correlation of all lags */
			hp_max(corr_ptr, signal, L_frame, pit_max, pit_min, &corr_hp_max);

			/* update complex background detector */
			vadSt->best_corr_hp = corr_hp_max * 0.5F;
		}
	}
#endif

	/* The best open-loop delay */
	if ((max1 * 0.85F) < max2) {
		max1 = max2;
		p_max1 = p_max2;
#ifdef VAD2
		if (dtx) {
			rmax1 = rmax2;
			r01 = r02;
		}
#endif
	}

	if ((max1 * 0.85F) < max3) {
		p_max1 = p_max3;
#ifdef VAD2
		if (dtx) {
			rmax1 = rmax3;
			r01 = r03;
		}
#endif
	}
#ifdef VAD2
	if (dtx) {
		vadSt->Rmax += rmax1;   /* Save max correlation */
		vadSt->R0 += r01;     /* Save max energy */
	}
#endif
	return(Word32)p_max1;
}


/*
* Lag_max_wght
*
*
* Parameters:
*    vadSt          B: vad structure
*    corr           I: correlation vector
*    signal         I: signal
*    L_frame        I: length of frame to compute pitch
*    old_lag        I: old open-loop lag
*    cor_max        O: maximum correlation
*    wght_flg       I: weighting function flag
*    gain_flg       O: open-loop flag
*    dtx            I: dtx on/off
*
* Function:
*    Find the lag that has maximum correlation of signal in a given delay range.
*    maximum lag = 143
*    minimum lag = 20
*
* Returns:
*    p_max             lag found
*/
__device__ static Word32 Lag_max_wght(vadState *vadSt, Float32 corr[], Float32 signal[],
	Word32 old_lag, Word32 *cor_max, Word32 wght_flg, Float32 *gain_flg,
	Word32 dtx)
{
	Float32 t0, t1, max;
	Float32 *psignal, *p1signal;
	const Float32 *ww, *we;
	Word32 i, j, p_max;


	ww = &corrweight[250];
	we = &corrweight[266 - old_lag];
	max = -FLT_MAX;
	p_max = PIT_MAX;

	/* see if the neigbouring emphasis is used */
	if (wght_flg > 0) {
		/* find maximum correlation with weighting */
		for (i = PIT_MAX; i >= PIT_MIN; i--) {
			/* Weighting of the correlation function. */
			t0 = corr[-i] * *ww--;
			/* Weight the neighbourhood of the old lag. */
			t0 *= *we--;

			if (t0 >= max) {
				max = t0;
				p_max = i;
			}
		}

	}
	else {
		/* find maximum correlation with weighting */
		for (i = PIT_MAX; i >= PIT_MIN; i--) {
			/* Weighting of the correlation function. */
			t0 = corr[-i] * *ww--;

			if (t0 >= max) {
				max = t0;
				p_max = i;
			}
		}

	}
	psignal = &signal[0];
	p1signal = &signal[-p_max];
	t0 = 0;
	t1 = 0;

	/* Compute energy */
	for (j = 0; j < L_FRAME_BY2; j++, psignal++, p1signal++) {
		t0 += *psignal * *p1signal;
		t1 += *p1signal * *p1signal;
	}

	if (dtx) {
#ifdef VAD2
		vadSt->Rmax += t0;   /* Save max correlation */
		vadSt->R0 += t1;   /* Save max energy */
#else
		/* update and detect tone */
		vad_tone_detection_update(vadSt, 0);
		vad_tone_detection(vadSt, t0, t1);
#endif
	}

	/*
	* gain flag is set according to the open_loop gain
	* is t2/t1 > 0.4 ?
	*/
	*gain_flg = t0 - (t1 * 0.4F);
	*cor_max = 0;
	return(p_max);
}


/*
* gmed_n
*
*
* Parameters:
*    ind               I: values
*    n                 I: The number of gains
*
* Function:
*    Calculates N-point median.
*
* Returns:
*    index of the median value
*/
__device__ static Word32 gmed_n(Word32 ind[], Word32 n)
{
	Word32 i, j, ix = 0;
	Word32 max;
	Word32 medianIndex;
	Word32 tmp[9];
	Word32 tmp2[9];


	for (i = 0; i < n; i++) {
		tmp2[i] = ind[i];
	}

	for (i = 0; i < n; i++) {
		max = -32767;

		for (j = 0; j < n; j++) {
			if (tmp2[j] >= max) {
				max = tmp2[j];
				ix = j;
			}
		}
		tmp2[ix] = -32768;
		tmp[i] = ix;
	}
	medianIndex = tmp[(n >> 1)];
	return(ind[medianIndex]);
}


/*
* Pitch_ol_wgh
*
*
* Parameters:
*    old_T0_med     O: old Cl lags median
*    wght_flg       I: weighting function flag
*    ada_w          B:
*    vadSt          B: VAD state struct
*    signal         I: signal used to compute the open loop pitch
*                                                  [[-pit_max]:[-1]]
*    old_lags       I: history with old stored Cl lags
*    ol_gain_flg    I: OL gain flag
*    idx            I: frame index
*    dtx            I: DTX flag
*
* Function:
*    Open-loop pitch search with weight
*
*    Open-loop pitch analysis is performed twice per frame (every 10 ms)
*    for the 10.2 kbit/s mode to find two estimates of the pitch lag
*    in each frame. The open-loop pitch analysis is done in order to simplify
*    the pitch analysis and confine the closed loop pitch search to
*    a small number of lags around the open-loop estimated lags.
*    Open-loop pitch estimation is based on the weighted speech signal
*    which is obtained by filtering the input speech signal through
*    the weighting filter.
*    The correlation of weighted speech is determined.
*    The estimated pitch-lag is the delay that maximises
*    the weighted autocorrelation function. To enhance  pitch-lag analysis
*    the autocorrelation function estimate is modified by a weighting window.
*    The weighting emphasises relevant pitch-lags, thus increasing
*    the likelihood of selecting the correct delay.
*    minimum pitch lag = 20
*    maximum pitch lag = 143
*
* Returns:
*    p_max1            open loop pitch lag
*/
__device__ static Word32 Pitch_ol_wgh(Word32 *old_T0_med, Word16 *wght_flg, Float32 *ada_w,
	vadState *vadSt, Float32 signal[], Word32 old_lags[], Float32 ol_gain_flg[],
	Word16 idx, Word32 dtx)
{
	Float32 corr[PIT_MAX + 1];
#ifndef VAD2
	Float32 corr_hp_max;
#endif
	Float32 *corrPtr;
	Word32 i, max1, p_max1;


	/* calculate all coreelations of signal, from pit_min to pit_max */
	corrPtr = &corr[PIT_MAX];
	comp_corr(signal, L_FRAME_BY2, PIT_MAX, PIT_MIN, corrPtr);
	p_max1 = Lag_max_wght(vadSt, corrPtr, signal, *old_T0_med,
		&max1, *wght_flg, &ol_gain_flg[idx], dtx);

	if (ol_gain_flg[idx] > 0) {
		/* Calculate 5-point median of previous lags */
		/* Shift buffer */
		for (i = 4; i > 0; i--) {
			old_lags[i] = old_lags[i - 1];
		}
		old_lags[0] = p_max1;
		*old_T0_med = gmed_n(old_lags, 5);
		*ada_w = 1;
	}
	else {
		*old_T0_med = p_max1;
		*ada_w = *ada_w * 0.9F;
	}

	if (*ada_w < 0.3) {
		*wght_flg = 0;
	}
	else {
		*wght_flg = 1;
	}

#ifndef VAD2
	if (dtx) {
		if (idx == 1) {
			/* calculate max high-passed filtered correlation of all lags */
			hp_max(corrPtr, signal, L_FRAME_BY2, PIT_MAX, PIT_MIN, &corr_hp_max);

			/* update complex background detector */
			vadSt->best_corr_hp = corr_hp_max * 0.5F;
		}
	}
#endif
	return(p_max1);
}


/*
* ol_ltp
*
*
* Parameters:
*    mode              I: AMR mode
*    vadSt             B: VAD state struct
*    wsp               I: signal used to compute the OL pitch
*    T_op              O: open loop pitch lag
*    ol_gain_flg       I: OL gain flag
*    old_T0_med        O: old Cl lags median
*    wght_flg          I: weighting function flag
*    ada_w             B:
*    old_lags          I: history with old stored Cl lags
*    ol_gain_flg       I: OL gain flag
*    dtx               I: DTX flag
*    idx               I: frame index
*
* Function:
*    Compute the open loop pitch lag.
*
*    Open-loop pitch analysis is performed in order to simplify
*    the pitch analysis and confine the closed-loop pitch search to
*    a small number of lags around the open-loop estimated lags.
*    Open-loop pitch estimation is based on the weighted speech signal Sw(n)
*    which is obtained by filtering the input speech signal through
*    the weighting filter W(z) = A(z/g1) / A(z/g2). That is,
*    in a subframe of size L, the weighted speech is given by:
*
*                10
*    Sw(n) = S(n) + SUM[ a(i) * g1(i) * S(n-i) ]
*                i=1
*                   10
*                - SUM[ a(i) * g2(i) * Sw(n-i) ], n = 0, ..., L-1
*                  i=1
*
* Returns:
*    void
*/
__device__ static void ol_ltp(enum Mode mode, vadState *vadSt, Float32 wsp[], Word32 *T_op
	, Float32 ol_gain_flg[], Word32 *old_T0_med, Word16 *wght_flg, Float32 *ada_w
	, Word32 *old_lags, Word32 dtx, Word16 idx)
{
	if (mode != MR102) {
		ol_gain_flg[0] = 0;
		ol_gain_flg[1] = 0;
	}

	if ((mode == MR475) || (mode == MR515)) {
		*T_op = Pitch_ol(mode, vadSt, wsp, PIT_MIN, PIT_MAX, L_FRAME, dtx, idx);
	}
	else {
		if (mode <= MR795) {
			*T_op = Pitch_ol(mode, vadSt, wsp, PIT_MIN, PIT_MAX, L_FRAME_BY2, dtx,
				idx);
		}
		else if (mode == MR102) {
			*T_op = Pitch_ol_wgh(old_T0_med, wght_flg, ada_w, vadSt, wsp, old_lags,
				ol_gain_flg, idx, dtx);
		}
		else {
			*T_op = Pitch_ol(mode, vadSt, wsp, PIT_MIN_MR122, PIT_MAX, L_FRAME_BY2
				, dtx, idx);
		}
	}
}


/*
* subframePreProc
*
*
* Parameters:
*    mode           I: AMR mode
*    gamma1         I: spectral exp. factor 1
*    gamma1_12k2    I: spectral exp. factor 1 for EFR
*    gamma2         I: spectral exp. factor 2
*    A              I: A(z) unquantized for the 4 subframes
*    Aq             I: A(z)   quantized for the 4 subframes
*    speech         I: speech segment
*    mem_err        I: pointer to error signal
*    mem_w0         I: memory of weighting filter
*    zero           I: pointer to zero vector
*    ai_zero        O: history of weighted synth. filter
*    exc            O: long term prediction residual
*    h1             O: impulse response
*    xn             O: target vector for pitch search
*    res2           O: long term prediction residual
*    error          O: error of LPC synthesis filter
*
* Function:
*    Subframe preprocessing
*
*    Impulse response computation:
*       The impulse response, h(n), of the weighted synthesis filter
*
*       H(z) * W(z) = A(z/g1) / ( A'(z) * A(z/g2) )
*
*       is computed each subframe. This impulse response is needed for
*       the search of adaptive and fixed codebooks. The impulse response h(n)
*       is computed by filtering the vector of coefficients of
*       the filter A(z/g1) extended by zeros through the two filters
*       1/A'(z) and 1/A(z/g2).
*
*    Target signal computation:
*       The target signal for adaptive codebook search is usually computed
*       by subtracting the zero input response of
*       the weighted synthesis filter H(z) * W(z) from the weighted
*       speech signal Sw(n). This is performed on a subframe basis.
*       An equivalent procedure for computing the target signal is
*       the filtering of the LP residual signal res(n) through
*       the combination of synthesis filter 1/A'(z) and
*       the weighting filter A(z/g1)/A(z/g2). After determining
*       the excitation for the subframe, the initial states of
*       these filters are updated by filtering the difference between
*       the LP residual and excitation.
*
*       The residual signal res(n) which is needed for finding
*       the target vector is also used in the adaptive codebook search
*       to extend the past excitation buffer. This simplifies
*       the adaptive codebook search procedure for delays less than
*       the subframe size of 40. The LP residual is given by:
*
*                        10
*       res(n) = S(n) + SUM[A'(i)* S(n-i)
*                       i=1
*
* Returns:
*    void
*/
__device__ static void subframePreProc(enum Mode mode, const Float32 gamma1[], const
	Float32 gamma1_12k2[], const Float32 gamma2[], Float32 *A, Float32 *Aq,
	Float32 *speech, Float32 *mem_err, Float32 *mem_w0, Float32 *zero, Float32
	ai_zero[], Float32 *exc, Float32 h1[], Float32 xn[], Float32 res2[],
	Float32 error[])
{
	Float32 Ap1[MP1];   /* weighted LPC coefficients */
	Float32 Ap2[MP1];   /* weighted LPC coefficients */
	const Float32 *g1;


	/* mode specific pointer to gamma1 values */
	g1 = gamma1;

	if ((mode == MR122) || (mode == MR102)) {
		g1 = gamma1_12k2;
	}

	/* Find the weighted LPC coefficients for the weighting filter. */
	Weight_Ai(A, g1, Ap1);
	Weight_Ai(A, gamma2, Ap2);

	/*
	* Compute impulse response, h1[],
	* of weighted synthesis filter A(z/g1)/A(z/g2)
	*/
	memcpy(ai_zero, Ap1, MP1 << 2);
	Syn_filt(Aq, ai_zero, h1, zero, 0);
	Syn_filt(Ap2, h1, h1, zero, 0);

	/*
	* Find the target vector for pitch search:
	*/
	/* LP residual */
	Residu(Aq, speech, res2);
	memcpy(exc, res2, L_SUBFR << 2);

	/* Synthesis filter */
	Syn_filt(Aq, exc, error, mem_err, 0);
	Residu(Ap1, error, xn);

	/* target signal xn[] */
	Syn_filt(Ap2, xn, xn, mem_w0, 0);
}


/*
* getRange
*
*
* Parameters:
*    T0                I: integer pitch
*    delta_low         I: search start offset
*    delta_range       I: search range
*    pitmin            I: minimum pitch
*    pitmax            I: maximum pitch
*    T0_min            I: search range minimum
*    T0_max            I: search range maximum
*
* Function:
*    Sets range around open-loop pitch or integer pitch of last subframe
*
*    Takes integer pitch T0 and calculates a range around it with
*    T0_min = T0-delta_low and T0_max = (T0-delta_low) + delta_range
*    T0_min and T0_max are bounded by pitmin and pitmax
*
* Returns:
*    void
*/
__device__ static void getRange(Word32 T0, Word16 delta_low, Word16 delta_range,
	Word16 pitmin, Word16 pitmax, Word32 *T0_min, Word32 *T0_max)
{
	*T0_min = T0 - delta_low;

	if (*T0_min < pitmin) {
		*T0_min = pitmin;
	}
	*T0_max = *T0_min + delta_range;

	if (*T0_max > pitmax) {
		*T0_max = pitmax;
		*T0_min = *T0_max - delta_range;
	}
}


/*
* Norm_Corr
*
*
* Parameters:
*    exc         I: excitation buffer                      [L_SUBFR]
*    xn          I: target vector                          [L_SUBFR]
*    h           I: impulse response of synthesis and weighting filters
*                                                          [L_SUBFR]
*    t_min       I: interval to compute normalized correlation
*    t_max       I: interval to compute normalized correlation
*    corr_norm   O: Normalized correlation                 [wT_min-wT_max]
*
* Function:
*    Normalized correlation
*
*    The closed-loop pitch search is performed by minimizing
*    the mean-square weighted error between the original and
*    synthesized speech. This is achieved by maximizing the term:
*
*            39                           39
*    R(k) = SUM[ X(n) * Yk(n)) ] / SQRT[ SUM[ Yk(n) * Yk(n)] ]
*           n=0                          n=0
*
*    where X(n) is the target signal and Yk(n) is the past filtered
*    excitation at delay k (past excitation convolved with h(n) ).
*    The search range is limited around the open-loop pitch.
*
*    The convolution Yk(n) is computed for the first delay t_min in
*    the searched range, and for the other delays in the search range
*    k = t_min + 1, ..., t_max, it is updated using the recursive relation:
*
*    Yk(n) = Yk-1(n-1) + u(-k) * h(n),
*
*    where u(n), n = -( 143 + 11 ), ..., 39, is the excitation buffer.
*    Note that in search stage, the samples u(n), n = 0, ..., 39,
*    are not known, and they are needed for pitch delays less than 40.
*    To simplify the search, the LP residual is copied to u(n) in order
*    to make the relation in above equation valid for all delays.
*
* Returns:
*    void
*/
__device__ static void Norm_Corr(Float32 exc[], Float32 xn[], Float32 h[], Word32 t_min,
	Word32 t_max, Float32 corr_norm[])
{
	Float32 exc_temp[L_SUBFR];
	Float32 *p_exc;
	Float32 corr, norm;
	Float32 sum;
	Word32 i, j, k;


	k = -t_min;
	p_exc = &exc[-t_min];

	/* compute the filtered excitation for the first delay t_min */
	/* convolution Yk(n) */
	for (j = 0; j < L_SUBFR; j++) {
		sum = 0;

		for (i = 0; i <= j; i++) {
			sum += p_exc[i] * h[j - i];
		}
		exc_temp[j] = sum;
	}

	/* loop for every possible period */
	for (i = t_min; i <= t_max; i++) {
		/*        39                     */
		/* SQRT[ SUM[ Yk(n) * Yk(n)] ]   */
		/*       n=0                     */
		norm = (Float32)Dotproduct40(exc_temp, exc_temp);

		if (norm == 0)
			norm = 1.0;
		else
			norm = (Float32)(1.0 / (sqrt(norm)));

		/*        39                  */
		/* SQRT[ SUM[ X(n) * Yk(n)] ] */
		/*       n=0                  */
		corr = (Float32)Dotproduct40(xn, exc_temp);

		/* R(k) */
		corr_norm[i] = corr * norm;

		/* modify the filtered excitation exc_tmp[] for the next iteration */
		if (i != t_max) {
			k--;

			for (j = L_SUBFR - 1; j > 0; j--) {
				/* Yk(n) = Yk-1(n-1) + u(-k) * h(n) */
				exc_temp[j] = exc_temp[j - 1] + exc[k] * h[j];
			}
			exc_temp[0] = exc[k];
		}
	}
}


/*
* Interpol_3or6
*
*
* Parameters:
*    x                 I: input vector
*    frac              I: fraction  (-2..2 for 3*, -3..3 for 6*)
*    flag3             I: if set, upsampling rate = 3 (6 otherwise)
*
* Function:
*    Interpolating the normalized correlation with 1/3 or 1/6 resolution.
*
*    The interpolation is performed using an FIR filter b24
*    based on a Hamming windowed sin(x)/x function truncated at \A1\C023
*    and padded with zeros at \A1\C024 (b24(24) = 0). The filter has its
*    cut-off frequency (-3 dB) at 3 600 Hz in the over-sampled domain.
*    The interpolated values of R(k) for the fractions -3/6 to 3/6
*    are obtained using the interpolation formula:
*
*              3                            3
*    R(k)t = SUM[ R(k-i) * b24(t+i*6) ] + SUM [ R(k+1+i) * b24(6-t+i*6) ],
*            i=0                          i=0
*    t = 0, ..., 5,
*
*    where t = 0, ..., 5, corresponds to the fractions
*    0, 1/6, 2/6, 3/6, -2/6, and -1/6, respectively. Note that it is
*    necessary to compute the correlation terms using a range t_min - 4,
*    t_max + 4, to allow for the proper interpolation.
*
* Returns:
*    s                 interpolated value
*/
__device__ static Float32 Interpol_3or6(Float32 *x, Word32 frac, Word16 flag3)
{
	Float32 s;
	Float32 *x1, *x2;
	const Float32 *c1, *c2;
	Word32 i, k;


	if (flag3 != 0) {
		/* inter_3[k] = b60[2*k] -> k' = 2*k */
		frac <<= 1;
	}

	if (frac < 0) {
		frac += UP_SAMP_MAX;
		x--;
	}
	x1 = &x[0];
	x2 = &x[1];
	c1 = &b24[frac];
	c2 = &b24[UP_SAMP_MAX - frac];
	s = 0;

	for (i = 0, k = 0; i < L_INTER_SRCH; i++, k += UP_SAMP_MAX) {
		/* R(k-i) * b24(t+i*6) */
		s += x1[-i] * c1[k];

		/* R(k+1+i) * b24(6-t+i*6) */
		s += x2[i] * c2[k];
	}
	return s;
}


/*
* searchFrac
*
*
* Parameters:
*    lag               B: integer pitch
*    frac              B: start point of search - fractional pitch
*    last_frac         I: endpoint of search
*    corr              I: normalized correlation
*    flag3             I: if set, upsampling rate = 3 (6 otherwise)
*
* Function:
*    Find fractional pitch
*
*    The function interpolates the normalized correlation at the
*    fractional positions around lag T0. The position at which the
*    interpolation function reaches its maximum is the fractional pitch.
*    Starting point of the search is frac, end point is last_frac.
*    frac is overwritten with the fractional pitch.
*
* Returns:
*    void
*/
__device__ static void searchFrac(Word32 *lag, Word32 *frac, Word16 last_frac, Float32
	corr[], Word16 flag3)
{
	Float32 max, corr_int;
	Word32 i;


	/*
	* Test the fractions around T0 and choose the one which maximizes
	* the interpolated normalized correlation.
	*/
	max = Interpol_3or6(&corr[*lag], *frac, flag3);

	for (i = *frac + 1; i <= last_frac; i++) {
		corr_int = Interpol_3or6(&corr[*lag], i, flag3);

		if (corr_int > max) {
			max = corr_int;
			*frac = i;
		}
	}

	if (flag3 == 0) {
		/* Limit the fraction value in the interval [-2,-1,0,1,2,3] */
		if (*frac == -3) {
			*frac = 3;
			*lag -= 1;
		}
	}
	else {
		/* limit the fraction value between -1 and 1 */
		if (*frac == -2) {
			*frac = 1;
			*lag -= 1;
		}

		if (*frac == 2) {
			*frac = -1;
			*lag += 1;
		}
	}
}


/*
* Enc_lag3
*
*
* Parameters:
*    T0             I: Pitch delay
*    T0_frac        I: Fractional pitch delay
*    T0_prev        I: Integer pitch delay of last subframe
*    T0_min         I: minimum of search range
*    T0_max         I: maximum of search range
*    delta_flag     I: Flag for 1st (or 3rd) subframe
*    flag4          I: Flag for encoding with 4 bits
*
* Function:
*    Encoding of fractional pitch lag with 1/3 resolution.
*
* Returns:
*    index             index of encoding
*/
__device__ static Word32 Enc_lag3(Word32 T0, Word32 T0_frac, Word32 T0_prev, Word32 T0_min
	, Word32 T0_max, Word16 delta_flag, Word16 flag4)
{
	Word32 index, i, tmp_ind, uplag, tmp_lag;


	/* if 1st or 3rd subframe */
	if (delta_flag == 0) {
		/* encode pitch delay (with fraction) */
		if (T0 <= 85) {
			index = T0 * 3 - 58 + T0_frac;
		}
		else {
			index = T0 + 112;
		}
	}

	/* if second or fourth subframe */
	else {
		if (flag4 == 0) {
			/* 'normal' encoding: either with 5 or 6 bit resolution */
			index = 3 * (T0 - T0_min) + 2 + T0_frac;
		}
		else {
			/* encoding with 4 bit resolution */
			tmp_lag = T0_prev;

			if ((tmp_lag - T0_min) > 5)
				tmp_lag = T0_min + 5;

			if ((T0_max - tmp_lag) > 4)
				tmp_lag = T0_max - 4;
			uplag = T0 + T0 + T0 + T0_frac;
			i = tmp_lag - 2;
			tmp_ind = i + i + i;

			if (tmp_ind >= uplag) {
				index = (T0 - tmp_lag) + 5;
			}
			else {
				i = tmp_lag + 1;
				i = i + i + i;

				if (i > uplag) {
					index = (uplag - tmp_ind) + 3;
				}
				else {
					index = (T0 - tmp_lag) + 11;
				}
			}
		}   /* end if (encoding with 4 bit resolution) */
	}   /* end if (second of fourth subframe) */
	return index;
}


/*
* Enc_lag6
*
*
* Parameters:
*    T0             I: Pitch delay
*    T0_frac        I: Fractional pitch delay
*    T0_min         I: minimum of search range
*    delta_flag     I: Flag for 1st (or 3rd) subframe
*
* Function:
*    Encoding of fractional pitch lag with 1/6 resolution.
*
*    First and third subframes:
*       The pitch range is divided as follows:
*          17 3/6  to   94 3/6   resolution 1/6
*          95      to   143      resolution 1
*       The period is encoded with 9 bits.
*       For the range with fractions:
*          index = (T-17)*6 + frac - 3;
*          where T=[17..94] and frac=[-2,-1,0,1,2,3]
*       and for the integer only range
*          index = (T - 95) + 463;
*          where T=[95..143]
*    Second and fourth subframes:
*       For the 2nd and 4th subframes a resolution of 1/6 is always used,
*       and the search range is relative to the lag in previous subframe.
*       If T0 is the lag in the previous subframe then
*       t_min=T0-5   and  t_max=T0+4   and  the range is given by
*       (t_min-1) 3/6   to  (t_max) 3/6
*       The period in the 2nd (and 4th) subframe is encoded with 6 bits:
*          index = (T-(t_min-1))*6 + frac - 3;
*          where T=[t_min-1..t_max] and frac=[-2,-1,0,1,2,3]
*    Note that only 61 values are used. If the decoder receives 61, 62,
*    or 63 as the relative pitch index, it means that a transmission
*    error occurred and the pitch from previous subframe should be used.
*
* Returns:
*    index             index of encoding
*/
__device__ static Word32 Enc_lag6(Word32 T0, Word32 T0_frac, Word32 T0_min, Word16
	delta_flag)
{
	Word32 index;


	/* if 1st or 3rd subframe */
	if (delta_flag == 0) {
		/* encode pitch delay (with fraction) */
		if (T0 <= 94) {
			/* index = (t-17)*6 + frac - 3 */
			index = T0 * 6 - 105 + T0_frac;
		}
		else {
			/* index = (t - 95) + 463 */
			index = T0 + 368;
		}
	}

	/* if second or fourth subframe */
	else {
		/* index = (t-(t_min-1))*6 + frac - 3 */
		index = 6 * (T0 - T0_min) + 3 + T0_frac;
	}
	return index;
}


/*
* Pitch_fr
*
*
* Parameters:
*    T0_prev_subframe  B: integer pitch lag of previous sub-frame
*    mode              I: codec mode
*    T_op              I: open-loop pitch estimations for
*                         the 2 big subframes [2]
*    exc               I: excitation buffer
*    xn                I: target vector
*    h                 I: impulse response of synthesis
*                         and weighting filters
*    i_subfr           I: subframe number
*    pit_frac          O: pitch period (fractional)
*    resu3             O: subsample resolution 1/3 (=1) or 1/6 (=0)
*    ana_index         O: index of encoding
*
* Function:
*    Closed-loop pitch search
*
*    In the first and third subframes, a fractional pitch delay is used
*    with resolutions: 1/6 in the range [17 3/6, 94 3/6] and integers only
*    in the range [95, 143]. For the second and fourth subframes,
*    a pitch resolution of 1/6 is always used in
*    the range [T1 - 5 3/6, T1 + 4 /3/6], where T1 is nearest integer to
*    the fractional pitch lag of the previous (1st or 3rd) subframe,
*    bounded by 18...143.
*
*    Closed-loop pitch analysis is performed around
*    the open-loop pitch estimates on a subframe basis.
*    In the first (and third) subframe the range Top\A1\C03,
*    bounded by 18...143, is searched. For the other subframes,
*    closed-loop pitch analysis is performed around the integer pitch
*    selected in the previous subframe, as described above.
*    The pitch delay is encoded with 9 bits in the first and
*    third subframes and the relative delay of the other subframes
*    is encoded with 6 bits.
*
*    The closed-loop pitch search is performed by minimizing
*    the mean-square weighted error between the original and
*    synthesized speech. This is achieved by maximizing the term:
*
*            39                           39
*    R(k) = SUM[ X(n) * Yk(n)) ] / SQRT[ SUM[ Yk(n) * Yk(n)] ]
*           n=0                          n=0
*
*    where X(n) is the target signal and Yk(n) is the past filtered
*    excitation at delay k (past excitation convolved with h(n) ).
*
*    Once the optimum integer pitch delay is determined, the fractions
*    from -3/6 to 3/6 with a step of 1/6 around that integer are tested.
*    The fractional pitch search is performed by interpolating
*    the normalized correlation R(k) and searching for its maximum.
*    The interpolation is performed using an FIR filter b24
*    based on a Hamming windowed sin(x)/x function truncated at \A1\C023
*    and padded with zeros at \A1\C024 (b24(24) = 0). The filter has its
*    cut-off frequency (-3 dB) at 3 600 Hz in the over-sampled domain.
*    The interpolated values of R(k) for the fractions -3/6 to 3/6
*    are obtained using the interpolation formula:
*
*              3                            3
*    R(k)t = SUM[ R(k-i) * b24(t+i*6) ] + SUM [ R(k+1+i) * b24(6-t+i*6) ],
*            i=0                          i=0
*    t = 0, ..., 5,
*
*    where t = 0, ..., 5, corresponds to the fractions
*    0, 1/6, 2/6, 3/6, -2/6, and -1/6, respectively. Note that it is
*    necessary to compute the correlation terms using a range t_min -4,
*    t_max + 4, to allow for the proper interpolation.
*
* Returns:
*    lag             closed-loop pitch lag
*/
__device__ static Word32 Pitch_fr(Word32 *T0_prev_subframe, enum Mode mode, Word32 T_op[],
	Float32 exc[], Float32 xn[], Float32 h[], Word16 i_subfr, Word32 *pit_frac
	, Word16 *resu3, Word32 *ana_index)
{
	Float32 corr_v[40];
	Float32 max;
	Float32 *corr;
	Word32 i, t_min, t_max, T0_min, T0_max;
	Word32 lag, frac, tmp_lag;
	Word16 max_frac_lag, flag3, flag4, last_frac;
	Word16 delta_int_low, delta_int_range, delta_frc_low, delta_frc_range;
	Word16 pit_min;
	Word16 frame_offset;
	Word16 delta_search;


	/* set mode specific variables */
	max_frac_lag = mode_dep_parm[mode].max_frac_lag;
	flag3 = mode_dep_parm[mode].flag3;
	frac = mode_dep_parm[mode].first_frac;
	last_frac = mode_dep_parm[mode].last_frac;
	delta_int_low = mode_dep_parm[mode].delta_int_low;
	delta_int_range = mode_dep_parm[mode].delta_int_range;
	delta_frc_low = mode_dep_parm[mode].delta_frc_low;
	delta_frc_range = mode_dep_parm[mode].delta_frc_range;
	pit_min = mode_dep_parm[mode].pit_min;

	/* decide upon full or differential search */
	delta_search = 1;

	if ((i_subfr == 0) || (i_subfr == L_FRAME_BY2)) {
		/* Subframe 1 and 3 */
		if (((mode != MR475) && (mode != MR515)) || (i_subfr !=
			L_FRAME_BY2)) {
			/*
			* set T0_min, T0_max for full search
			* this is *not* done for mode MR475, MR515 in subframe 3
			*/
			delta_search = 0;   /* no differential search */

								/*
								* calculate index into T_op which contains the open-loop
								* pitch estimations for the 2 big subframes
								*/
			frame_offset = 1;

			if (i_subfr == 0)
				frame_offset = 0;

			/*
			* get T_op from the corresponding half frame and
			* set T0_min, T0_max
			*/
			getRange(T_op[frame_offset], delta_int_low, delta_int_range, pit_min,
				PIT_MAX, &T0_min, &T0_max);
		}
		else {
			/* mode MR475, MR515 and 3. Subframe: delta search as well */
			getRange(*T0_prev_subframe, delta_frc_low, delta_frc_range, pit_min,
				PIT_MAX, &T0_min, &T0_max);
		}
	}
	else {
		/*
		* for Subframe 2 and 4
		* get range around T0 of previous subframe for delta search
		*/
		getRange(*T0_prev_subframe, delta_frc_low, delta_frc_range, pit_min,
			PIT_MAX, &T0_min, &T0_max);
	}

	/* Find interval to compute normalized correlation */
	t_min = T0_min - L_INTER_SRCH;
	t_max = T0_max + L_INTER_SRCH;
	corr = &corr_v[-t_min];

	/* Compute normalized correlation between target and filtered excitation */
	Norm_Corr(exc, xn, h, t_min, t_max, corr);

	/* Find integer pitch */
	max = corr[T0_min];
	lag = T0_min;

	for (i = T0_min + 1; i <= T0_max; i++) {
		if (corr[i] >= max) {
			max = corr[i];
			lag = i;
		}
	}

	/* Find fractional pitch   */
	if ((delta_search == 0) && (lag > max_frac_lag)) {
		/*
		* full search and integer pitch greater than max_frac_lag
		* fractional search is not needed, set fractional to zero
		*/
		frac = 0;
	}
	else {
		/*
		* if differential search AND mode MR475 OR MR515 OR MR59 OR MR67
		* then search fractional with 4 bits resolution
		*/
		if ((delta_search != 0) && ((mode == MR475) || (mode == MR515) ||
			(mode == MR59) || (mode == MR67))) {
			/*
			* modify frac or last_frac according to position of last
			* integer pitch: either search around integer pitch,
			* or only on left or right side
			*/
			tmp_lag = *T0_prev_subframe;

			if ((tmp_lag - T0_min) > 5)
				tmp_lag = T0_min + 5;

			if ((T0_max - tmp_lag) > 4)
				tmp_lag = T0_max - 4;

			if ((lag == tmp_lag) || (lag == (tmp_lag - 1))) {
				/* normal search in fractions around T0 */
				searchFrac(&lag, &frac, last_frac, corr, flag3);
			}
			else if (lag == (tmp_lag - 2)) {
				/* limit search around T0 to the right side */
				frac = 0;
				searchFrac(&lag, &frac, last_frac, corr, flag3);
			}
			else if (lag == (tmp_lag + 1)) {
				/* limit search around T0 to the left side */
				last_frac = 0;
				searchFrac(&lag, &frac, last_frac, corr, flag3);
			}
			else {
				/* no fractional search */
				frac = 0;
			}
		}
		else

			/* test the fractions around T0 */
			searchFrac(&lag, &frac, last_frac, corr, flag3);
	}

	/*
	*  encode pitch
	*/
	if (flag3 != 0) {
		/*
		* flag4 indicates encoding with 4 bit resolution;
		* this is needed for mode MR475, MR515 and MR59
		*/
		flag4 = 0;

		if ((mode == MR475) || (mode == MR515) || (mode == MR59) || (mode
			== MR67)) {
			flag4 = 1;
		}

		/* encode with 1/3 subsample resolution */
		*ana_index = Enc_lag3(lag, frac, *T0_prev_subframe, T0_min, T0_max,
			delta_search, flag4);
	}
	else {
		/* encode with 1/6 subsample resolution */
		*ana_index = Enc_lag6(lag, frac, T0_min, delta_search);
	}

	/*
	*  update state variables
	*/
	*T0_prev_subframe = lag;

	/*
	* update output variables
	*/
	*resu3 = flag3;
	*pit_frac = frac;
	return(lag);
}


/*
* Pred_lt_3or6
*
*
* Parameters:
*    exc      B: excitation buffer
*    T0       I: integer pitch lag
*    frac     I: fraction of lag
*    flag3    I: if set, upsampling rate = 3 (6 otherwise)
*
* Function:
*    Compute the result of long term prediction with fractional
*    interpolation of resolution 1/3 or 1/6. (Interpolated past excitation).
*
*    Once the fractional pitch lag is determined,
*    the adaptive codebook vector v(n) is computed by interpolating
*    the past excitation signal u(n) at the given integer delay k
*    and phase (fraction)  :
*
*            9                              9
*    v(n) = SUM[ u(n-k-i) * b60(t+i*6) ] + SUM[ u(n-k+1+i) * b60(6-t+i*6) ],
*           i=0                            i=0
*    n = 0, ...,39, t = 0, ...,5.
*
*    The interpolation filter b60 is based on a Hamming windowed sin(x)/x
*    function truncated at \A1\C0 59 and padded with zeros at \A1\C0 60 (b60(60)=0)).
*    The filter has a cut-off frequency (-3 dB) at 3 600 Hz in
*    the over-sampled domain.
*
* Returns:
*    void
*/
__device__ static void Pred_lt_3or6(Float32 exc[], Word32 T0, Word32 frac, Word16 flag3)
{
	Float32 s;
	Float32 *x0, *x1, *x2;
	const Float32 *c1, *c2;
	Word32 j;


	x0 = &exc[-T0];
	frac = -frac;

	if (flag3 != 0) {
		/* inter_3l[k] = b60[2*k] -> k' = 2*k */
		frac <<= 1;
	}

	if (frac < 0) {
		frac += UP_SAMP_MAX;
		x0--;
	}
	c1 = &b60[frac];
	c2 = &b60[UP_SAMP_MAX - frac];

	for (j = 0; j < L_SUBFR; j += 4) {
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0] + x2[0] * c2[0];
		s += x1[-1] * c1[6] + x2[1] * c2[6];
		s += x1[-2] * c1[12] + x2[2] * c2[12];
		s += x1[-3] * c1[18] + x2[3] * c2[18];
		s += x1[-4] * c1[24] + x2[4] * c2[24];
		s += x1[-5] * c1[30] + x2[5] * c2[30];
		s += x1[-6] * c1[36] + x2[6] * c2[36];
		s += x1[-7] * c1[42] + x2[7] * c2[42];
		s += x1[-8] * c1[48] + x2[8] * c2[48];
		s += x1[-9] * c1[54] + x2[9] * c2[54];
		exc[j] = (Float32)floor(s + 0.5F);
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0] + x2[0] * c2[0];
		s += x1[-1] * c1[6] + x2[1] * c2[6];
		s += x1[-2] * c1[12] + x2[2] * c2[12];
		s += x1[-3] * c1[18] + x2[3] * c2[18];
		s += x1[-4] * c1[24] + x2[4] * c2[24];
		s += x1[-5] * c1[30] + x2[5] * c2[30];
		s += x1[-6] * c1[36] + x2[6] * c2[36];
		s += x1[-7] * c1[42] + x2[7] * c2[42];
		s += x1[-8] * c1[48] + x2[8] * c2[48];
		s += x1[-9] * c1[54] + x2[9] * c2[54];
		exc[j + 1] = (Float32)floor(s + 0.5F);
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0] + x2[0] * c2[0];
		s += x1[-1] * c1[6] + x2[1] * c2[6];
		s += x1[-2] * c1[12] + x2[2] * c2[12];
		s += x1[-3] * c1[18] + x2[3] * c2[18];
		s += x1[-4] * c1[24] + x2[4] * c2[24];
		s += x1[-5] * c1[30] + x2[5] * c2[30];
		s += x1[-6] * c1[36] + x2[6] * c2[36];
		s += x1[-7] * c1[42] + x2[7] * c2[42];
		s += x1[-8] * c1[48] + x2[8] * c2[48];
		s += x1[-9] * c1[54] + x2[9] * c2[54];
		exc[j + 2] = (Float32)floor(s + 0.5F);
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0] + x2[0] * c2[0];
		s += x1[-1] * c1[6] + x2[1] * c2[6];
		s += x1[-2] * c1[12] + x2[2] * c2[12];
		s += x1[-3] * c1[18] + x2[3] * c2[18];
		s += x1[-4] * c1[24] + x2[4] * c2[24];
		s += x1[-5] * c1[30] + x2[5] * c2[30];
		s += x1[-6] * c1[36] + x2[6] * c2[36];
		s += x1[-7] * c1[42] + x2[7] * c2[42];
		s += x1[-8] * c1[48] + x2[8] * c2[48];
		s += x1[-9] * c1[54] + x2[9] * c2[54];
		exc[j + 3] = (Float32)floor(s + 0.5F);
	}
	return;
}

__device__ static void Pred_lt_3or6_fixed(Word32 exc[], Word32 T0, Word32 frac, Word32 flag3)
{
	Word32 s, i;
	Word32 *x0, *x1, *x2;
	const Word32 *c1, *c2;

	x0 = &exc[-T0];
	frac = -frac;

	if (flag3 != 0) {
		frac <<= 1;   /* inter_3l[k] = inter6[2*k] -> k' = 2*k */
	}

	if (frac < 0) {
		frac += 6;
		x0--;
	}
	c1 = &inter6[frac];
	c2 = &inter6[6 - frac];

	for (i = 0; i < 40; i++) {
		x1 = x0++;
		x2 = x0;
		s = x1[0] * c1[0];
		s += x1[-1] * c1[6];
		s += x1[-2] * c1[12];
		s += x1[-3] * c1[18];
		s += x1[-4] * c1[24];
		s += x1[-5] * c1[30];
		s += x1[-6] * c1[36];
		s += x1[-7] * c1[42];
		s += x1[-8] * c1[48];
		s += x1[-9] * c1[54];
		s += x2[0] * c2[0];
		s += x2[1] * c2[6];
		s += x2[2] * c2[12];
		s += x2[3] * c2[18];
		s += x2[4] * c2[24];
		s += x2[5] * c2[30];
		s += x2[6] * c2[36];
		s += x2[7] * c2[42];
		s += x2[8] * c2[48];
		s += x2[9] * c2[54];
		exc[i] = (s + 0x4000) >> 15;

	}
}


/*
* G_pitch
*
*
* Parameters:
*    xn       I: Pitch target
*    y1       I: Filtered adaptive codebook
*    gCoeff   O: Correlations need for gain quantization
*
* Function:
*    Compute the pitch (adaptive codebook) gain.
*
*    The adaptive codebook gain is given by
*
*       g = <x[], y[]> / <y[], y[]>
*
*    where x[] is the target vector, y[] is the filtered adaptive
*    codevector, and <> denotes dot product.
*
* Returns:
*    gain              gain saturated to 1.2
*/
__device__ static Float32 G_pitch(Float32 xn[], Float32 y1[], Float32 gCoeff[])
{
	Float32 gain, sum;


	/* Compute scalar product <y1[],y1[]> */
	sum = (Float32)Dotproduct40(y1, y1);

	/* Avoid case of all zeros */
	sum += 0.01F;
	gCoeff[0] = sum;

	/* Compute scalar product <xn[],y1[]> */
	sum = (Float32)Dotproduct40(xn, y1);
	gCoeff[1] = sum;

	/* compute gain = xy/yy */
	gain = (Float32)(gCoeff[1] / gCoeff[0]);

	/* if(gain >1.2) gain = 1.2 */
	if (gain < 0.0)
		gain = 0.0F;

	if (gain > 1.2)
		gain = 1.2F;
	return(gain);
}


/*
* check_gp_clipping
*
*
* Parameters:
*    gp          I: old pitch gains
*    g_pitch     I: pitch gain
*
* Function:
*    Verify that the sum of the last (N_FRAME+1) pitch gains is under
*    a certain threshold.
*
* Returns:
*    True or false
*/
__device__ static Word16 check_gp_clipping(Float32 *gp, Float32 g_pitch)
{
	Float32 sum;
	Word32 i;


	sum = g_pitch;

	for (i = 0; i < N_FRAME; i++) {
		sum += gp[i];
	}

	if (sum > 7.6F /*FGP_CLIP*/) {
		return 1;
	}
	else {
		return 0;
	}
}


/*
* q_gain_pitch
*
*
* Parameters:
*    mode              I: codec mode
*    gp_limit          I: pitch gain limit
*    gain              B: Pitch gain (unquant/quant)
*    gain_cand         O: pitch gain candidates (3),   MR795 only
*    gain_cind         O: pitch gain cand. indices (3),MR795 only
*
* Function:
*    Closed-loop pitch search
*
* Returns:
*    index             index of quantization
*/
__device__ static Word16 q_gain_pitch(enum Mode mode, Float32 gp_limit, Float32 *gain,
	Float32 gain_cand[], Word32 gain_cind[])
{
	Float32 err_min, err;
	Word32 i, index;


	err_min = (Float32)fabs(*gain - qua_gain_pitch[0]);
	index = 0;

	for (i = 1; i < NB_QUA_PITCH; i++) {
		if (qua_gain_pitch[i] <= gp_limit) {
			err = (Float32)fabs(*gain - qua_gain_pitch[i]);

			if (err < err_min) {
				err_min = err;
				index = i;
			}
		}
	}

	if (mode == MR795) {
		/*
		* in MR795 mode, compute three gain_pit candidates around the index
		* found in the quantization loop: the index found and the two direct
		* neighbours, except for the extreme cases (i=0 or i=NB_QUA_PITCH-1),
		* where the direct neighbour and the neighbour to that is used.
		*/
		Word32 ii;


		if (index == 0) {
			ii = index;
		}
		else {
			ii = index - 1;

			if (index == (NB_QUA_PITCH - 1) || (qua_gain_pitch[index + 1] >
				gp_limit)) {
				ii = index - 2;
			}
		}

		/* store candidate indices and values */
		for (i = 0; i < 3; i++) {
			gain_cind[i] = ii;
			gain_cand[i] = qua_gain_pitch[ii];
			ii++;
		}
		*gain = qua_gain_pitch[index];
	}
	else {
		/* return the index and gain pitch found */
		*gain = qua_gain_pitch_MR122[index];
	}
	return(Word16)index;
}


/*
* cl_ltp
*
*
* Parameters:
*    T0_prev_subframe  B: Integer pitch lag of previous sub-frame
*    gp                I: Gain history
*    mode              I: Coder mode
*    frame_offset      I: Offset to subframe
*    T_op              I: Open loop pitch lags
*    h1                I: Impulse response vector
*    exc               B: Excitation vector
*    res2              B: Long term prediction residual
*    xn                I: Target vector for pitch search
*    lsp_flag          I: LSP resonance flag
*    xn2               O: Target vector for codebook search
*    y1                O: Filtered adaptive excitation
*    T0                O: Pitch delay (integer part)
*    T0_frac           O: Pitch delay (fractional part)
*    gain_pit          O: Pitch gain
*    gCoeff[]          O: Correlations between xn, y1, & y2
*    anap              O: Analysis parameters
*    gp_limit          O: pitch gain limit
*
* Function:
*    Closed-loop ltp search
*
*    Adaptive codebook search is performed on a subframe basis.
*    It consists of performing closed-loop pitch search, and then computing
*    the adaptive codevector by interpolating the past excitation at
*    the selected fractional pitch lag.
*    The adaptive codebook parameters (or pitch parameters) are
*    the delay and gain of the pitch filter. In the adaptive codebook approach
*    for implementing the pitch filter, the excitation is repeated for delays
*    less than the subframe length. In the search stage, the excitation is
*    extended by the LP residual to simplify the closed-loop search.
*
* Returns:
*    void
*/
__device__ static void cl_ltp(Word32 *T0_prev_subframe, Float32 *gp, enum Mode mode,
	Word16 frame_offset, Word32 T_op[], Float32 *h1, Float32 *exc, Float32
	res2[], Float32 xn[], Word16 lsp_flag, Float32 xn2[], Float32 y1[], Word32
	*T0, Word32 *T0_frac, Float32 *gain_pit, Float32 gCoeff[], Word16 **anap,
	Float32 *gp_limit)
{
	Float32 s;
	Word32 i, n;
	Word16 gpc_flag, resu3;   /* flag for upsample resolution */

	Word32 exc_tmp[314];
	Word32 *exc_tmp_p;

	exc_tmp_p = exc_tmp + PIT_MAX + L_INTERPOL;


	/* Closed-loop fractional pitch search */
	*T0 = Pitch_fr(T0_prev_subframe, mode, T_op, exc, xn, h1, frame_offset,
		T0_frac, &resu3, &i);
	*(*anap)++ = (Word16)i;

	/*
	* Compute the adaptive codebook vector
	* using fixed point. This is required
	* to maintain encoder/decoder excitation
	* syncronisation
	*/
	for (i = -(PIT_MAX + L_INTERPOL); i < 40; i++)
		exc_tmp_p[i] = (Word32)exc[i];

	Pred_lt_3or6_fixed(exc_tmp_p, *T0, *T0_frac, resu3);

	for (i = -(PIT_MAX + L_INTERPOL); i < 40; i++)
		exc[i] = (Float32)exc_tmp_p[i];

	/*
	*   Convolve to get filtered adaptive codebook vector
	*  y[n] = sum_{i=0}^{n} x[i] h[n-i], n=0,...,L-1
	*/
	for (n = 0; n < L_SUBFR; n++) {
		s = 0;

		for (i = 0; i <= n; i++) {
			s += exc[i] * h1[n - i];
		}
		y1[n] = s;
	}

	/* The adaptive codebook gain */
	*gain_pit = G_pitch(xn, y1, gCoeff);

	/* check if the pitch gain should be limit due to resonance in LPC filter */
	gpc_flag = 0;
	*gp_limit = 2.0F;

	if ((lsp_flag != 0) && (*gain_pit > 0.95F)) {
		gpc_flag = check_gp_clipping(gp, *gain_pit);
	}

	/*
	* special for the MR475, MR515 mode; limit the gain to 0.85 to
	* cope with bit errors in the decoder in a better way.
	*/
	if ((mode == MR475) || (mode == MR515)) {
		if (*gain_pit > 0.85) {
			*gain_pit = 0.85F;
		}

		if (gpc_flag != 0)
			*gp_limit = GP_CLIP;
	}
	else {
		if (gpc_flag != 0) {
			*gp_limit = GP_CLIP;
			*gain_pit = GP_CLIP;
		}

		/*
		* 12k2 gain_pit is quantized here and not in gainQuant.
		*/
		if (mode == MR122) {

			*(*anap)++ = q_gain_pitch(MR122, *gp_limit, gain_pit, NULL, NULL);
		}
	}

	/*
	* Update target vector for codebook search
	* Find LTP residual
	*/
	for (i = 0; i < L_SUBFR; i++) {
		xn2[i] = xn[i] - y1[i] * *gain_pit;
		res2[i] = res2[i] - exc[i] * *gain_pit;
	}
}


/*
* DotProduct
*
*
* Parameters:
*    x                 I: first input
*    y                 I: second input
*    len               I: length of product
*
* Function:
*    Computes dot product
*
* Returns:
*    acc               dot product
*/
__device__ static Float32 DotProduct(Float32 *x, Float32 *y, Word32 len)
{
	Word32 i;
	Float32 acc;


	acc = 0.0F;

	for (i = 0; i < len; i++)
		acc += x[i] * y[i];
	return(acc);
}


/*
* cor_h_x
*
*
* Parameters:
*    h                 I: impulse response of weighted synthesis filter
*    x                 I: target
*    dn                O: correlation between target and impulse response
*
* Function:
*    Computes correlation between target signal and impulse response.
*
* Returns:
*    void
*/
__device__ static void cor_h_x(Float32 h[], Float32 x[], Float32 dn[])
{
	Word32 i;


	dn[0] = (Float32)Dotproduct40(h, x);

	for (i = 1; i < L_CODE; i++)
		dn[i] = (Float32)DotProduct(h, &x[i], L_CODE - i);
}


/*
* set_sign
*
*
* Parameters:
*    dn                B: correlation between target and h[]
*    sign              O: sign of dn[]
*    dn2               O: maximum of correlation in each track
*    n                 I: # of maximum correlations in dn2[]
*
* Function:
*    Builds sign[] vector.
*
* Returns:
*    void
*/
__device__ static void set_sign(Float32 dn[], Float32 sign[], Float32 dn2[], Word16 n)
{
	Float32 val, min;
	Word32 i, j, k, pos = 0;


	/* set sign according to dn[] */
	for (i = 0; i < L_CODE; i++) {
		val = dn[i];

		if (val >= 0) {
			sign[i] = 1.0F;
		}
		else {
			sign[i] = -1.0F;
			val = -val;
		}

		/* modify dn[] according to the fixed sign */
		dn[i] = val;
		dn2[i] = val;
	}

	/* keep 8-n maximum positions/8 of each track and store it in dn2[] */
	for (i = 0; i < NB_TRACK; i++) {
		for (k = 0; k < (8 - n); k++) {
			min = FLT_MAX;

			for (j = i; j < L_CODE; j += STEP) {
				if (dn2[j] >= 0) {
					val = dn2[j] - min;

					if (val < 0) {
						min = dn2[j];
						pos = j;
					}
				}
			}
			dn2[pos] = -1.0F;
		}
	}
	return;
}


/*
* cor_h
*
*
* Parameters:
*    h                I: h[]
*    sign             I: sign information
*    rr               O: correlations
*
* Function:
*    Computes correlations of h[] needed for the codebook search,
*    and includes the sign information into the correlations.
*
* Returns:
*    void
*/
__device__ static void cor_h(Float32 h[], Float32 sign[], Float32 rr[][L_CODE])
{
	Float32 sum;
	Float32 *prr, *ph, *ph_max;
	Float32 *rrj, *rri, *signi, *signj;
	Word32 ii, total_loops, four_loops;


	sum = 0.0F;

	/* Compute diagonal matrix of autocorrelation of h */
	rr[0][0] = (Float32)Dotproduct40(h, h);
	prr = &rr[39][39];
	ph = &h[0];
	ph_max = ph + 39;

	/*
	* speed optimization of code:
	* for (k=0; k<m; k++)
	* {
	* sum += h[k]*h[k];
	* rr[i][i] = sum;
	* i--;
	* }
	*/
	do {
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
		sum += *ph * *ph;
		ph++;
		*prr = sum;
		prr -= 41;
	} while (ph < ph_max);

	/*
	* Compute upper & bottom symmetric matrix of autocorrelation of h.
	*/
	/* speed optimization of code:
	* for (ii=1; ii<L_CODE; ii++)
	* {
	* j = m;
	* i = j - ii;
	* sum = (Float32)0.0;
	* for ( k = 0; k < (L_CODE-ii); k++ )
	* {
	* sum += h[k]*h[k+ii];
	* rr[i][j] = rr[j][i] = (sum*sign[i]*sign[j]);
	* i--; j--;
	* }
	* }
	*/
	ii = 1;

	for (total_loops = 9; total_loops >= 0; total_loops--) {
		rrj = rri = &rr[39][39];
		rrj -= ii;
		rri = (rri - 40 * ii);
		signi = signj = &sign[39];
		signi -= ii;
		sum = 0.0F;
		ph = &h[0];

		for (four_loops = 0; four_loops < total_loops; four_loops++) {
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
		}
		sum += *ph * *(ph + ii);
		ph++;
		*rri = *rrj = sum * *signi * *signj;
		rri -= 41;
		rrj -= 41;
		signi--;
		signj--;
		sum += *ph * *(ph + ii);
		ph++;
		*rri = *rrj = sum * *signi * *signj;
		rri -= 41;
		rrj -= 41;
		signi--;
		signj--;
		sum += *ph * *(ph + ii);
		*rri = *rrj = sum * *signi * *signj;
		ii++;
		rrj = rri = &rr[39][39];
		rrj -= ii;
		rri = (rri - 40 * ii);
		signi = signj = &sign[39];
		signi -= ii;
		sum = 0.0F;
		ph = &h[0];

		for (four_loops = 0; four_loops < total_loops; four_loops++) {
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
		}
		sum += *ph * *(ph + ii);
		ph++;
		*rri = *rrj = sum * *signi * *signj;
		rri -= 41;
		rrj -= 41;
		signi--;
		signj--;
		sum += *ph * *(ph + ii);
		*rri = *rrj = sum * *signi * *signj;
		ii++;
		rrj = rri = &rr[39][39];
		rrj -= ii;
		rri = (rri - 40 * ii);
		signi = signj = &sign[39];
		signi -= ii;
		sum = 0.0F;
		ph = &h[0];

		for (four_loops = 0; four_loops < total_loops; four_loops++) {
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
		}
		sum += *ph * *(ph + ii);
		*rri = *rrj = sum * *signi * *signj;
		ii++;
		rrj = rri = &rr[39][39];
		rrj -= ii;
		rri = (rri - 40 * ii);
		signi = signj = &sign[39];
		signi -= ii;
		sum = 0.0F;
		ph = &h[0];

		for (four_loops = 0; four_loops < total_loops; four_loops++) {
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * (*signi) * (*signj);
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
			sum += *ph * *(ph + ii);
			ph++;
			*rri = *rrj = sum * *signi * *signj;
			rri -= 41;
			rrj -= 41;
			signi--;
			signj--;
		}
		ii++;
	}
	return;
}


/*
* search_2i40_9bits
*
*
* Parameters:
*    subNr             I: subframe number
*    dn                I: correlation between target and h[]
*    rr                I: matrix of autocorrelation
*    codvec            O: algebraic codebook vector
*
* Function:
*    Search the best codevector; determine positions of the 2 pulses
*    in the 40-sample frame.
*
*    First subframe:
*    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
*    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
*             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
*
*    Second subframe:
*    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
*    second   i0 :  2, 7, 12, 17, 22, 27, 32, 37.
*             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
*
*    Third subframe:
*    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
*    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
*             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
*
*    Fourth subframe:
*    first    i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
*    second   i0 :  1, 6, 11, 16, 21, 26, 31, 36.
*             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
*
* Returns:
*    void
*/
__device__ static void search_2i40_9bits(Word16 subNr, Float32 dn[], Float32 rr[][L_CODE],
	Word32 codvec[])
{
	Float32 ps0, ps1, psk, alp, alp0, alp1, alpk, sq, sq1;
	Word32 i0, i1, ix, i;
	Word16 ipos[2];
	Word16 track1;


	psk = -1;
	alpk = 1;

	for (i = 0; i < 2; i++) {
		codvec[i] = i;
	}

	/* main loop: try 2x4  tracks	*/
	for (track1 = 0; track1 < 2; track1++) {
		ipos[0] = startPos[(subNr << 1) + (track1 << 3)];
		ipos[1] = startPos[(subNr << 1) + 1 + (track1 << 3)];

		/* i0 loop: try 8 positions	*/
		for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {
			ps0 = dn[i0];
			alp0 = rr[i0][i0];

			/* i1 loop: 8 positions */
			sq = -1;
			alp = 1;
			ix = ipos[1];

			for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {
				ps1 = ps0 + dn[i1];
				alp1 = alp0 + rr[i1][i1] + 2.0F * rr[i0][i1];
				sq1 = ps1 * ps1;

				if ((alp * sq1) >(sq * alp1)) {
					sq = sq1;
					alp = alp1;
					ix = i1;
				}
			}

			/* memorise codevector if this one is better than the last one	*/
			if ((alpk * sq) > (psk * alp)) {
				psk = sq;
				alpk = alp;
				codvec[0] = i0;
				codvec[1] = ix;
			}
		}
	}
	return;
}


/*
* build_code_2i40_9bits
*
*
* Parameters:
*    subNr             I: subframe number
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 I: filtered innovative code
*    anap              O: analysis parameters
*
* Function:
*    Builds the codeword, the filtered codeword and index of the
*    codevector, based on the signs and positions of 2 pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_2i40_9bits(Word16 subNr, Word32 codvec[], Float32
	dn_sign[], Float32 cod[], Float32 h[], Float32 y[], Word16 *anap)
{
	Float32 s;
	Float32 *p0, *p1;
	Word32 _sign[2];
	Word32 i, j, k, track, index, indx = 0, rsign = 0;
	Word8 first, *pt;


	pt = &trackTable[subNr + (subNr << 2)];
	memset(cod, 0, 160);

	for (k = 0; k < 2; k++) {
		/* read pulse position */
		i = codvec[k];

		/* read sign */
		j = (Word32)dn_sign[i];

		/* index = pos/5 */
		index = i / 5;

		/* track = pos%5 */
		track = i % 5;
		first = pt[track];

		if (first == 0) {
			if (k == 0) {
				/*	position of 1st pulse	*/
				track = 0;
			}
			else {
				track = 1;

				/*	position of 2nd pulse	*/
				index <<= 3;
			}
		}
		else {
			if (k == 0) {
				track = 0;

				/*	position of 1st pulse, subset 2	*/
				index += 64;
			}
			else {
				track = 1;
				index <<= 3;
			}
		}

		if (j > 0) {
			cod[i] = 0.9998779296875F;
			_sign[k] = 1;

			/*	sign information */
			rsign = rsign + (1 << track);
		}
		else {
			cod[i] = -1;
			_sign[k] = -1;
		}
		indx = indx + index;
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * _sign[0];
		s += *p1++ * _sign[1];
		y[i] = s;
	}
	anap[0] = (Word16)indx;
	anap[1] = (Word16)rsign;
}


/*
* code_2i40_9bits
*
*
* Parameters:
*    subNr             I: subframe number
*    x                 I: target vector
*    h                 I: impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    code              O: innovative codebook
*    y                 O: filtered fixed codebook excitation
*    anap              O: analysis parameters
*
* Function:
*    Searches a 9 bit algebraic codebook containing 2 pulses
*    in a frame of 40 samples.
*
*    The code length is 40, containing 2 nonzero pulses: i0...i1.
*    All pulses can have two possible amplitudes: +1 or -1.
*    Pulse i0 can have 8 possible positions, pulse i1 can have
*    8 positions. Also coded is which track pair should be used,
*    i.e. first or second pair. Where each pair contains 2 tracks.
*
* Returns:
*    void
*/
__device__ static void code_2i40_9bits(Word16 subNr, Float32 x[], Float32 h[], Word32 T0,
	Float32 pitch_sharp, Float32 code[], Float32 y[], Word16 *anap)
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], dn_sign[L_CODE], dn2[L_CODE];
	Word32 codvec[2];
	Word32 i;


	if ((T0 < L_CODE) && (pitch_sharp != 0.0F))
		for (i = T0; i < L_CODE; i++) {
			h[i] += h[i - T0] * pitch_sharp;
		}
	cor_h_x(h, x, dn);
	set_sign(dn, dn_sign, dn2, 8);
	cor_h(h, dn_sign, rr);
	search_2i40_9bits(subNr, dn, rr, codvec);
	build_code_2i40_9bits(subNr, codvec, dn_sign, code, h, y, anap);

	/*
	* Compute innovation vector gain.
	* Include fixed-gain pitch contribution into code[].
	*/
	if ((T0 < L_CODE) && (pitch_sharp != 0.0F))
		for (i = T0; i < L_CODE; i++) {
			code[i] += code[i - T0] * pitch_sharp;
		}
}


/*
* search_2i40_11bits
*
*
* Parameters:
*    dn                I: correlation between target and h[]
*    rr                I: matrix of autocorrelation
*    codvec            O: algebraic codebook vector
*
* Function:
*    Search the best codevector; determine positions of the 2 pulses
*    in the 40-sample frame.
*
* Returns:
*    void
*/
__device__ static void search_2i40_11bits(Float32 dn[], Float32 rr[][L_CODE], Word32
	codvec[])
{
	Float64 alpk, alp, alp0, alp1;
	Float32 psk, ps0, ps1, sq, sq1;
	Word32 i, i0, i1, ix = 0;
	Word16 ipos[2];
	Word16 track1, track2;


	psk = -1;
	alpk = 1;

	for (i = 0; i < 2; i++) {
		codvec[i] = i;
	}

	/*
	* main loop: try 2x4  tracks.
	*/
	for (track1 = 0; track1 < 2; track1++) {
		for (track2 = 0; track2 < 4; track2++) {
			/* fix starting position */
			ipos[0] = startPos1[track1];
			ipos[1] = startPos2[track2];

			/*
			* i0 loop: try 8 positions.
			*/
			for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {
				ps0 = dn[i0];
				alp0 = rr[i0][i0] * 0.25F;

				/*
				* i1 loop: 8 positions.
				*/
				sq = -1;
				alp = 1;
				ix = ipos[1];

				for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {
					ps1 = ps0 + dn[i1];

					/* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
					alp1 = alp0 + rr[i1][i1] * 0.25F;
					alp1 += rr[i0][i1] * 0.5F;
					sq1 = ps1 * ps1;

					if ((alp * sq1) >(sq * alp1)) {
						sq = sq1;
						alp = alp1;
						ix = i1;
					}
				}

				/*
				* memorise codevector if this one is better than the last one.
				*/
				if ((alpk * sq) > (psk * alp)) {
					psk = sq;
					alpk = alp;
					codvec[0] = i0;
					codvec[1] = ix;
				}
			}
		}
	}
	return;
}


/*
* build_code_2i40_11bits
*
*
* Parameters:
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 O: filtered innovative code
*    anap              O: analysis parameters
*
* Function:
*    Builds the codeword, the filtered codeword and index of the
*    codevector, based on the signs and positions of 2 pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_2i40_11bits(Word32 codvec[], Float32 dn_sign[], Float32
	cod[], Float32 h[], Float32 y[], Word16 *anap)
{
	Float64 s;
	Float32 *p0, *p1;
	Word32 _sign[2];
	Word32 i, j, k, track, index, indx = 0, rsign = 0;


	memset(cod, 0, 160);

	for (k = 0; k < 2; k++) {
		i = codvec[k];   /* read pulse position */
		j = (Word16)dn_sign[i];   /* read sign */
		index = i / 5;   /* index = pos/5 */

						 /* track = pos%5 */
		track = i % 5;

		if (track == 0) {
			track = 1;
			index = index << 6;
		}
		else if (track == 1) {
			if (k == 0) {
				track = 0;
				index = index << 1;
			}
			else {
				track = 1;
				index = (index << 6) + 16;
			}
		}
		else if (track == 2) {
			track = 1;
			index = (index << 6) + 32;
		}
		else if (track == 3) {
			track = 0;
			index = (index << 1) + 1;
		}
		else if (track == 4) {
			track = 1;
			index = (index << 6) + 48;
		}

		if (j > 0) {
			cod[i] = 0.9998779296875F;
			_sign[k] = 1;
			rsign = rsign + (1 << track);
		}
		else {
			cod[i] = -1;
			_sign[k] = -1;
		}
		indx = indx + index;
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * _sign[0];
		s += *p1++ * _sign[1];
		y[i] = (Float32)s;
	}
	anap[0] = (Word16)indx;
	anap[1] = (Word16)rsign;
}


/*
* code_2i40_11bits
*
*
* Parameters:
*    x                 I: target vector
*    h                 I: impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    code              O: innovative codebook
*    y                 O: filtered fixed codebook excitation
*    anap              O: analysis parameters
*
* Function:
*    Searches a 11 bit algebraic codebook containing 2 pulses
*    in a frame of 40 samples.
*
*    The code length is 40, containing 2 nonzero pulses: i0...i1.
*    All pulses can have two possible amplitudes: +1 or -1.
*    Pulse i0 can have 2x8=16 possible positions, pulse i1 can have
*    4x8=32 positions.
*
*    i0 :  1, 6, 11, 16, 21, 26, 31, 36.
*          3, 8, 13, 18, 23, 28, 33, 38.
*    i1 :  0, 5, 10, 15, 20, 25, 30, 35.
*          1, 6, 11, 16, 21, 26, 31, 36.
*          2, 7, 12, 17, 22, 27, 32, 37.
*          4, 9, 14, 19, 24, 29, 34, 39.
*
* Returns:
*    void
*/
__device__ static void code_2i40_11bits(Float32 x[], Float32 h[], Word32 T0, Float32
	pitch_sharp, Float32 code[], Float32 y[], Word16 *anap)
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
	Word32 codvec[2];
	Word32 i;


	if ((T0 < L_CODE) && (pitch_sharp != 0.0F)) {
		for (i = T0; i < L_CODE; i++) {
			h[i] = h[i] + (h[i - T0] * pitch_sharp);
		}
	}
	cor_h_x(h, x, dn);
	set_sign(dn, dn_sign, dn2, 8);
	cor_h(h, dn_sign, rr);
	search_2i40_11bits(dn, rr, codvec);
	build_code_2i40_11bits(codvec, dn_sign, code, h, y, anap);

	/*
	* Compute innovation vector gain.
	* Include fixed-gain pitch contribution into code[].
	*/
	if ((T0 < L_CODE) && (pitch_sharp != 0.0F)) {
		for (i = T0; i < L_CODE; i++) {
			code[i] = code[i] + code[i - T0] * pitch_sharp;
		}
	}
}


/*
* search_3i40
*
*
* Parameters:
*    dn                I: correlation between target and h[]
*    dn2               I: maximum of corr. in each track
*    rr                I: matrix of autocorrelation
*    codvec            O: algebraic codebook vector
*
* Function:
*    Searches a 14 bit algebraic codebook containing 3 pulses in
*    a frame of 40 samples.
*
* Returns:
*    void
*/
__device__ static void search_3i40(Float32 dn[], Float32 dn2[], Float32 rr[][L_CODE],
	Word32 codvec[])
{
	Float32 psk, ps0, ps1, sq, sq1, alpk, alp, alp0, alp1, ps = 0.0F;
	Float32 *rr2, *rr1, *rr0, *pdn, *pdn_max;
	Word32 ipos[3];
	Word32 i0, i1, i2, ix, i, pos, track1, track2;


	psk = -1.0F;
	alpk = 1.0F;

	for (track1 = 1; track1 < 4; track1 += 2) {
		for (track2 = 2; track2 < 5; track2 += 2) {
			/* fix starting position */
			ipos[0] = 0;
			ipos[1] = track1;
			ipos[2] = track2;

			/* main loop: try 3 tracks */
			for (i = 0; i < 3; i++) {
				/* i0 loop: try 8 positions */
				for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {
					if (dn2[i0] >= 0) {
						ps0 = dn[i0];
						alp0 = rr[i0][i0];

						/* i1 loop: 8 positions */
						sq = -1.0F;
						alp = 1.0F;
						ps = 0.0F;
						ix = ipos[1];
						i1 = ipos[1];
						rr1 = &rr[i1][i1];
						rr0 = &rr[i0][i1];
						pdn = &dn[i1];
						pdn_max = &dn[L_CODE];

						do {
							ps1 = ps0 + *pdn;
							alp1 = alp0 + *rr1 + 2.0F * *rr0;
							sq1 = ps1 * ps1;

							if ((alp * sq1) > (sq * alp1)) {
								sq = sq1;
								ps = ps1;
								alp = alp1;
								ix = (Word16)(pdn - dn);
							}
							pdn += STEP;
							rr1 += (40 * STEP + STEP);
							rr0 += STEP;
						} while (pdn < pdn_max);
						i1 = ix;

						/* i2 loop: 8 positions */
						ps0 = ps;
						alp0 = alp;
						sq = -1.0F;
						alp = 1.0F;
						ps = 0.0F;
						ix = ipos[2];
						i2 = ipos[2];
						rr2 = &rr[i2][i2];
						rr1 = &rr[i1][i2];
						rr0 = &rr[i0][i2];
						pdn = &dn[i2];

						do {
							ps1 = ps0 + *pdn;
							alp1 = alp0 + *rr2 + 2.0F * (*rr1 + *rr0);
							sq1 = ps1 * ps1;

							if ((alp * sq1) > (sq * alp1)) {
								sq = sq1;
								ps = ps1;
								alp = alp1;
								ix = (Word16)(pdn - dn);
							}
							pdn += STEP;
							rr2 += (40 * STEP + STEP);
							rr1 += STEP;
							rr0 += STEP;
						} while (pdn < pdn_max);
						i2 = ix;

						/* memorise codevector if this one is better than the last one */
						if ((alpk * sq) >(psk * alp)) {
							psk = sq;
							alpk = alp;
							codvec[0] = i0;
							codvec[1] = i1;
							codvec[2] = i2;
						}
					}
				}

				/* Cyclic permutation of i0, i1 and i2 */
				pos = ipos[2];
				ipos[2] = ipos[1];
				ipos[1] = ipos[0];
				ipos[0] = pos;
			}
		}
	}
	return;
}


/*
* build_code_3i40_14bits
*
*
* Parameters:
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 I: filtered innovative code
*    anap              O: analysis parameters
*
* Function:
*    Builds the codeword, the filtered codeword and index of the
*    codevector, based on the signs and positions of 3 pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_3i40_14bits(Word32 codvec[], Float32 dn_sign[], Float32
	cod[], Float32 h[], Float32 y[], Word16 *anap)
{
	Float64 s;
	Float32 _sign[3];
	Float32 *p0, *p1, *p2;
	Word32 i, j, k, track, index, indx, rsign;


	memset(cod, 0, 160);
	indx = 0;
	rsign = 0;

	for (k = 0; k < 3; k++) {
		/* read pulse position */
		i = codvec[k];

		/* read sign */
		j = (Word16)dn_sign[i];

		/* index = pos/5 */
		index = i / 5;

		/* track = pos%5 */
		track = i % 5;

		if (track == 1)
			index = index << 4;
		else if (track == 2) {
			track = 2;
			index = index << 8;
		}
		else if (track == 3) {
			track = 1;
			index = (index << 4) + 8;
		}
		else if (track == 4) {
			track = 2;
			index = (index << 8) + 128;
		}

		if (j > 0) {
			cod[i] = 0.9998779296875F;
			_sign[k] = 1.0F;
			rsign = rsign + (1 << track);
		}
		else {
			cod[i] = -1.0F;
			_sign[k] = -1.0F;
		}
		indx = indx + index;
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];
	p2 = h - codvec[2];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * _sign[0];
		s += *p1++ * _sign[1];
		s += *p2++ * _sign[2];
		y[i] = (Float32)s;
	}
	anap[0] = (Word16)indx;
	anap[1] = (Word16)rsign;
}


/*
* code_3i40_14bits
*
*
* Parameters:
*    x                 I: target vector
*    h                 I: impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    code              O: innovative codebook
*    y                 O: filtered fixed codebook excitation
*    anap              O: analysis parameters
*
* Function:
*    Searches a 14 bit algebraic codebook containing 3 pulses
*    in a frame of 40 samples.
*
*    The code length is 40, containing 3 nonzero pulses: i0...i2.
*    All pulses can have two possible amplitudes: +1 or -1.
*    Pulse i0 can have 8 possible positions, pulses i1 and i2 can have
*    2x8=16 positions.
*
*       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
*             3, 8, 13, 18, 23, 28, 33, 38.
*       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
*             4, 9, 14, 19, 24, 29, 34, 39.
*
* Returns:
*    void
*/
__device__ static void code_3i40_14bits(Float32 x[], Float32 h[], Word32 T0, Float32
	pitch_sharp, Float32 code[], Float32 y[], Word16 *anap)
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
	Word32 codvec[3];
	Word32 i;


	if ((T0 < L_CODE) && (pitch_sharp != 0)) {
		for (i = T0; i < L_CODE; i++) {
			h[i] = h[i] + (h[i - T0] * pitch_sharp);
		}
	}
	cor_h_x(h, x, dn);
	set_sign(dn, dn_sign, dn2, 6);
	cor_h(h, dn_sign, rr);
	search_3i40(dn, dn2, rr, codvec);

	/* function result */
	build_code_3i40_14bits(codvec, dn_sign, code, h, y, anap);

	/*
	* Compute innovation vector gain.
	* Include fixed-gain pitch contribution into code[].
	*/
	if ((T0 < L_CODE) && (pitch_sharp != 0)) {
		for (i = T0; i < L_CODE; i++) {
			code[i] = code[i] + (code[i - T0] * pitch_sharp);
		}
	}
}


/*
* search_4i40
*
*
* Parameters:
*    dn                I: correlation between target and h[]
*    dn2               I: maximum of corr. in each track.
*    rr                I: matrix of autocorrelation
*    codvec            O: algebraic codebook vector
*
* Function:
*    Search the best codevector; determine positions of the 4 pulses
*    in the 40-sample frame.
*
* Returns:
*    void
*/
__device__ static void search_4i40(Float32 dn[], Float32 dn2[], Float32 rr[][L_CODE],
	Word32 codvec[])
{
	Float64 alpk, alp, alp0, alp1;
	Float32 ps, psk, ps0, ps1, sq, sq1;
	Word32 ipos[4];
	Word32 i0, i1, i2, i3, ix, i, pos, track;


	/* Default value */
	psk = -1;
	alpk = 1;

	for (i = 0; i < 4; i++) {
		codvec[i] = i;
	}

	for (track = 3; track < 5; track++) {
		/* fix starting position */
		ipos[0] = 0;
		ipos[1] = 1;
		ipos[2] = 2;
		ipos[3] = track;

		/*
		* main loop: try 4 tracks.
		*/
		for (i = 0; i < 4; i++) {
			/*
			* i0 loop: try 4 positions (use position with max of corr.).
			*/
			for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {
				if (dn2[i0] >= 0) {
					ps0 = dn[i0];
					alp0 = rr[i0][i0] * 0.25F;

					/*
					* i1 loop: 8 positions.
					*/
					sq = -1;
					alp = 1;
					ps = 0;
					ix = ipos[1];

					for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {
						ps1 = ps0 + dn[i1];

						/* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
						alp1 = alp0 + rr[i1][i1] * 0.25F;
						alp1 = alp1 + rr[i0][i1] * 0.5F;
						sq1 = ps1 * ps1;

						if ((alp * sq1) >(sq * alp1)) {
							sq = sq1;
							ps = ps1;
							alp = alp1;
							ix = i1;
						}
					}
					i1 = ix;

					/*
					* i2 loop: 8 positions.
					*/
					ps0 = ps;
					alp0 = alp * 0.25F;
					sq = -1;
					alp = 1;
					ps = 0;
					ix = ipos[2];

					for (i2 = ipos[2]; i2 < L_CODE; i2 += STEP) {
						ps1 = ps0 + dn[i2];

						/* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
						alp1 = alp0 + rr[i2][i2] * 0.0625F;
						alp1 += rr[i1][i2] * 0.125F;
						alp1 += rr[i0][i2] * 0.125F;
						sq1 = ps1 * ps1;

						if ((alp * sq1) >(sq * alp1)) {
							sq = sq1;
							ps = ps1;
							alp = alp1;
							ix = i2;
						}
					}
					i2 = ix;

					/*
					* i3 loop: 8 positions
					*/
					ps0 = ps;
					alp0 = alp;
					sq = -1;
					alp = 1;
					ps = 0;
					ix = ipos[3];

					for (i3 = ipos[3]; i3 < L_CODE; i3 += STEP) {
						ps1 = ps0 + dn[i3];

						/* alp1 = alp0 + rr[i0][i3] + rr[i1][i3] + rr[i2][i3] + 1/2*rr[i3][i3]; */
						alp1 = alp0 + rr[i3][i3] * 0.0625F;
						alp1 += rr[i2][i3] * 0.125F;
						alp1 += rr[i1][i3] * 0.125F;
						alp1 += rr[i0][i3] * 0.125F;
						sq1 = ps1 * ps1;

						if ((alp * sq1) >(sq * alp1)) {
							sq = sq1;
							ps = ps1;
							alp = alp1;
							ix = i3;
						}
					}

					/*
					* memorise codevector if this one is better than the last one.
					*/
					if ((alpk * sq) > (psk * alp)) {
						psk = sq;
						alpk = alp;
						codvec[0] = i0;
						codvec[1] = i1;
						codvec[2] = i2;
						codvec[3] = ix;
					}
				}
			}

			/*
			* Cyclic permutation of i0,i1,i2 and i3.
			*/
			pos = ipos[3];
			ipos[3] = ipos[2];
			ipos[2] = ipos[1];
			ipos[1] = ipos[0];
			ipos[0] = pos;
		}
	}
	return;
}


/*
* build_code_4i40
*
*
* Parameters:
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 O: filtered innovative code
*    anap              O: analysis parameters
*
* Function:
*    Builds the codeword, the filtered codeword and index of the
*    codevector, based on the signs and positions of 4 pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_4i40(Word32 codvec[], Float32 dn_sign[], Float32 cod[],
	Float32 h[], Float32 y[], Word16 *anap)
{
	Float64 s;
	Float32 *p0, *p1, *p2, *p3;
	Word32 _sign[4];
	Word32 i, j, k, track, index, indx = 0, rsign = 0;


	memset(cod, 0, 160);

	for (k = 0; k < 4; k++) {
		/* read pulse position */
		i = codvec[k];

		/* read sign */
		j = (Word16)dn_sign[i];
		index = i / 5;
		track = i % 5;
		index = gray[index];

		if (track == 1)
			index = index << 3;
		else if (track == 2) {
			index = index << 6;
		}
		else if (track == 3) {
			index = index << 10;
		}
		else if (track == 4) {
			track = 3;
			index = (index << 10) + 512;
		}

		if (j > 0) {
			cod[i] = 0.9998779296875F;
			_sign[k] = 1;
			rsign = rsign + (1 << track);
		}
		else {
			cod[i] = -1;
			_sign[k] = -1;
		}
		indx = indx + index;
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];
	p2 = h - codvec[2];
	p3 = h - codvec[3];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * _sign[0];
		s += *p1++ * _sign[1];
		s += *p2++ * _sign[2];
		s += *p3++ * _sign[3];
		y[i] = (Float32)(s);
	}
	anap[0] = (Word16)indx;
	anap[1] = (Word16)rsign;
}


/*
* code_4i40_17bits
*
*
* Parameters:
*    x                 I: target vector
*    h                 I: impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    code              O: innovative codebook
*    y                 O: filtered fixed codebook excitation
*    anap              O: analysis parameters
*
* Function:
*    Searches a 17 bit algebraic codebook containing 4 pulses
*    in a frame of 40 samples.
*
*    The code length is 40, containing 4 nonzero pulses: i0...i3.
*    All pulses can have two possible amplitudes: +1 or -1.
*    Pulse i0 to i2 can have 8 possible positions, pulse i3 can have
*    2x8=16 positions.
*
*       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
*       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
*       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
*       i3 :  3, 8, 13, 18, 23, 28, 33, 38.
*             4, 9, 14, 19, 24, 29, 34, 39.
*
* Returns:
*    void
*/
__device__ static void code_4i40_17bits(Float32 x[], Float32 h[], Word32 T0, Float32
	pitch_sharp, Float32 code[], Float32 y[], Word16 *anap)
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
	Word32 codvec[4];
	Word32 i;


	if ((T0 < L_CODE) && (pitch_sharp != 0)) {
		for (i = T0; i < L_CODE; i++) {
			h[i] = h[i] + h[i - T0] * pitch_sharp;
		}
	}
	cor_h_x(h, x, dn);
	set_sign(dn, dn_sign, dn2, 4);
	cor_h(h, dn_sign, rr);
	search_4i40(dn, dn2, rr, codvec);
	build_code_4i40(codvec, dn_sign, code, h, y, anap);

	/*
	* Compute innovation vector gain.
	* Include fixed-gain pitch contribution into code[].
	*/
	if ((T0 < L_CODE) && (pitch_sharp != 0)) {
		for (i = T0; i < L_CODE; i++) {
			code[i] = code[i] + (code[i - T0] * pitch_sharp);
		}
	}
}


/*
* set_sign12k2
*
*
* Parameters:
*    dn                B: correlation between target and h[]
*    cn                I: residual after long term prediction
*    sign              O: sign of dn[]
*    pos_max           O: position of maximum correlation
*    nb_track          I: number of tracks
*    ipos              O: starting position for each pulse
*    step              I: the step size in the tracks
*
* Function:
*    Builds sign[] vector according to "dn[]" and "cn[]", and modifies
*    dn[] to include the sign information (dn[i]=sign[i]*dn[i]).
*    Also finds the position of maximum of correlation in each track
*    and the starting position for each pulse.
*
*
*                  cn[n]                     dn[n]
*    b(n) = ----------------------- + -----------------------  ;n = 0,..,39
*                   39                        39
*            sqrt( SUM cn[i]*cn[i] )   sqrt( SUM dn[i]*dn[i] )
*                  i=0                       i=0
*
*    sign[n] = sign(b[n])
*
*    d'[n] = sign[n] * d[n]
*
* Returns:
*    void
*/
__device__ static void set_sign12k2(Float32 dn[], Float32 cn[], Float32 sign[], Word32
	pos_max[], Word16 nb_track, Word32 ipos[], Word16 step)
{
	Float32 b[L_CODE];
	Float32 val, cor, k_cn, k_dn, max, max_of_all, sum;
	Word32 i, j, pos = 0;


	/* calculate energy for normalization of cn[] and dn[] */
	sum = 0.01F;
	sum += (Float32)Dotproduct40(cn, cn);
	k_cn = (Float32)(1 / sqrt(sum));
	sum = 0.01F;
	sum += (Float32)Dotproduct40(dn, dn);
	k_dn = (Float32)(1 / sqrt(sum));

	for (i = 0; i < L_CODE; i++) {
		val = dn[i];
		cor = (k_cn * cn[i]) + (k_dn * val);

		/* sign = +1 */
		sign[i] = 1;

		if (cor < 0) {
			/* sign = -1 */
			sign[i] = -1;
			cor = -cor;
			val = -val;
		}

		/* modify dn[] according to the fixed sign */
		dn[i] = val;
		b[i] = cor;
	}
	max_of_all = -1;

	for (i = 0; i < nb_track; i++) {
		max = -1;

		for (j = i; j < L_CODE; j += step) {
			cor = b[j];
			val = cor - max;

			if (val > 0) {
				max = cor;
				pos = j;
			}
		}

		/* store maximum correlation position in track */
		pos_max[i] = pos;
		val = max - max_of_all;

		if (val > 0) {
			/* store maximum correlation of all tracks */
			max_of_all = max;

			/* starting position for i0 */
			ipos[0] = i;
		}
	}

	/* Set starting position of each pulse	*/
	pos = ipos[0];
	ipos[nb_track] = pos;

	for (i = 1; i < nb_track; i++) {
		pos++;

		if (pos >= nb_track) {
			pos = 0;
		}
		ipos[i] = pos;
		ipos[i + nb_track] = pos;
	}
}


/*
* search_4i40
*
*
* Parameters:
*    dn                I: correlation between target and h[]
*    rr                I: matrix of autocorrelation
*    ipos              I: starting position for each pulse
*    pos_max           I: maximum of correlation position
*    codvec            O: algebraic codebook vector
*
* Function:
*    Search the best codevector; determine positions of the 8 pulses
*    in the 40-sample frame.
*
* Returns:
*    void
*/
__device__ static void search_8i40(Float32 dn[], Float32 rr[][L_CODE], Word32 ipos[],
	Word32 pos_max[], Word32 codvec[])
{
	Float32 rrv[L_CODE];
	Float32 psk, ps, ps0, ps1, ps2, sq, sq2, alpk, alp, alp0, alp1, alp2;
	Float32 *p_r, *p_r0, *p_r1, *p_r2, *p_r3, *p_r4, *p_r5, *p_r6, *p_r7, *p_r8;
	Float32 *p_rrv, *p_rrv0, *p_dn, *p_dn0, *p_dn1, *p_dn_max;
	Word32 i0, i1, i2, i3, i4, i5, i6, i7, j, k, ia, ib, i, pos;

	p_dn_max = &dn[39];

	/* fix i0 on maximum of correlation position */
	i0 = pos_max[ipos[0]];
	ia = ib = 0;
	ps = 0;

	/* i1 loop */
	/* Default value */
	psk = -1;
	alpk = 1;

	for (i = 0; i < 8; i++) {
		codvec[i] = i;
	}
	p_r = &rr[i0][i0];

	for (i = 1; i < 5; i++) {
		i1 = pos_max[ipos[1]];
		i2 = ipos[2];
		i3 = ipos[3];
		i4 = ipos[4];
		i5 = ipos[5];
		i6 = ipos[6];
		i7 = ipos[7];
		ps0 = dn[i0] + dn[i1];
		alp0 = *p_r + rr[i1][i1] + 2.0F * rr[i0][i1];

		/* i2 and i3 loop	*/
		p_rrv = &rrv[i3];
		p_r0 = &rr[i0][i3];
		p_r1 = &rr[i1][i3];
		p_r3 = &rr[i3][i3];
		*p_rrv = *p_r3 + 2.0F * (*p_r0 + *p_r1);
		*(p_rrv + 4) = *(p_r3 + 164) + 2.0F * (*(p_r0 + 4) + *(p_r1 + 4)
			);
		*(p_rrv + 8) = *(p_r3 + 328) + 2.0F * (*(p_r0 + 8) + *(p_r1 + 8)
			);
		*(p_rrv + 12) = *(p_r3 + 492) + 2.0F * (*(p_r0 + 12) + *(p_r1 + 12
			));
		*(p_rrv + 16) = *(p_r3 + 656) + 2.0F * (*(p_r0 + 16) + *(p_r1 + 16
			));
		*(p_rrv + 20) = *(p_r3 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			));
		*(p_rrv + 24) = *(p_r3 + 984) + 2.0F * (*(p_r0 + 24) + *(p_r1 + 24
			));
		*(p_rrv + 28) = *(p_r3 + 1148) + 2.0F * (*(p_r0 + 28) + *(p_r1 +
			28));
		*(p_rrv + 32) = *(p_r3 + 1312) + 2.0F * (*(p_r0 + 32) + *(p_r1 +
			32));
		*(p_rrv + 36) = *(p_r3 + 1476) + 2.0F * (*(p_r0 + 36) + *(p_r1 +
			36));
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i2;
		ib = i3;
		p_rrv = rrv + i3;
		p_r0 = &rr[i0][i2];
		p_r1 = &rr[i1][i2];
		p_r2 = &rr[i2][i2];
		p_r3 = &rr[i2][i3];
		p_dn0 = dn + i2;
		p_dn1 = dn + i3;
		p_rrv0 = rrv + i3;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r2 + 2.0F * (*p_r0 + *p_r1);
			p_rrv = p_rrv0;
			p_dn = p_dn1;
			p_r4 = p_r3;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r4;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = p_dn0 - dn;
					ib = p_dn - dn;
				}
				p_rrv += 4;
				p_dn += 4;
				p_r4 += 4;
			} while (p_dn < p_dn_max);
			p_dn0 += 4;
			p_r0 += 4;
			p_r1 += 4;
			p_r2 += 164;
			p_r3 += 160;
		} while (p_dn0 <= p_dn_max);
		i2 = ia;
		i3 = ib;

		/* i4 and i5 loop	*/
		p_rrv = rrv + i5;
		p_r0 = &rr[i0][i5];
		p_r1 = &rr[i1][i5];
		p_r2 = &rr[i2][i5];
		p_r3 = &rr[i3][i5];
		p_r5 = &rr[i5][i5];
		*p_rrv = *p_r5 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3);
		*(p_rrv + 4) = *(p_r5 + 164) + 2.0F * (*(p_r0 + 4) + *(p_r1 + 4)
			+ *(p_r2 + 4) + *(p_r3 + 4));
		*(p_rrv + 8) = *(p_r5 + 328) + 2.0F * (*(p_r0 + 8) + *(p_r1 + 8)
			+ *(p_r2 + 8) + *(p_r3 + 8));
		*(p_rrv + 12) = *(p_r5 + 492) + 2.0F * (*(p_r0 + 12) + *(p_r1 + 12
			) + *(p_r2 + 12) + *(p_r3 + 12));
		*(p_rrv + 16) = *(p_r5 + 656) + 2.0F * (*(p_r0 + 16) + *(p_r1 + 16
			) + *(p_r2 + 16) + *(p_r3 + 16));
		*(p_rrv + 20) = *(p_r5 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			) + *(p_r2 + 20) + *(p_r3 + 20));
		*(p_rrv + 24) = *(p_r5 + 984) + 2.0F * (*(p_r0 + 24) + *(p_r1 + 24
			) + *(p_r2 + 24) + *(p_r3 + 24));
		*(p_rrv + 28) = *(p_r5 + 1148) + 2.0F * (*(p_r0 + 28) + *(p_r1 +
			28) + *(p_r2 + 28) + *(p_r3 + 28));
		*(p_rrv + 32) = *(p_r5 + 1312) + 2.0F * (*(p_r0 + 32) + *(p_r1 +
			32) + *(p_r2 + 32) + *(p_r3 + 32));
		*(p_rrv + 36) = *(p_r5 + 1476) + 2.0F * (*(p_r0 + 36) + *(p_r1 +
			36) + *(p_r2 + 36) + *(p_r3 + 36));

		/* Default value */
		ps0 = ps;
		alp0 = alp;
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i4;
		ib = i5;
		p_dn0 = dn + i4;
		p_dn1 = dn + i5;
		p_r0 = &rr[i0][i4];
		p_r1 = &rr[i1][i4];
		p_r2 = &rr[i2][i4];
		p_r3 = &rr[i3][i4];
		p_r4 = &rr[i4][i4];
		p_r5 = &rr[i4][i5];
		p_rrv0 = rrv + i5;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r4 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3);
			p_dn = p_dn1;
			p_r6 = p_r5;
			p_rrv = p_rrv0;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r6;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = p_dn0 - dn;
					ib = p_dn - dn;
				}
				p_dn += 4;
				p_rrv += 4;
				p_r6 += 4;
			} while (p_dn <= p_dn_max);
			p_r0 += 4;
			p_r1 += 4;
			p_r2 += 4;
			p_r3 += 4;
			p_r4 += 164;
			p_r5 += 160;
			p_dn0 += 4;
		} while (p_dn0 < p_dn_max);
		i4 = ia;
		i5 = ib;

		/* i6 and i7 loop	*/
		p_rrv = rrv + i7;
		p_r0 = &rr[i0][i7];
		p_r1 = &rr[i1][i7];
		p_r2 = &rr[i2][i7];
		p_r3 = &rr[i3][i7];
		p_r4 = &rr[i4][i7];
		p_r5 = &rr[i5][i7];
		p_r7 = &rr[i7][i7];
		*p_rrv = *p_r7 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5);
		*(p_rrv + 4) = *(p_r7 + 164) + 2.0F * (*(p_r0 + 4) + *(p_r1 + 4)
			+ *(p_r2 + 4) + *(p_r3 + 4) + *(p_r4 + 4) + *(p_r5 + 4));
		*(p_rrv + 8) = *(p_r7 + 328) + 2.0F * (*(p_r0 + 8) + *(p_r1 + 8)
			+ *(p_r2 + 8) + *(p_r3 + 8) + *(p_r4 + 8) + *(p_r5 + 8));
		*(p_rrv + 12) = *(p_r7 + 492) + 2.0F * (*(p_r0 + 12) + *(p_r1 + 12
			) + *(p_r2 + 12) + *(p_r3 + 12) + *(p_r4 + 12) + *(p_r5 + 12
				));
		*(p_rrv + 16) = *(p_r7 + 656) + 2.0F * (*(p_r0 + 16) + *(p_r1 + 16
			) + *(p_r2 + 16) + *(p_r3 + 16) + *(p_r4 + 16) + *(p_r5 + 16
				));
		*(p_rrv + 20) = *(p_r7 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			) + *(p_r2 + 20) + *(p_r3 + 20) + *(p_r4 + 20) + *(p_r5 + 20
				));
		*(p_rrv + 24) = *(p_r7 + 984) + 2.0F * (*(p_r0 + 24) + *(p_r1 + 24
			) + *(p_r2 + 24) + *(p_r3 + 24) + *(p_r4 + 24) + *(p_r5 + 24
				));
		*(p_rrv + 28) = *(p_r7 + 1148) + 2.0F * (*(p_r0 + 28) + *(p_r1 +
			28) + *(p_r2 + 28) + *(p_r3 + 28) + *(p_r4 + 28) + *(p_r5 +
				28));
		*(p_rrv + 32) = *(p_r7 + 1312) + 2.0F * (*(p_r0 + 32) + *(p_r1 +
			32) + *(p_r2 + 32) + *(p_r3 + 32) + *(p_r4 + 32) + *(p_r5 +
				32));
		*(p_rrv + 36) = *(p_r7 + 1476) + 2.0F * (*(p_r0 + 36) + *(p_r1 +
			36) + *(p_r2 + 36) + *(p_r3 + 36) + *(p_r4 + 36) + *(p_r5 +
				36));

		/* Default value */
		ps0 = ps;
		alp0 = alp;
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i6;
		ib = i7;
		p_dn0 = dn + i6;
		p_dn1 = dn + i7;
		p_r0 = &rr[i0][i6];
		p_r1 = &rr[i1][i6];
		p_r2 = &rr[i2][i6];
		p_r3 = &rr[i3][i6];
		p_r4 = &rr[i4][i6];
		p_r5 = &rr[i5][i6];
		p_r6 = &rr[i6][i6];
		p_r7 = &rr[i6][i7];
		p_rrv0 = rrv + i7;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r6 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
				*p_r5);
			p_dn = p_dn1;
			p_r8 = p_r7;
			p_rrv = p_rrv0;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r8;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = p_dn0 - dn;
					ib = p_dn - dn;
				}
				p_dn += 4;
				p_rrv += 4;
				p_r8 += 4;
			} while (p_dn <= p_dn_max);
			p_r0 += 4;
			p_r1 += 4;
			p_r2 += 4;
			p_r3 += 4;
			p_r4 += 4;
			p_r5 += 4;
			p_r6 += 164;
			p_r7 += 160;
			p_dn0 += 4;
		} while (p_dn0 < p_dn_max);

		/*
		* now finished searching a set of 8 pulses
		* test and memorise if this combination is better than the last one.
		*/
		if ((alpk * sq) >(psk * alp)) {
			psk = sq;
			alpk = alp;
			codvec[0] = (Word16)i0;
			codvec[1] = (Word16)i1;
			codvec[2] = (Word16)i2;
			codvec[3] = (Word16)i3;
			codvec[4] = (Word16)i4;
			codvec[5] = (Word16)i5;
			codvec[6] = (Word16)ia;
			codvec[7] = (Word16)ib;
		}

		/*
		* Cyclic permutation of i1,i2,i3,i4,i5,i6,i7,(i8 and i9).
		*/
		pos = ipos[1];

		for (j = 1, k = 2; k < 8; j++, k++) {
			ipos[j] = ipos[k];
		}
		ipos[7] = pos;
	}   /* end 1..nb_tracks  loop*/
}


/*
* build_code_8i40_31bits
*
*
* Parameters:
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 O: filtered innovative code
*    sign_indx         O: signs of 4  pulses (signs only)
*    pos_indx          O: position index of 8 pulses (position only)
*
* Function:
*    Builds the codeword, the filtered codeword and a
*    linear uncombined version of  the index of the
*    codevector, based on the signs and positions of 8  pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_8i40_31bits(Word32 codvec[], Float32 dn_sign[], Float32
	cod[], Float32 h[], Float32 y[], Word32 sign_indx[], Word32 pos_indx[])
{
	Float64 s;
	Float32 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7;
	Word32 sign[8];
	Word32 i, j, k, track, sign_index, pos_index;


	memset(cod, 0, L_CODE << 2);

	for (i = 0; i < NB_TRACK_MR102; i++) {
		pos_indx[i] = -1;
		sign_indx[i] = -1;
	}

	for (k = 0; k < 8; k++) {
		/* read pulse position */
		i = codvec[k];

		/* read sign */
		j = (Word32)dn_sign[i];

		/* index = pos/4 */
		pos_index = i >> 2;

		/* track = pos%4 */
		track = i & 3;

		if (j > 0) {
			cod[i] = cod[i] + 0.99987792968750F;
			sign[k] = 1;

			/* bit=0 -> positive pulse */
			sign_index = 0;
		}
		else {
			cod[i] = cod[i] - 0.99987792968750F;
			sign[k] = -1;

			/* bit=1 => negative pulse */
			sign_index = 1;
		}

		/* first set first NB_TRACK pulses */
		if (pos_indx[track] < 0) {
			pos_indx[track] = pos_index;
			sign_indx[track] = sign_index;
		}

		/* 2nd row of pulses , test if positions needs to be switched */
		else {
			if (((sign_index ^ sign_indx[track]) & 1) == 0) {
				/* sign of 1st pulse == sign of 2nd pulse */
				if (pos_indx[track] <= pos_index) {
					/* no swap */
					pos_indx[track + NB_TRACK_MR102] = pos_index;
				}
				else {
					/* swap*/
					pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
					pos_indx[track] = pos_index;
					sign_indx[track] = sign_index;
				}
			}
			else {
				/* sign of 1st pulse != sign of 2nd pulse */
				if (pos_indx[track] <= pos_index) {   /*swap*/
					pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
					pos_indx[track] = pos_index;
					sign_indx[track] = sign_index;
				}
				else {
					/*no swap */
					pos_indx[track + NB_TRACK_MR102] = pos_index;
				}
			}
		}
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];
	p2 = h - codvec[2];
	p3 = h - codvec[3];
	p4 = h - codvec[4];
	p5 = h - codvec[5];
	p6 = h - codvec[6];
	p7 = h - codvec[7];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * sign[0];
		s += *p1++ * sign[1];
		s += *p2++ * sign[2];
		s += *p3++ * sign[3];
		s += *p4++ * sign[4];
		s += *p5++ * sign[5];
		s += *p6++ * sign[6];
		s += *p7++ * sign[7];
		y[i] = (Float32)(s);
	}
}


/*
* compress10
*
*
* Parameters:
*    pos_indxA         I: signs of 4 pulses (signs only)
*    pos_indxB         I: position index of 8 pulses (pos only)
*    pos_indxC         I: position and sign of 8 pulses (compressed)
* Function:
*    Compression of three indeces [0..9] to one 10 bit index
*    minimizing the phase shift of a bit error.
*
* Returns:
*    indx
*/
__device__ static Word16 compress10(Word32 pos_indxA, Word32 pos_indxB, Word32
	pos_indxC)
{
	Word32 indx, ia, ib, ic;


	ia = pos_indxA >> 1;
	ib = ((pos_indxB >> 1) * 5);
	ic = ((pos_indxC >> 1) * 25);
	indx = (ia + (ib + ic)) << 3;
	ia = pos_indxA & 1;
	ib = (pos_indxB & 1) << 1;
	ic = (pos_indxC & 1) << 2;
	indx = indx + (ia + (ib + ic));
	return(Word16)indx;
}


/*
* compress_code
*
*
* Parameters:
*    sign_indx         I: signs of 4 pulses (signs only)
*    pos_indx          I: position index of 8 pulses (pos only)
*    indx              O: position and sign of 8 pulses (compressed)
* Function:
*    Compression of the linear codewords to 4+three indeces one bit from each
*    pulse is made robust to errors by minimizing the phase shift of a bit error.
*       4 signs (one for each track)
*       i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
*       i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
*       i3,i7    => one index (5+2) bits, 2-3 LSBs more robust
*
* Returns:
*    void
*/

__device__ static void compress_code(Word32 sign_indx[], Word32 pos_indx[], Word16 indx[]
)
{
	Word32 i, ia, ib, ic;


	for (i = 0; i < NB_TRACK_MR102; i++) {
		indx[i] = (Word16)sign_indx[i];
	}

	/*
	* First index
	* indx[NB_TRACK] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4;
	*/
	indx[NB_TRACK_MR102] = compress10(pos_indx[0], pos_indx[4], pos_indx[1]);

	/*
	* Second index
	* indx[NB_TRACK+1] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4;
	*/
	indx[NB_TRACK_MR102 + 1] = compress10(pos_indx[2], pos_indx[6], pos_indx[5]
	);

	/*
	* Third index
	* if ((ib/2)%2 == 1)
	* indx[NB_TRACK+2] = ((((4-ia/2) + (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
	* else
	* indx[NB_TRACK+2] = ((((ia/2) +   (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
	*/
	ib = (pos_indx[7] >> 1) & 1;

	if (ib == 1)
		ia = 4 - (pos_indx[3] >> 1);
	else
		ia = pos_indx[3] >> 1;
	ib = ((pos_indx[7] >> 1) * 5);
	ib = ((ia + ib) << 5) + 12;
	ic = ((ib * 1311) >> 15) << 2;
	ia = pos_indx[3] & 1;
	ib = (pos_indx[7] & 1) << 1;
	indx[NB_TRACK_MR102 + 2] = (Word16)(ia + (ib + ic));
}


/*
* code_8i40_31bits
*
*
* Parameters:
*    x                 I: target vector
*    cn                I: residual after long term prediction
*    h                 I: impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    code              O: algebraic (fixed) codebook excitation
*    y                 O: filtered fixed codebook excitation
*    anap              O: 7 Word16, index of 8 pulses (signs+positions)
*
* Function:
*    Searches a 31 bit algebraic codebook containing 8 pulses
*    in a frame of 40 samples.
*
*    The code contains 8 nonzero pulses: i0...i7.
*    All pulses can have two possible amplitudes: +1 or -1.
*    The 40 positions in a subframe are divided into 4 tracks of
*    interleaved positions. Each track contains two pulses.
*    The pulses can have the following possible positions:
*
*       i0, i4 :  0, 4, 8,  12, 16, 20, 24, 28, 32, 36
*       i1, i5 :  1, 5, 9,  13, 17, 21, 25, 29, 33, 37
*       i2, i6 :  2, 6, 10, 14, 18, 22, 26, 30, 34, 38
*       i3, i7 :  3, 7, 11, 15, 19, 23, 27, 31, 35, 39
*
*    Each pair of pulses require 1 bit for their signs. The positions
*    are encoded together 3,3 and 2 resulting in
*    (7+3) + (7+3) + (5+2) bits for their
*    positions. This results in a 31 (4 sign and 27 pos) bit codebook.
*    The function determines the optimal pulse signs and positions, builds
*    the codevector, and computes the filtered codevector.
*
* Returns:
*    void
*/
__device__ static void code_8i40_31bits(Float32 x[], Float32 cn[], Float32 h[],
	Word32 T0, Float32 pitch_sharp, Float32 code[],
	Float32 y[], Word16 anap[])
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], sign[L_CODE];
	Word32 ipos[8], pos_max[NB_TRACK_MR102], codvec[8], linear_signs[
		NB_TRACK_MR102], linear_codewords[8];
		Word32 i;

		if (pitch_sharp > 1.0F)
			pitch_sharp = 1.0F;

		/* include pitch contribution into impulse resp. */
		if (pitch_sharp != 0) {
			for (i = T0; i < L_SUBFR; i++) {
				h[i] += h[i - T0] * pitch_sharp;
			}
		}

		cor_h_x(h, x, dn);
		set_sign12k2(dn, cn, sign, pos_max, NB_TRACK_MR102, ipos, STEP_MR102);
		cor_h(h, sign, rr);
		search_8i40(dn, rr, ipos, pos_max, codvec);
		build_code_8i40_31bits(codvec, sign, code, h, y, linear_signs,
			linear_codewords);
		compress_code(linear_signs, linear_codewords, anap);

		/* Add the pitch contribution to code[]. */
		if (pitch_sharp != 0) {
			for (i = T0; i < L_SUBFR; i++) {
				code[i] += code[i - T0] * pitch_sharp;
			}
		}
		return;
}


/*
* search_10i40
*
*
* Parameters:
*    dn                I: correlation between target and h[]
*    rr                I: matrix of autocorrelation
*    ipos              I: starting position for each pulse
*    pos_max           I: maximum of correlation position
*    codvec            O: algebraic codebook vector
*
* Function:
*    Search the best codevector; determine positions of the 10
*    pulses in the 40-sample frame.
*
*    First, for each of the five tracks the pulse positions with maximum
*    absolute values of b(n) are searched. From these the global maximum value
*    for all the pulse positions is selected. The first pulse i0 is always set
*    into the position corresponding to the global maximum value.
*    Next, four iterations are carried out. During each iteration the position
*    of pulse i1 is set to the local maximum of one track.
*    The rest of the pulses are searched in pairs by sequentially searching
*    each of the pulse pairs {i2,i3}, {i4,i5}, {i6,i7} and {i8,i9}
*    in nested loops. Every pulse has 8 possible positions, i.e., there are
*    four 8x8-loops, resulting in 256 different combinations of
*    pulse positions for each iteration. In each iteration all the 9 pulse
*    starting positions are cyclically shifted, so that the pulse pairs are
*    changed and the pulse i1 is placed in a local maximum of
*    a different track. The rest of the pulses are searched also for
*    the other positions in the tracks. At least one pulse is located in
*    a position corresponding to the global maximum and one pulse is
*    located in a position corresponding to one of the 4 local maxima.
*
* Returns:
*    void
*/
__device__ static void search_10i40(Float32 dn[], Float32 rr[][L_CODE], Word32 ipos[],
	Word32 pos_max[], Word32 codvec[])
{
	Float32 rrv[L_CODE];
	Float32 psk, ps, ps0, ps1, ps2, sq, sq2, alpk, alp, alp0, alp1, alp2;
	Float32 *p_r, *p_r0, *p_r1, *p_r2, *p_r3, *p_r4, *p_r5, *p_r6, *p_r7, *p_r8,
		*p_r9, *p_r10;
	Float32 *p_rrv, *p_rrv0, *p_dn, *p_dn0, *p_dn1, *p_dn_max;
	Word32 i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, j, k, ia, ib, i, pos;

	p_dn_max = &dn[39];

	/* fix i0 on maximum of correlation position */
	i0 = pos_max[ipos[0]];
	ia = ib = 0;
	ps = 0;

	/* i1 loop */
	psk = -1;
	alpk = 1;

	for (i = 0; i < 10; i++) {
		codvec[i] = i;
	}
	p_r = &rr[i0][i0];

	for (i = 1; i < 5; i++) {
		i1 = pos_max[ipos[1]];
		i2 = ipos[2];
		i3 = ipos[3];
		i4 = ipos[4];
		i5 = ipos[5];
		i6 = ipos[6];
		i7 = ipos[7];
		i8 = ipos[8];
		i9 = ipos[9];
		ps0 = dn[i0] + dn[i1];
		alp0 = *p_r + rr[i1][i1] + 2.0F * rr[i0][i1];

		/* i2 and i3 loop	*/
		p_rrv = &rrv[i3];
		p_r0 = &rr[i0][i3];
		p_r1 = &rr[i1][i3];
		p_r3 = &rr[i3][i3];
		*p_rrv = *p_r3 + 2.0F * (*p_r0 + *p_r1);
		*(p_rrv + 5) = *(p_r3 + 205) + 2.0F * (*(p_r0 + 5) + *(p_r1 + 5)
			);
		*(p_rrv + 10) = *(p_r3 + 410) + 2.0F * (*(p_r0 + 10) + *(p_r1 + 10
			));
		*(p_rrv + 15) = *(p_r3 + 615) + 2.0F * (*(p_r0 + 15) + *(p_r1 + 15
			));
		*(p_rrv + 20) = *(p_r3 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			));
		*(p_rrv + 25) = *(p_r3 + 1025) + 2.0F * (*(p_r0 + 25) + *(p_r1 +
			25));
		*(p_rrv + 30) = *(p_r3 + 1230) + 2.0F * (*(p_r0 + 30) + *(p_r1 +
			30));
		*(p_rrv + 35) = *(p_r3 + 1435) + 2.0F * (*(p_r0 + 35) + *(p_r1 +
			35));
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i2;
		ib = i3;
		p_rrv = rrv + i3;
		p_r0 = &rr[i0][i2];
		p_r1 = &rr[i1][i2];
		p_r2 = &rr[i2][i2];
		p_r3 = &rr[i2][i3];
		p_dn0 = dn + i2;
		p_dn1 = dn + i3;
		p_rrv0 = rrv + i3;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r2 + 2.0F * (*p_r0 + *p_r1);
			p_rrv = p_rrv0;
			p_dn = p_dn1;
			p_r4 = p_r3;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r4;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = (Word16)(p_dn0 - dn);
					ib = (Word16)(p_dn - dn);
				}
				p_rrv += 5;
				p_dn += 5;
				p_r4 += 5;
			} while (p_dn < p_dn_max);
			p_dn0 += 5;
			p_r0 += 5;
			p_r1 += 5;
			p_r2 += 205;
			p_r3 += 200;
		} while (p_dn0 <= p_dn_max);
		i2 = ia;
		i3 = ib;

		/* i4 and i5 loop	*/
		p_rrv = rrv + i5;
		p_r0 = &rr[i0][i5];
		p_r1 = &rr[i1][i5];
		p_r2 = &rr[i2][i5];
		p_r3 = &rr[i3][i5];
		p_r5 = &rr[i5][i5];
		*p_rrv = *p_r5 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3);
		*(p_rrv + 5) = *(p_r5 + 205) + 2.0F * (*(p_r0 + 5) + *(p_r1 + 5)
			+ *(p_r2 + 5) + *(p_r3 + 5));
		*(p_rrv + 10) = *(p_r5 + 410) + 2.0F * (*(p_r0 + 10) + *(p_r1 + 10
			) + *(p_r2 + 10) + *(p_r3 + 10));
		*(p_rrv + 15) = *(p_r5 + 615) + 2.0F * (*(p_r0 + 15) + *(p_r1 + 15
			) + *(p_r2 + 15) + *(p_r3 + 15));
		*(p_rrv + 20) = *(p_r5 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			) + *(p_r2 + 20) + *(p_r3 + 20));
		*(p_rrv + 25) = *(p_r5 + 1025) + 2.0F * (*(p_r0 + 25) + *(p_r1 +
			25) + *(p_r2 + 25) + *(p_r3 + 25));
		*(p_rrv + 30) = *(p_r5 + 1230) + 2.0F * (*(p_r0 + 30) + *(p_r1 +
			30) + *(p_r2 + 30) + *(p_r3 + 30));
		*(p_rrv + 35) = *(p_r5 + 1435) + 2.0F * (*(p_r0 + 35) + *(p_r1 +
			35) + *(p_r2 + 35) + *(p_r3 + 35));

		/* Default value */
		ps0 = ps;
		alp0 = alp;
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i4;
		ib = i5;
		p_dn0 = dn + i4;
		p_dn1 = dn + i5;
		p_r0 = &rr[i0][i4];
		p_r1 = &rr[i1][i4];
		p_r2 = &rr[i2][i4];
		p_r3 = &rr[i3][i4];
		p_r4 = &rr[i4][i4];
		p_r5 = &rr[i4][i5];
		p_rrv0 = rrv + i5;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r4 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3);
			p_dn = p_dn1;
			p_r6 = p_r5;
			p_rrv = p_rrv0;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r6;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = (Word16)(p_dn0 - dn);
					ib = (Word16)(p_dn - dn);
				}
				p_dn += 5;
				p_rrv += 5;
				p_r6 += 5;
			} while (p_dn <= p_dn_max);
			p_r0 += 5;
			p_r1 += 5;
			p_r2 += 5;
			p_r3 += 5;
			p_r4 += 205;
			p_r5 += 200;
			p_dn0 += 5;
		} while (p_dn0 < p_dn_max);
		i4 = ia;
		i5 = ib;

		/* i6 and i7 loop	*/
		p_rrv = rrv + i7;
		p_r0 = &rr[i0][i7];
		p_r1 = &rr[i1][i7];
		p_r2 = &rr[i2][i7];
		p_r3 = &rr[i3][i7];
		p_r4 = &rr[i4][i7];
		p_r5 = &rr[i5][i7];
		p_r7 = &rr[i7][i7];
		*p_rrv = *p_r7 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5);
		*(p_rrv + 5) = *(p_r7 + 205) + 2.0F * (*(p_r0 + 5) + *(p_r1 + 5)
			+ *(p_r2 + 5) + *(p_r3 + 5) + *(p_r4 + 5) + *(p_r5 + 5));
		*(p_rrv + 10) = *(p_r7 + 410) + 2.0F * (*(p_r0 + 10) + *(p_r1 + 10
			) + *(p_r2 + 10) + *(p_r3 + 10) + *(p_r4 + 10) + *(p_r5 + 10
				));
		*(p_rrv + 15) = *(p_r7 + 615) + 2.0F * (*(p_r0 + 15) + *(p_r1 + 15
			) + *(p_r2 + 15) + *(p_r3 + 15) + *(p_r4 + 15) + *(p_r5 + 15
				));
		*(p_rrv + 20) = *(p_r7 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			) + *(p_r2 + 20) + *(p_r3 + 20) + *(p_r4 + 20) + *(p_r5 + 20
				));
		*(p_rrv + 25) = *(p_r7 + 1025) + 2.0F * (*(p_r0 + 25) + *(p_r1 +
			25) + *(p_r2 + 25) + *(p_r3 + 25) + *(p_r4 + 25) + *(p_r5 +
				25));
		*(p_rrv + 30) = *(p_r7 + 1230) + 2.0F * (*(p_r0 + 30) + *(p_r1 +
			30) + *(p_r2 + 30) + *(p_r3 + 30) + *(p_r4 + 30) + *(p_r5 +
				30));
		*(p_rrv + 35) = *(p_r7 + 1435) + 2.0F * (*(p_r0 + 35) + *(p_r1 +
			35) + *(p_r2 + 35) + *(p_r3 + 35) + *(p_r4 + 35) + *(p_r5 +
				35));

		/* Default value */
		ps0 = ps;
		alp0 = alp;
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i6;
		ib = i7;
		p_dn0 = dn + i6;
		p_dn1 = dn + i7;
		p_r0 = &rr[i0][i6];
		p_r1 = &rr[i1][i6];
		p_r2 = &rr[i2][i6];
		p_r3 = &rr[i3][i6];
		p_r4 = &rr[i4][i6];
		p_r5 = &rr[i5][i6];
		p_r6 = &rr[i6][i6];
		p_r7 = &rr[i6][i7];
		p_rrv0 = rrv + i7;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r6 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
				*p_r5);
			p_dn = p_dn1;
			p_r8 = p_r7;
			p_rrv = p_rrv0;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r8;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = (Word16)(p_dn0 - dn);
					ib = (Word16)(p_dn - dn);
				}
				p_dn += 5;
				p_rrv += 5;
				p_r8 += 5;
			} while (p_dn <= p_dn_max);
			p_r0 += 5;
			p_r1 += 5;
			p_r2 += 5;
			p_r3 += 5;
			p_r4 += 5;
			p_r5 += 5;
			p_r6 += 205;
			p_r7 += 200;
			p_dn0 += 5;
		} while (p_dn0 < p_dn_max);
		i6 = ia;
		i7 = ib;

		/* i8 and i9 loop	*/
		p_rrv = rrv + i9;
		p_r0 = &rr[i0][i9];
		p_r1 = &rr[i1][i9];
		p_r2 = &rr[i2][i9];
		p_r3 = &rr[i3][i9];
		p_r4 = &rr[i4][i9];
		p_r5 = &rr[i5][i9];
		p_r6 = &rr[i6][i9];
		p_r7 = &rr[i7][i9];
		p_r9 = &rr[i9][i9];
		*p_rrv = *p_r9 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 + *p_r5 +
			*p_r6 + *p_r7);
		*(p_rrv + 5) = *(p_r9 + 205) + 2.0F * (*(p_r0 + 5) + *(p_r1 + 5)
			+ *(p_r2 + 5) + *(p_r3 + 5) + *(p_r4 + 5) + *(p_r5 + 5) + *(
				p_r6 + 5) + *(p_r7 + 5));
		*(p_rrv + 10) = *(p_r9 + 410) + 2.0F * (*(p_r0 + 10) + *(p_r1 + 10
			) + *(p_r2 + 10) + *(p_r3 + 10) + *(p_r4 + 10) + *(p_r5 + 10
				) + *(p_r6 + 10) + *(p_r7 + 10));
		*(p_rrv + 15) = *(p_r9 + 615) + 2.0F * (*(p_r0 + 15) + *(p_r1 + 15
			) + *(p_r2 + 15) + *(p_r3 + 15) + *(p_r4 + 15) + *(p_r5 + 15
				) + *(p_r6 + 15) + *(p_r7 + 15));
		*(p_rrv + 20) = *(p_r9 + 820) + 2.0F * (*(p_r0 + 20) + *(p_r1 + 20
			) + *(p_r2 + 20) + *(p_r3 + 20) + *(p_r4 + 20) + *(p_r5 + 20
				) + *(p_r6 + 20) + *(p_r7 + 20));
		*(p_rrv + 25) = *(p_r9 + 1025) + 2.0F * (*(p_r0 + 25) + *(p_r1 +
			25) + *(p_r2 + 25) + *(p_r3 + 25) + *(p_r4 + 25) + *(p_r5 +
				25) + *(p_r6 + 25) + *(p_r7 + 25));
		*(p_rrv + 30) = *(p_r9 + 1230) + 2.0F * (*(p_r0 + 30) + *(p_r1 +
			30) + *(p_r2 + 30) + *(p_r3 + 30) + *(p_r4 + 30) + *(p_r5 +
				30) + *(p_r6 + 30) + *(p_r7 + 30));
		*(p_rrv + 35) = *(p_r9 + 1435) + 2.0F * (*(p_r0 + 35) + *(p_r1 +
			35) + *(p_r2 + 35) + *(p_r3 + 35) + *(p_r4 + 35) + *(p_r5 +
				35) + *(p_r6 + 35) + *(p_r7 + 35));

		/* Default value */
		ps0 = ps;
		alp0 = alp;
		sq = -1;
		alp = 1;
		ps = 0;
		ia = i8;
		ib = i9;
		p_dn0 = dn + i8;
		p_dn1 = dn + i9;
		p_r0 = &rr[i0][i8];
		p_r1 = &rr[i1][i8];
		p_r2 = &rr[i2][i8];
		p_r3 = &rr[i3][i8];
		p_r4 = &rr[i4][i8];
		p_r5 = &rr[i5][i8];
		p_r6 = &rr[i6][i8];
		p_r7 = &rr[i7][i8];
		p_r8 = &rr[i8][i8];
		p_r9 = &rr[i8][i9];
		p_rrv0 = rrv + i9;

		do {
			ps1 = ps0 + *p_dn0;
			alp1 = alp0 + *p_r8 + 2.0F * (*p_r0 + *p_r1 + *p_r2 + *p_r3 + *p_r4 +
				*p_r5 + *p_r6 + *p_r7);
			p_dn = p_dn1;
			p_r10 = p_r9;
			p_rrv = p_rrv0;

			do {
				ps2 = ps1 + *p_dn;
				sq2 = ps2 * ps2;
				alp2 = alp1 + *p_rrv + 2.0F * *p_r10;

				if ((alp * sq2) > (sq * alp2)) {
					sq = sq2;
					ps = ps2;
					alp = alp2;
					ia = (Word16)(p_dn0 - dn);
					ib = (Word16)(p_dn - dn);
				}
				p_dn += 5;
				p_rrv += 5;
				p_r10 += 5;
			} while (p_dn <= p_dn_max);
			p_r0 += 5;
			p_r1 += 5;
			p_r2 += 5;
			p_r3 += 5;
			p_r4 += 5;
			p_r5 += 5;
			p_r6 += 5;
			p_r7 += 5;
			p_r8 += 205;
			p_r9 += 200;
			p_dn0 += 5;
		} while (p_dn0 < p_dn_max);

		/*
		* test and memorise if this combination is better than the last one.
		*/
		if ((alpk * sq) >(psk * alp)) {
			psk = sq;
			alpk = alp;
			codvec[0] = (Word16)i0;
			codvec[1] = (Word16)i1;
			codvec[2] = (Word16)i2;
			codvec[3] = (Word16)i3;
			codvec[4] = (Word16)i4;
			codvec[5] = (Word16)i5;
			codvec[6] = (Word16)i6;
			codvec[7] = (Word16)i7;
			codvec[8] = (Word16)ia;
			codvec[9] = (Word16)ib;
		}

		/*
		* Cyclic permutation of i1,i2,i3,i4,i5,i6,i7,(i8 and i9).
		*/
		pos = ipos[1];

		for (j = 1, k = 2; k < 10; j++, k++) {
			ipos[j] = ipos[k];
		}
		ipos[9] = pos;
	}   /* end 1..nb_tracks  loop*/
}


/*
* build_code_10i40_35bits
*
*
* Parameters:
*    codvec            I: position of pulses
*    dn_sign           I: sign of pulses
*    cod               O: algebraic codebook vector
*    h                 I: impulse response of weighted synthesis filter
*    y                 O: filtered innovative code
*    indx              O: index of 10 pulses (sign+position)
*
* Function:
*    Builds the codeword, the filtered codeword and index of the
*    codevector, based on the signs and positions of 10 pulses.
*
* Returns:
*    void
*/
__device__ static void build_code_10i40_35bits(Word32 codvec[], Float32 dn_sign[], Float32
	cod[], Float32 h[], Float32 y[], Word16 indx[])
{
	Word32 i, j, k, track, index, sign[10];
	Float32 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9;
	Float64 s;


	memset(cod, 0, 160);
	memset(y, 0, 160);

	for (i = 0; i < NB_TRACK; i++) {
		indx[i] = -1;
	}

	for (k = 0; k < 10; k++) {
		/* read pulse position */
		i = codvec[k];

		/* read sign */
		j = (Word16)dn_sign[i];

		/* index = pos/5 */
		index = (Word16)(i / 5);

		/* track = pos%5 */
		track = (Word16)(i % 5);

		if (j > 0) {
			cod[i] = cod[i] + 1;
			sign[k] = 1;
		}
		else {
			cod[i] = cod[i] - 1;
			sign[k] = -1;
			index = index + 8;
		}

		if (indx[track] < 0) {
			indx[track] = (Word16)index;
		}
		else {
			if (((index ^ indx[track]) & 8) == 0) {
				/* sign of 1st pulse == sign of 2nd pulse */
				if (indx[track] <= index) {
					indx[track + 5] = (Word16)index;
				}
				else {
					indx[track + 5] = (Word16)indx[track];
					indx[track] = (Word16)index;
				}
			}
			else {
				/* sign of 1st pulse != sign of 2nd pulse */
				if ((indx[track] & 7) <= (index & 7)) {
					indx[track + 5] = (Word16)indx[track];
					indx[track] = (Word16)index;
				}
				else {
					indx[track + 5] = (Word16)index;
				}
			}
		}
	}
	p0 = h - codvec[0];
	p1 = h - codvec[1];
	p2 = h - codvec[2];
	p3 = h - codvec[3];
	p4 = h - codvec[4];
	p5 = h - codvec[5];
	p6 = h - codvec[6];
	p7 = h - codvec[7];
	p8 = h - codvec[8];
	p9 = h - codvec[9];

	for (i = 0; i < L_CODE; i++) {
		s = *p0++ * sign[0];
		s += *p1++ * sign[1];
		s += *p2++ * sign[2];
		s += *p3++ * sign[3];
		s += *p4++ * sign[4];
		s += *p5++ * sign[5];
		s += *p6++ * sign[6];
		s += *p7++ * sign[7];
		s += *p8++ * sign[8];
		s += *p9++ * sign[9];
		y[i] = (Float32)(s);
	}
}


/*
* q_p
*
*
* Parameters:
*    ind               B: Pulse position
*    n                 I: Pulse number
*
* Function:
*    Gray coding
*
* Returns:
*    void
*/
__device__ static void q_p(Word16 *ind, Word32 n)
{
	Word16 tmp;


	tmp = *ind;

	if (n < 5) {
		*ind = (Word16)((tmp & 0x8) | gray[tmp & 0x7]);
	}
	else {
		*ind = gray[tmp & 0x7];
	}
}


/*
* code_10i40_35bits
*
*
* Parameters:
*    x                 I: target vector
*    cn                I: residual after long term prediction
*    h                 I: impulse response of weighted synthesis filter
*    gain_pit          I: quantified adaptive codebook gain
*    code              O: algebraic (fixed) codebook excitation
*    y                 O: filtered fixed codebook excitation
*    anap              O: 7 Word16, index of 8 pulses (signs+positions)
*
* Function:
*    Searches a 35 bit algebraic codebook containing 10 pulses
*    in a frame of 40 samples.
*
*    The code contains 10 nonzero pulses: i0...i9.
*    All pulses can have two possible amplitudes: +1 or -1.
*    The 40 positions in a subframe are divided into 5 tracks of
*    interleaved positions. Each track contains two pulses.
*    The pulses can have the following possible positions:
*       Track    Pulse       Positions
*          1     i0, i5      0, 5, 10, 15, 20, 25, 30, 35.
*          2     i1, i6      1, 6, 11, 16, 21, 26, 31, 36.
*          3     i2, i       2, 7, 12, 17, 22, 27, 32, 37.
*          4     i3, i8      3, 8, 13, 18, 23, 28, 33, 38.
*          5     i4, i9      4, 9, 14, 19, 24, 29, 34, 39.
*
*    Each pair of pulses require 1 bit for their signs and 6 bits for their
*    positions (3 bits + 3 bits). This results in a 35 bit codebook.
*    The function determines the optimal pulse signs and positions, builds
*    the codevector, and computes the filtered codevector.
*
*    The algebraic codebook is searched by minimizing the mean square error
*    between the weighted input speech and the weighted synthesized speech.
*    The target signal used in the closed-loop pitch search is updated by
*    subtracting the adaptive codebook contribution. That is:
*
*    x2(n) = x(n) - Gp' * y(n), n = 0, ..., 39
*
*    where y(n) = v(n) * h(n) is the filtered adaptive codebook vector
*    and Gp' is the quantified adaptive codebook gain. This is done
*    already in function cl_ltp.
*
*    If c(k) is the algebraic codevector at index k, then
*    the algebraic codebook is searched by maximizing the term:
*
*    A(k) = (C(k) * C(k)) / Ed(k) =
*
*                     39
*                   [SUM sb(i)*d(i)]^2
*                    i=0
*                  ---------------------
*                 transpose(sb) * PI * sb
*
*    where d(n) is the correlation between the target signal x2(n)
*    and the impulse response h(n), H is a the lower triangular Toepliz
*    convolution matrix with diagonal h(0) and lower diagonals
*    h(1), ..., h(39), and PI = H_transpose * H is the matrix of
*    correlations of h(n).
*
*    The pulse amplitudes are preset by the mere quantization of an signal
*    b(n) used for presetting the amplitudes.
*
*                           39
*    b(n) = res(n) / SQRT[ SUM[ res(i) * res(i) ] ]
*                          i=0
*                          39
*          + d(n) / SQRT[ SUM [ d(i) * d(i) ] ], n = 0, ..., 39,
*                         i=0
*
*    where res(n) is normalized long-term prediction residual and
*    d(n) is normalized vector.
*
*            39
*    d(n) = SUM[ x2(i) * h(i-n) ], n = 0, ..., 39,
*           i=n
*
*    This is simply done by setting the amplitude of a pulse at
*    a certain position equal to the sign of b(n) at that position.
*    The simplification proceeds as follows (prior to the codebook search).
*    First, the sign signal sb(n) = SIGN[ b(n) ] and
*    the signal d'(n) = sb(n) * d(n) are computed.
*
* Returns:
*    void
*/
__device__ static void code_10i40_35bits(Float32 x[], Float32 cn[], Float32 h[],
	Word32 T0, Float32 gain_pit, Float32 code[],
	Float32 y[], Word16 anap[])
{
	Float32 rr[L_CODE][L_CODE];
	Float32 dn[L_CODE], sign[L_CODE];
	Word32 ipos[10], pos_max[NB_TRACK], codvec[10];
	Word32 i;

	/* include pitch contribution into impulse resp. */
	if (gain_pit > 1.0F)
		gain_pit = 1.0F;

	if (gain_pit != 0) {
		for (i = T0; i < L_SUBFR; i++) {
			h[i] += h[i - T0] * gain_pit;
		}
	}
	/*
	*            39
	*    d(n) = SUM[ x2(i) * h(i-n) ], n = 0, ..., 39
	*           i=n
	*/
	cor_h_x(h, x, dn);

	/* sb(n) and d'(n) */
	set_sign12k2(dn, cn, sign, pos_max, NB_TRACK, ipos, STEP);

	/* Matrix of correlations */
	cor_h(h, sign, rr);
	search_10i40(dn, rr, ipos, pos_max, codvec);
	build_code_10i40_35bits(codvec, sign, code, h, y, anap);

	for (i = 0; i < 10; i++) {
		q_p(&anap[i], i);
	}

	/*  Add the pitch contribution to code[]. */
	if (gain_pit != 0) {
		for (i = T0; i < L_SUBFR; i++) {
			code[i] += code[i - T0] * gain_pit;
		}
	}
	return;
}


/*
* cbsearch
*
*
* Parameters:
*    mode              I: AMR mode
*    subnr             I: Subframe
*    x                 I: Target vector
*    h                 B: Impulse response of weighted synthesis filter
*    T0                I: Pitch lag
*    pitch_sharp       I: Last quantized pitch gain
*    gain_pit          I: Algebraic codebook gain
*    code              O: Innovative codebook
*    y                 O: Filtered fixed codebook excitation
*    res2              I: residual after long term prediction
*    anap              O: Signs and positions of the pulses
*
* Function:
*    Innovative codebook search (find index and gain)
*
* Returns:
*    void
*/
__device__ static void cbsearch(enum Mode mode, Word16 subnr, Float32 x[],
	Float32 h[], Word32 T0, Float32 pitch_sharp,
	Float32 gain_pit, Float32 code[], Float32 y[],
	Float32 *res2, Word16 **anap)
{
	switch (mode) {
	case MR475:
	case MR515:
		code_2i40_9bits(subnr, x, h, T0, pitch_sharp, code, y, *anap);
		(*anap) += 2;
		break;
	case MR59:
		code_2i40_11bits(x, h, T0, pitch_sharp, code, y, *anap);
		(*anap) += 2;
		break;
	case MR67:
		code_3i40_14bits(x, h, T0, pitch_sharp, code, y, *anap);
		(*anap) += 2;
		break;
	case MR74:
	case MR795:
		code_4i40_17bits(x, h, T0, pitch_sharp, code, y, *anap);
		(*anap) += 2;
		break;
	case MR102:
		code_8i40_31bits(x, res2, h, T0, pitch_sharp, code, y, *anap);
		*anap += 7;
		break;
	default:
		code_10i40_35bits(x, res2, h, T0, gain_pit, code, y, *anap);
		*anap += 10;
	}
}

/*
* Log2_norm
*
*
* Parameters:
*    x                 I: input value
*    exp               I: exponent
*    exponent          O: Integer part of Log2. (range: 0<=val<=30)
*    fraction          O: Fractional part of Log2. (range: 0<=val<1)
*
* Function:
*    Computes log2
*
*    Computes log2(L_x, exp),  where   L_x is positive and
*    normalized, and exp is the normalisation exponent
*    If L_x is negative or zero, the result is 0.
*
*    The function Log2(L_x) is approximated by a table and linear
*    interpolation. The following steps are used to compute Log2(L_x)
*
*    exponent = 30-normExponent
*    i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
*    a = bit10-b24
*    i -=32
*    fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
*
* Returns:
*    void
*/
__device__ static void Log2_norm(Word32 x, Word32 exp, Word32 *exponent, Word32 *
	fraction)
{
	Word32 y, i, a;

	if (x <= 0) {
		*exponent = 0;
		*fraction = 0;
		return;
	}

	/* Extract b25-b31 */
	i = x >> 25;
	i = i - 32;

	/* Extract b10-b24 of fraction */
	a = x >> 9;
	a = a & 0xFFFE;   /* 2a */

					  /* fraction */
	y = (log2_table[i] << 16) - a * (log2_table[i] - log2_table[i + 1]);
	*fraction = y >> 16;
	*exponent = 30 - exp;
	return;
}

/*
* Log2
*
*
* Parameters:
*    x                 I: input value
*    exponent          O: Integer part of Log2. (range: 0<=val<=30)
*    fraction          O: Fractional part of Log2. (range: 0<=val<1)
*
* Function:
*    Computes log2(L_x)
*    If x is negative or zero, the result is 0.
*
* Returns:
*    void
*/
__device__ static void Log2(Word32 x, Word32 *exponent, Word32 *fraction)
{
	int exp;


	frexp((Float64)x, &exp);
	exp = 31 - exp;
	Log2_norm(x << exp, exp, exponent, fraction);
}

/*
* Pow2
*
*
* Parameters:
*    exponent          I: Integer part. (range: 0<=val<=30)
*    fraction          O: Fractional part. (range: 0.0<=val<1.0)
*
* Function:
*    pow(2.0, exponent.fraction)
*
*    The function Pow2(L_x) is approximated by a table and linear interpolation.
*
*    i = bit10-b15 of fraction, 0 <= i <= 31
*    a = biT0-b9   of fraction
*    x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
*    x = L_x >> (30-exponent) (with rounding)
*
* Returns:
*    result (range: 0<=val<=0x7fffffff)
*/
__device__ static Word32 Pow2(Word32 exponent, Word32 fraction)
{
	Word32 i, a, tmp, x, exp;

	/* Extract b10-b16 of fraction */
	i = fraction >> 10;

	/* Extract b0-b9 of fraction */
	a = (fraction << 5) & 0x7fff;

	/* table[i] << 16 */
	x = pow2_table[i] << 16;

	/* table[i] - table[i+1] */
	tmp = pow2_table[i] - pow2_table[i + 1];

	/* L_x -= tmp*a*2 */
	x -= (tmp * a) << 1;

	if (exponent >= -1) {
		exp = (30 - exponent);

		/* Rounding */
		if ((x & ((Word32)1 << (exp - 1))) != 0) {
			x = (x >> exp) + 1;
		}
		else
			x = x >> exp;
	}
	else
		x = 0;
	return(x);
}

/*
* gc_pred
*
*
* Parameters:
*    past_qua_en       I: MA predictor
*    mode              I: AMR mode
*    code              I: innovative codebook vector
*    gcode0            O: predicted gain factor
*    en                I: innovation energy (only calculated for MR795)
*
* Function:
*    MA prediction of the innovation energy
*
*    Mean removed innovation energy (dB) in subframe n
*                          N-1
*    E(n) = 10*log(gc*gc * SUM[(code(i) * code(i)]/N) - E_mean
*                          i=0
*    N=40
*
*    Mean innovation energy (dB)
*                   N-1
*    Ei(n) = 10*log(SUM[(code(i) * code(i)]/N)
*                   i=0
*
*    Predicted energy
*             4
*    Ep(n) = SUM[b(i) * R(n-i)]
*            i=1
*    b = [0.68 0.58 0.34 0.19]
*    R(k) is quantified prediction error at subframe k
*
*    E_Mean = 36 dB (MR122)
*
*    Predicted gain gc is found by
*
*    gc = POW[10, 0.05 * (Ep(n) + E_mean - Ei)]
*
* Returns:
*    void
*/
__device__ static void gc_pred(Word32 *past_qua_en, enum Mode mode, Float32 *code,
	Word32 *gcode0_exp, Word32 *gcode0_fra, Float32 *en)
{
	Float64 ener_code;
	Word32 exp, frac, ener, ener_tmp, tmp;
	int exp_code;


	/* energy of code */
	ener_code = Dotproduct40(code, code);

	if (mode == MR122) {

		ener = (Word32)(ener_code * 33554432);
		/* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
		ener = ((ener + 0x00008000L) >> 16) * 52428;

		Log2(ener, &exp, &frac);
		ener = ((exp - 30) << 16) + (frac << 1);

		ener_tmp = 44 * qua_gain_code_MR122[past_qua_en[0]];
		ener_tmp += 37 * qua_gain_code_MR122[past_qua_en[1]];
		ener_tmp += 22 * qua_gain_code_MR122[past_qua_en[2]];
		ener_tmp += 12 * qua_gain_code_MR122[past_qua_en[3]];

		ener_tmp = ener_tmp << 1;
		ener_tmp += 783741L;

		/*
		* predicted codebook gain
		* gc0 = Pow10( (ener*constant - ener_code*constant) / 20 )
		*     = Pow2(ener-ener_code)
		*     = Pow2(int(d)+frac(d))
		*/
		ener = (ener_tmp - ener) >> 1;   /* Q16 */
		*gcode0_exp = ener >> 16;
		*gcode0_fra = (ener >> 1) - (*gcode0_exp << 15);
	}
	else {
		ener = (Word32)(ener_code * 134217728);
		if (ener < 0)
			ener = 0x7fffffff;

		frexp((Float64)ener, &exp_code);
		exp_code = 31 - exp_code;
		ener <<= exp_code;

		Log2_norm(ener, exp_code, &exp, &frac);

		tmp = (exp * (-49320)) + (((frac * (-24660)) >> 15) << 1);

		if (mode == MR102) {
			/* mean = 33 dB */
			tmp += 2134784;   /* Q14 */
		}
		else if (mode == MR795) {
			/* mean = 36 dB */
			tmp += 2183936;   /* Q14 */

			*en = (Float32)ener_code;
		}
		else if (mode == MR74) {
			/* mean = 30 dB */
			tmp += 2085632;   /* Q14 */
		}
		else if (mode == MR67) {
			/* mean = 28.75 dB */
			tmp += 2065152;   /* Q14 */
		}
		else /* MR59, MR515, MR475 */ {
			/* mean = 33 dB */
			tmp += 2134784;   /* Q14 */
		}

		tmp = tmp << 9;

		tmp += 5571 * qua_gain_code[past_qua_en[0]];
		tmp += 4751 * qua_gain_code[past_qua_en[1]];
		tmp += 2785 * qua_gain_code[past_qua_en[2]];
		tmp += 1556 * qua_gain_code[past_qua_en[3]];

		tmp = tmp >> 15;   /* Q8  */

						   /*
						   * gcode0 = pow(10.0, gcode0/20)
						   *        = pow(2, 3.3219*gcode0/20)
						   *        = pow(2, 0.166*gcode0)
						   */
						   /* 5439 Q15 = 0.165985                                        */
						   /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
						   /* For IS641 bitexactness */
		if (mode == MR74) {
			/* Q8 * Q15 -> Q24 */
			tmp = tmp * 10878;
		}
		else {
			/* Q8 * Q15 -> Q24 */
			tmp = tmp * 10886;
		}
		tmp = tmp >> 9;   /* -> Q15 */

		*gcode0_exp = tmp >> 15;
		*gcode0_fra = tmp - (*gcode0_exp * 32768);
	}
}

/*
* calc_filt_energies
*
*
* Parameters:
*    mode              I: AMR mode
*    xn                I: LTP target vector
*    xn2               I: CB target vector
*    y1                I: Adaptive codebook
*    y2                I: Filtered innovative vector
*    gCoeff            I: Correlations <xn y1> <y1 y1>
*    coeff             O: energy coefficients
*    cod_gain          O: optimum codebook gain
*
* Function:
*    Calculation of several energy coefficients for filtered excitation signals
*
*    Compute coefficients need for the quantization and the optimum
*    codebook gain gcu (for MR475 only).
*
*       coeff[0] =    y1 y1
*       coeff[1] = -2 xn y1
*       coeff[2] =    y2 y2
*       coeff[3] = -2 xn y2
*       coeff[4] =  2 y1 y2
*
*
*       gcu = <xn2, y2> / <y2, y2> (0 if <xn2, y2> <= 0)
*
*    Product <y1 y1> and <xn y1> have been computed in G_pitch() and
*    are in vector gCoeff[].
*
* Returns:
*    void
*/
__device__ static void calc_filt_energies(enum Mode mode, Float32 xn[], Float32 xn2[],
	Float32 y1[], Float32 y2[], Float32 gCoeff[], Float32 coeff[], Float32 *
	cod_gain)
{
	Float32 sum, ener_init = 0.01F;


	if ((mode == MR795) || (mode == MR475))
		ener_init = 0;
	coeff[0] = gCoeff[0];
	coeff[1] = -2.0F * gCoeff[1];

	/* Compute scalar product <y2[],y2[]> */
	sum = (Float32)Dotproduct40(y2, y2);
	sum += ener_init;
	coeff[2] = sum;

	/* Compute scalar product -2*<xn[],y2[]> */
	sum = (Float32)Dotproduct40(xn, y2);
	sum += ener_init;
	coeff[3] = -2.0F * sum;

	/* Compute scalar product 2*<y1[],y2[]> */
	sum = (Float32)Dotproduct40(y1, y2);
	sum += ener_init;
	coeff[4] = 2.0F * sum;

	if ((mode == MR475) || (mode == MR795)) {
		/* Compute scalar product <xn2[],y2[]> */
		sum = (Float32)Dotproduct40(xn2, y2);

		if (sum <= 0) {
			*cod_gain = 0;
		}
		else {
			/*
			* gcu = <xn2, y2> / <y2, y2>
			*/
			*cod_gain = sum / coeff[2];
		}
	}
}


/*
* MR475_update_unq_pred
*
*
* Parameters:
*    past_qua_en       I: MA predictor memory, 20*log10(qua_err)
*    gcode0            I: predicted CB gain
*    cod_gain          I: optimum codebook gain
*
* Function:
*    Use optimum codebook gain and update "unquantized"
*    gain predictor with the (bounded) prediction error
*
*    Prediction error is given by:
*
*       R(n) = E(n) - E_pred(n) = 20 * log(cf),
*
*    where correction factor cf between the gain Gc and
*    the estimated pne Gc' is given by:
*
*       cf = Gc/Gc'.
*
* Returns:
*    void
*/
__device__ static void MR475_update_unq_pred(Word32 *past_qua_en, Float32 gcode0, Float32
	cod_gain)
{
	Float32 qua_ener, pred_err_fact;
	Word32 i, index, energy, max, s;


	if (cod_gain <= 0) {
		/*MIN_QUA_ENER*/
		qua_ener = -32.0F;
	}
	else {
		if (gcode0 != 0) {
			pred_err_fact = cod_gain / gcode0;
		}
		else {
			pred_err_fact = 10.0F;
		}

		if (pred_err_fact < 0.0251189F) {
			/*MIN_QUA_ENER*/
			qua_ener = -32.0F;
		}
		else if (pred_err_fact > 7.8125F) {
			/*MAX_QUA_ENER*/
			qua_ener = 17.8558F;
		}
		else {
			qua_ener = (Float32)(20.0F*log10(pred_err_fact));
		}
	}
	energy = (Word32)(qua_ener * 1024 + 0.5F);
	max = abs(energy - qua_gain_code[0]);
	index = 0;
	/* find match from table */
	for (i = 1; i < NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + MR475_VQ_SIZE * 2 + 3; i++)
	{
		s = abs(energy - qua_gain_code[i]);
		if (s < max) {
			max = s;
			index = i;
			if (s == 0) {
				break;
			}
		}
	}
	/* update MA predictor memory */
	for (i = 3; i > 0; i--) {
		past_qua_en[i] = past_qua_en[i - 1];
	}
	past_qua_en[0] = index;
}


/*
* MR475_gain_quant
*
*
* Parameters:
*    past_qua_en          B: MA predictor memory, 20*log10(qua_err)
*    sf0_gcode0_exp(fra)  I: predicted CB gain from subframe 0 (or 2)
*    sf0_coeff            I: energy coeff. from subframe 0 (or 2)
*    sf0_target_en        I: target energy from subframe 0 (or 2)
*    sf1_code_nosharp     I: innovative codebook vector (L_SUBFR)
*                            (without pitch sharpening)
*                            from subframe 1 (or 3)
*    sf1_gcode0_exp(fra)  I: predicted CB gain from subframe 1 (or 3)
*    sf1_coeff            I: energy coeff. subframe 1 (or 3)
*    sf1_target_en        I: target energy from subframe 1 (or 3)
*    gp_limit             I: pitch gain limit
*    sf0_gain_pit         O: Pitch gain subframe 0 (or 2)
*    sf0_gain_cod         O: Code gain subframe 0 (or 2)
*    sf1_gain_pit         O: Pitch gain subframe 1 (or 3)
*    sf1_gain_cod         O: Code gain subframe 1 (or 3)
*
* Function:
*    Quantization of pitch and codebook gains for two subframes
*    (using predicted codebook gain)
*
* Returns:
*    index             index of quantization
*/
__device__ static Word16 MR475_gain_quant(Word32 *past_qua_en, Word32 sf0_gcode0_exp, Word32
	sf0_gcode0_fra, Float32 sf0_coeff[], Float32 sf0_target_en,
	Float32 sf1_code_nosharp[], Word32 sf1_gcode0_exp, Word32
	sf1_gcode0_fra, Float32 sf1_coeff[], Float32 sf1_target_en,
	Float32 gp_limit, Float32 *sf0_gain_pit, Float32
	*sf0_gain_cod, Float32 *sf1_gain_pit, Float32 *sf1_gain_cod)
{
	Float32 temp, temp2, g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, dist_min, sf0_gcode0, sf1_gcode0;
	const Float32 *p;
	Word32 i, tmp, g_code_tmp, gcode0, index = 0;

	sf0_gcode0 = (Float32)Pow2(sf0_gcode0_exp, sf0_gcode0_fra);
	sf1_gcode0 = (Float32)Pow2(sf1_gcode0_exp, sf1_gcode0_fra);

	if ((sf0_target_en * 2.0F) < sf1_target_en) {
		sf0_coeff[0] *= 2.0F;
		sf0_coeff[1] *= 2.0F;
		sf0_coeff[2] *= 2.0F;
		sf0_coeff[3] *= 2.0F;
		sf0_coeff[4] *= 2.0F;
	}
	else if (sf0_target_en > (sf1_target_en * 4.0F)) {
		sf1_coeff[0] *= 2.0F;
		sf1_coeff[1] *= 2.0F;
		sf1_coeff[2] *= 2.0F;
		sf1_coeff[3] *= 2.0F;
		sf1_coeff[4] *= 2.0F;
	}

	/*
	* Codebook search:
	* For each pair (g_pitch, g_fac) in the table calculate the
	* terms t[0..4] and sum them up; the result is the mean squared
	* error for the quantized gains from the table. The index for the
	* minimum MSE is stored and finally used to retrieve the quantized
	* gains
	*/
	dist_min = FLT_MAX;
	p = &table_gain_MR475[0];

	for (i = 0; i < MR475_VQ_SIZE; i++) {
		/* subframe 0 (and 2) calculations */
		g_pitch = *p++;
		g_code = *p++;
		g_code *= sf0_gcode0;
		g2_pitch = g_pitch * g_pitch;
		g2_code = g_code * g_code;
		g_pit_cod = g_code * g_pitch;
		temp = sf0_coeff[0] * g2_pitch;
		temp += sf0_coeff[1] * g_pitch;
		temp += sf0_coeff[2] * g2_code;
		temp += sf0_coeff[3] * g_code;
		temp += sf0_coeff[4] * g_pit_cod;
		temp2 = g_pitch - gp_limit;

		/* subframe 1 (and 3) calculations */
		g_pitch = *p++;
		g_code = *p++;

		if (temp2 <= 0 && (g_pitch <= gp_limit)) {
			g_code *= sf1_gcode0;
			g2_pitch = g_pitch * g_pitch;
			g2_code = g_code * g_code;
			g_pit_cod = g_code * g_pitch;
			temp += sf1_coeff[0] * g2_pitch;
			temp += sf1_coeff[1] * g_pitch;
			temp += sf1_coeff[2] * g2_code;
			temp += sf1_coeff[3] * g_code;
			temp += sf1_coeff[4] * g_pit_cod;

			/*
			* store table index if MSE for this index is lower
			* than the minimum MSE seen so far
			*/
			if (temp < dist_min) {
				dist_min = temp;
				index = i;
			}
		}
	}

	/*
	*  read quantized gains and update MA predictor memories
	*
	* for subframe 0, the pre-calculated gcode0 is the same
	* as one calculated from the "real" predictor using quantized gains
	*/
	tmp = index << 2;
	p = &table_gain_MR475[tmp];
	*sf0_gain_pit = *p++;
	g_code_tmp = (Word32)(*p++ * 4096 + 0.5F);

	gcode0 = Pow2(14, sf0_gcode0_fra);
	if (sf0_gcode0_exp < 11) {
		*sf0_gain_cod = (Float32)((g_code_tmp * gcode0) >> (25 - sf0_gcode0_exp));
	}
	else {
		i = ((g_code_tmp * gcode0) << (sf0_gcode0_exp - 9));

		if ((i >> (sf0_gcode0_exp - 9)) != (g_code_tmp * gcode0)) {
			*sf0_gain_cod = (Float32)0x7FFF;
		}
		else {
			*sf0_gain_cod = (Float32)(i >> 16);
		}
	}

	*sf0_gain_cod *= 0.5F;

	for (i = 3; i > 0; i--) {
		past_qua_en[i] = past_qua_en[i - 1];
	}
	past_qua_en[0] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (index << 1);


	/*
	* calculate new predicted gain for subframe 1 (this time using
	* the real, quantized gains)
	*/
	gc_pred(past_qua_en, MR475, sf1_code_nosharp, &sf1_gcode0_exp, &sf1_gcode0_fra, &sf0_gcode0);

	tmp += 2;
	p = &table_gain_MR475[tmp];
	*sf1_gain_pit = *p++;
	g_code_tmp = (Word32)(*p++ * 4096 + 0.5F);

	gcode0 = Pow2(14, sf1_gcode0_fra);
	if (sf1_gcode0_exp < 11) {
		*sf1_gain_cod = (Float32)((g_code_tmp * gcode0) >> (25 - sf1_gcode0_exp));
	}
	else {
		i = ((g_code_tmp * gcode0) << (sf1_gcode0_exp - 9));

		if ((i >> (sf1_gcode0_exp - 9)) != (g_code_tmp * gcode0)) {
			*sf1_gain_cod = (Float32)0x7FFF;
		}
		else {
			*sf1_gain_cod = (Float32)(i >> 16);
		}
	}

	*sf1_gain_cod *= 0.5F;

	for (i = 3; i > 0; i--) {
		past_qua_en[i] = past_qua_en[i - 1];
	}
	past_qua_en[0] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (index << 1) + 1;

	return(Word16)index;
}


/*
* q_gain_code
*
*
* Parameters:
*    gcode0            I: predicted CB gain
*    gain              B: quantized fixed codebook gain
*    qua_ener_index    O: quantized energy error index
*
* Function:
*    Scalar quantization of the innovative codebook gain.
*
*    A correction factor between the gain gc and the estimated one gc'
*    is given by:
*
*    cf = gc/gc'
*
*    The quantization table search is performed by minimizing the error:
*
*    Eq = POW[gc - cf' * gc', 2]
*
*    Once the optimum value cf' is chosen,
*    the quantified fixed codebook gain is given by
*
*    gc_q = cf' * gc'
*
* Returns:
*    index             quantization index
*/
__device__ static Word16 q_gain_code(Float32 gcode0, Float32 *gain, Word32 *qua_ener_index)
{
	Float64 err_min, err;
	const Float32 *p;
	Word32 i, index;


	p = &gain_factor[0];

	/* using abs instead pow */
	err_min = fabs(*gain - (gcode0 * *p++));
	index = 0;

	for (i = 1; i < NB_QUA_CODE; i++) {
		err = fabs(*gain - (gcode0 * *p++));

		if (err < err_min) {
			err_min = err;
			index = i;
		}
	}
	p = &gain_factor[index];
	*gain = (Float32)floor(gcode0 * *p);
	*qua_ener_index = index;

	return(Word16)index;
}


/*
* MR795_gain_code_quant3
*
*
* Parameters:
*    gcode0            I: Predicted CB gain
*    g_pitch_cand      I: Pitch gain candidates (3)
*    g_pitch_cind      I: Pitch gain cand. indices (3)
*    coeff             I: Energy coefficients
*    gain_pit          O: Pitch gain
*    gain_pit_ind      O: Pitch gain index
*    gain_cod          O: Code gain
*    gain_cod_ind      O: Code gain index
*    qua_ener_index    O: quantized energy error index
*
* Function:
*    Pre-quantization of codebook gains, given three possible
*    LTP gains (using predicted codebook gain)
*
* Returns:
*    void
*/
__device__ static void MR795_gain_code_quant3(Word32 gcode0_exp, Word32 gcode0_fra, Float32 g_pitch_cand[],
	Word32 g_pitch_cind[], Float32 coeff[], Float32 *gain_pit, Word32 *
	gain_pit_ind, Float32 *gain_cod, Word32 *gain_cod_ind, Word32 *qua_ener_index)
{
	Float32 gcode0, dist_min, g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, tmp0, tmp;
	const Float32 *p;
	Word32 i, j, cod_ind, pit_ind, g_code0, g_code_tmp;

	gcode0 = (Float32)Pow2(gcode0_exp, gcode0_fra);
	/*
	* The error energy (sum) to be minimized consists of five terms, t[0..4].
	*
	* t[0] =    gp^2  * <y1 y1>
	* t[1] = -2*gp    * <xn y1>
	* t[2] =    gc^2  * <y2 y2>
	* t[3] = -2*gc    * <xn y2>
	* t[4] =  2*gp*gc * <y1 y2>
	*/
	/*
	* Codebook search:
	* For each of the candiates LTP gains in g_pitch_cand[], the terms
	* t[0..4] are calculated from the values in the table (and the
	* pitch gain candidate) and summed up; the result is the mean
	* squared error for the LPT/CB gain pair. The index for the mini-
	* mum MSE is stored and finally used to retrieve the quantized CB
	* gain
	*/
	dist_min = FLT_MAX;
	cod_ind = 0;
	pit_ind = 0;

	/* loop through LTP gain candidates */
	for (j = 0; j < 3; j++) {
		/* pre-calculate terms only dependent on pitch gain */
		g_pitch = g_pitch_cand[j];
		g2_pitch = g_pitch * g_pitch;
		tmp0 = coeff[0] * g2_pitch;
		tmp0 += coeff[1] * g_pitch;
		p = &gain_factor[0];

		for (i = 0; i < NB_QUA_CODE; i++) {
			/* this is g_fac */
			g_code = *p++;
			g_code = g_code * gcode0;
			g2_code = g_code * g_code;
			g_pit_cod = g_code * g_pitch;
			tmp = tmp0 + coeff[2] * g2_code;
			tmp += coeff[3] * g_code;
			tmp += coeff[4] * g_pit_cod;

			/*
			* store table index if MSE for this index is lower
			* than the minimum MSE seen so far; also store the
			* pitch gain for this (so far) lowest MSE
			*/
			if (tmp < dist_min) {
				dist_min = tmp;
				cod_ind = i;
				pit_ind = j;
			}
		}
	}

	/*
	*  read quantized gains and new values for MA predictor memories
	*/
	p = &gain_factor[cod_ind];
	g_code_tmp = (Word32)(2048 * *p);
	*qua_ener_index = cod_ind;

	/*
	*  calculate final fixed codebook gain:
	*   gc = gc0 * g
	*/
	g_code0 = Pow2(14, gcode0_fra);
	i = (g_code_tmp * g_code0) << 1;
	gcode0_exp = 9 - gcode0_exp;

	if (gcode0_exp > 0)
		i = i >> gcode0_exp;
	else
		i = i << (-gcode0_exp);
	*gain_cod = (Float32)(i >> 16);
	if (*gain_cod > 32767)
		*gain_cod = 32767;

	*gain_cod *= 0.5F;

	*gain_cod_ind = (Word16)cod_ind;
	*gain_pit = g_pitch_cand[pit_ind];
	*gain_pit_ind = g_pitch_cind[pit_ind];
}


/*
* calc_unfilt_energies
*
*
* Parameters:
*    res               I: LP residual
*    exc               I: LTP excitation (unfiltered)
*    code              I: CB innovation (unfiltered)
*    gain_pit          I: pitch gain
*    en                O: energy coefficients [4]
*    ltpg              O: LTP coding gain (log2())
*
* Function:
*    Calculation of several energy coefficients for unfiltered
*    excitation signals and the LTP coding gain
*
*    en[0] = <res res>    LP residual energy
*    en[1] = <exc exc>    LTP residual energy
*    en[2] = <exc code>   LTP/CB innovation dot product
*    en[3] = <lres lres>  LTP residual energy
*                         (lres = res - gain_pit*exc)
*    ltpg = log2(LP_res_en / LTP_res_en)
*
* Returns:
*    void
*/
__device__ static void calc_unfilt_energies(Float32 res[], Float32 exc[], Float32 code[],
	Float32 gain_pit, Float32 en[], Float32 *ltpg)
{
	Float32 sum, pred_gain;
	Word32 i;


	/* Compute residual energy */
	en[0] = (Float32)Dotproduct40(res, res);

	/* ResEn := 0 if ResEn < 200.0 */
	if (en[0] < 200) {
		en[0] = 0;
	}

	/* Compute ltp excitation energy */
	en[1] = (Float32)Dotproduct40(exc, exc);

	/* Compute scalar product <exc[],code[]> */
	en[2] = (Float32)Dotproduct40(exc, code);

	/* Compute energy of LTP residual */
	en[3] = 0;

	for (i = 0; i < L_SUBFR; i++) {
		/* LTP residual */
		sum = res[i] - (exc[i] * gain_pit);
		en[3] += sum * sum;
	}

	/* calculate LTP coding gain, i.e. energy reduction LP res -> LTP res */
	if (en[3] > 0 && en[0] != 0) {
		/* gain = ResEn / LTPResEn */
		pred_gain = en[0] / en[3];
		*ltpg = (Float32)(log10(pred_gain) / log10(2.0));
	}
	else {
		*ltpg = 0;
	}
}


/*
* gmed_n_f
*
*
* Parameters:
*    ind               I: values
*    n                 I: The number of gains
*
* Function:
*    Calculates N-point median (float).
*
* Returns:
*    index of the median value
*/
__device__ static Float32 gmed_n_f(Float32 ind[], Word16 n)
{
	Word32 medianIndex;
	Word32 i, j, ix = 0;
	Word32 tmp[9];
	Float32 tmp2[9];
	Float32 max;


	for (i = 0; i < n; i++) {
		tmp2[i] = ind[i];
	}

	for (i = 0; i < n; i++) {
		max = -FLT_MAX;

		for (j = 0; j < n; j++) {
			if (tmp2[j] >= max) {
				max = tmp2[j];
				ix = j;
			}
		}
		tmp2[ix] = -FLT_MAX;
		tmp[i] = ix;
	}
	medianIndex = tmp[n >> 1];
	return(ind[medianIndex]);
}


/*
* gain_adapt
*
*
* Parameters:
*    prev_gc           B: previous code gain
*    onset             B: onset indicator
*    ltpg_mem          B: stored past LTP coding gains
*    prev_alpha        B: revious gain adaptation factor
*    ltpg              I: ltp coding gain (log2())
*    gain_cod          I: code gain
*    alpha             O: gain adaptation factor
*
* Function:
*    Calculate pitch/codebook gain adaptation factor alpha
*    (and update the adaptor state)
*
*    If the coding gain ag is less than 1 dB, the modified criterion is
*    employed, except when an onset is detected. An onset is said to be
*    detected if the fixed codebook gain in the current subframe is more
*    than twice the value of the fixed codebook gain in the previous
*    subframe. A hangover of 8 subframes is used in the onset detection
*    so that the modified criterion is not used for the next 7 subframes
*    either if an onset is detected. The balance factor a is computed from
*    the median filtered adaptive coding gain. The current and
*    the ag-values for the previous 4 subframes are median filtered to get
*    agm. The  a-factor is computed by:
*
*          /  0                       ,  2 < agm
*       a =   0.5 * (1 - 0.5 * agm)   ,  0 < agm < 2
*          \  0.5                     ,      agm < 0
*
* Returns:
*    void
*/
__device__ static void gain_adapt(Float32 *prev_gc, Word16 *onset, Float32 *ltpg_mem,
	Float32 *prev_alpha, Float32 ltpg, Float32 gain_cod, Float32 *alpha)
{
	Float32 result, filt;   /* alpha factor, median-filtered LTP coding gain */
	Word32 i;
	Word16 adapt;   /* adaptdation status; 0, 1, or 2 */


					/* basic adaptation */
	if (ltpg <= 0.3321928F /*LTP_GAIN_THR1*/) {
		adapt = 0;
	}
	else {
		if (ltpg <= 0.6643856 /*LTP_GAIN_THR2*/) {
			adapt = 1;
		}
		else {
			adapt = 2;
		}
	}

	/*
	* onset indicator:
	*/
	if ((gain_cod > 2.0F * *prev_gc) && (gain_cod > 100)) {
		*onset = 8;
	}
	else {
		if (*onset != 0) {
			(*onset)--;
		}
	}

	/*
	* if onset, increase adaptor state
	*/
	if ((*onset != 0) && (adapt < 2)) {
		adapt++;
	}
	ltpg_mem[0] = ltpg;
	filt = gmed_n_f(ltpg_mem, 5);

	if (adapt == 0) {
		if (filt > 0.66443) {
			result = 0;
		}
		else {
			if (filt < 0) {
				result = 0.5;
			}
			else {
				result = (Float32)(0.5 - 0.75257499*filt);
			}
		}
	}
	else {
		result = 0;
	}

	/*
	* if (prev_alpha == 0.0) result = 0.5 * (result + prev_alpha);
	*/
	if (*prev_alpha == 0) {
		result = 0.5F * result;
	}

	/* store the result */
	*alpha = result;

	/* update adapter state memory */
	*prev_alpha = result;
	*prev_gc = gain_cod;

	for (i = LTPG_MEM_SIZE - 1; i > 0; i--) {
		ltpg_mem[i] = ltpg_mem[i - 1];
	}

	/* mem[0] is just present for convenience in calling the gmed_n[5]
	* function above. The memory depth is really LTPG_MEM_SIZE-1.
	*/
}


/*
* MR795_gain_code_quant_mod
*
*
* Parameters:
*    gain_pit          I: Pitch gain
*    gcode0            I: Predicted CB gain
*    en                I: energy coefficients
*    alpha             I: gain adaptation factor
*    gain_cod_unq      I: Code gain (unquantized)
*    gain_cod          I: Code gain
*    qua_ener_index    O: quantized energy error index
*
* Function:
*   Modified quantization of the MR795 codebook gain
*
*   Uses pre-computed energy coefficients in frac_en[]/exp_en[]
*
*   frac_en[0]*2^exp_en[0] = <res res>     LP residual energy
*   frac_en[1]*2^exp_en[1] = <exc exc>     LTP residual energy
*   frac_en[2]*2^exp_en[2] = <exc code>    LTP/CB innovation dot product
*   frac_en[3]*2^exp_en[3] = <code code>   CB innovation energy
*
* Returns:
*    index             codebook index
*/
__device__ static Word16 MR795_gain_code_quant_mod(Float32 gain_pit, Word32 gcode0_exp, Word32 gcode0_fra,
	Float32 en[], Float32 alpha, Float32 gain_cod_unq, Float32 *gain_cod,
	Word32 *qua_ener_index)
{
	Float32 coeff[5];
	Float32 gcode0, g2_pitch, g_code, g2_code, d2_code, dist_min, gain_code, tmp;
	const Float32 *p;
	Word32 i, index, g_code_tmp, g_code0;

	gcode0 = (Float32)Pow2(gcode0_exp, gcode0_fra);

	gain_code = *gain_cod;
	g2_pitch = gain_pit * gain_pit;
	coeff[0] = (Float32)(sqrt(alpha * en[0]));
	coeff[1] = alpha * en[1] * g2_pitch;
	coeff[2] = 2.0F * alpha * en[2] * gain_pit;
	coeff[3] = alpha * en[3];
	coeff[4] = (1.0F - alpha) * en[3];

	/* search the quantizer table for the lowest value of the search criterion */
	dist_min = FLT_MAX;
	index = 0;
	p = &gain_factor[0];

	for (i = 0; i < NB_QUA_CODE; i++) {
		/* this is g_fac */
		g_code = *p++;
		g_code = g_code * gcode0;

		/*
		* only continue if gc[i] < 2.0*gc
		*/
		if (g_code >= (2.0F * gain_code))
			break;
		g2_code = g_code * g_code;
		d2_code = g_code - gain_cod_unq;
		d2_code = d2_code * d2_code;
		tmp = coeff[1] + coeff[2] * g_code;
		tmp += coeff[3] * g2_code;
		tmp = (Float32)sqrt(tmp);
		tmp = tmp - coeff[0];
		tmp = tmp * tmp;
		tmp += coeff[4] * d2_code;

		/*
		* store table index if distance measure for this
		* index is lower than the minimum seen so far
		*/
		if (tmp < dist_min) {
			dist_min = tmp;
			index = i;
		}
	}

	/*
	*  read quantized gains and new values for MA predictor memories
	*/
	p = &gain_factor[index];
	g_code_tmp = (Word32)(2048 * *p);
	*qua_ener_index = index;

	/* calculate final fixed codebook gain:
	* gc = gc0 * g
	*/
	g_code0 = Pow2(14, gcode0_fra);
	i = (g_code_tmp * g_code0) << 1;
	gcode0_exp = 9 - gcode0_exp;

	if (gcode0_exp > 0)
		i = i >> gcode0_exp;
	else
		i = i << (-gcode0_exp);
	*gain_cod = (Float32)(i >> 16);
	if (*gain_cod > 32767)
		*gain_cod = 32767;

	*gain_cod *= 0.5F;
	return(Word16)index;
}


/*
* MR795_gain_quant
*
*
* Parameters:
*    prev_gc           B: previous code gain
*    onset             B: onset indicator
*    ltpg_mem          B: stored past LTP coding gains
*    prev_alpha        B: previous gain adaptation factor
*    res               I: LP residual
*    exc               I: LTP excitation (unfiltered)
*    code              I: CB innovation (unfiltered)
*    coeff             I: energy coefficients (5)
*    code_en           I: innovation energy
*    gcode0            I: predicted CB gain
*    cod_gain          I: codebook gain
*    gp_limit          I: pitch gain limit
*    gain_pit          B: Pitch gain
*    gain_cod          O: Code gain
*    qua_ener          O: quantized energy error
*    anap              O: Index of quantization
*    gain_pit          I: Pitch gain
*    gcode0            I: Predicted CB gain
*    en                I: energy coefficients
*    alpha             I: gain adaptation factor
*    gain_cod_unq      I: Code gain (unquantized)
*    gain_cod          I: Code gain
*    qua_ener          O: quantized energy error_index
*
* Function:
*    Pitch and codebook quantization for MR795
*
* Returns:
*    void
*/
__device__ static void MR795_gain_quant(Float32 *prev_gc, Word16 *onset, Float32 *ltpg_mem
	, Float32 *prev_alpha, Float32 res[], Float32 exc[], Float32 code[],
	Float32 coeff[], Float32 code_en, Word32 gcode0_exp, Word32 gcode0_fra, Float32 cod_gain,
	Float32 gp_limit, Float32 *gain_pit, Float32 *gain_cod, Word32 *qua_ener_index,
	Word16 **anap)
{
	Float32 en[4], g_pitch_cand[3];
	Float32 ltpg, alpha, gain_cod_unq;   /* code gain (unq.) */
	Word32 g_pitch_cind[3];   /* pitch gain indices */
	Word32 gain_pit_index, gain_cod_index;


	/*
	* get list of candidate quantized pitch gain values
	* and corresponding quantization indices
	*/
	gain_pit_index = q_gain_pitch(MR795, gp_limit, gain_pit, g_pitch_cand,
		g_pitch_cind);

	/*
	* pre-quantization of codebook gain
	* (using three pitch gain candidates);
	* result: best guess of pitch gain and code gain
	*/
	MR795_gain_code_quant3(gcode0_exp, gcode0_fra, g_pitch_cand, g_pitch_cind, coeff, gain_pit,
		&gain_pit_index, gain_cod, &gain_cod_index, qua_ener_index);

	/* calculation of energy coefficients and LTP coding gain */
	calc_unfilt_energies(res, exc, code, *gain_pit, en, &ltpg);

	/*
	* run gain adaptor, calculate alpha factor to balance LTP/CB gain
	* (this includes the gain adaptor update)
	*/
	gain_adapt(prev_gc, onset, ltpg_mem, prev_alpha, ltpg, *gain_cod, &alpha);

	/*
	* if this is a very low energy signal (threshold: see
	* calc_unfilt_energies) or alpha <= 0 then don't run the modified quantizer
	*/
	if ((en[0] != 0) && (alpha > 0)) {
		/*
		* innovation energy <cod cod> was already computed in gc_pred()
		* (this overwrites the LtpResEn which is no longer needed)
		*/
		en[3] = code_en;

		/*
		* store optimum codebook gain
		*/
		gain_cod_unq = cod_gain;

		/* run quantization with modified criterion */
		gain_cod_index = MR795_gain_code_quant_mod(*gain_pit, gcode0_exp, gcode0_fra, en, alpha,
			gain_cod_unq, gain_cod, qua_ener_index);
	}
	*(*anap)++ = (Word16)gain_pit_index;
	*(*anap)++ = (Word16)gain_cod_index;
}


/*
* Qua_gain
*
*
* Parameters:
*    mode              I: AMR mode
*    gcode0            I: predicted CB gain
*    coeff             I: energy coefficients (5)
*    gp_limit          I: pitch gain limit
*    gain_pit          O: Pitch gain
*    gain_cod          O: Code gain
*    qua_ener_index    O: quantized energy error index
*
* Function:
*    Quantization of pitch and codebook gains (using predicted codebook gain)
*
* Returns:
*    index             index of quantization
*/
__device__ static Word16 Qua_gain(enum Mode mode, Word32 gcode0_exp, Word32 gcode0_fra, Float32 coeff[], Float32
	gp_limit, Float32 *gain_pit, Float32 *gain_cod, Word32 *qua_ener_index)
{
	Float32 g_pitch, g2_pitch, g_code, g2_code, g_pit_cod, tmp, dist_min, gcode0;
	const Float32 *table_gain, *p;
	Word32 i, index = 0, gcode_0, g_code_tmp;
	Word16 table_len;

	gcode0 = (Float32)Pow2(gcode0_exp, gcode0_fra);


	if ((mode == MR102) || (mode == MR74) || (mode == MR67)) {
		table_len = VQ_SIZE_HIGHRATES;
		table_gain = table_highrates;
		*qua_ener_index = NB_QUA_CODE;
	}
	else {
		table_len = VQ_SIZE_LOWRATES;
		table_gain = table_lowrates;
		*qua_ener_index = NB_QUA_CODE + VQ_SIZE_HIGHRATES;
	}

	/*
	* Codebook search:
	* For each pair (g_pitch, g_fac) in the table calculate the
	* terms t[0..4] and sum them up; the result is the mean squared
	* error for the quantized gains from the table. The index for the
	* minimum MSE is stored and finally used to retrieve the quantized
	* gains
	*/
	dist_min = FLT_MAX;
	p = &table_gain[0];

	for (i = 0; i < table_len; i++) {
		g_pitch = *p++;

		/* this is g_fac */
		g_code = *p++;

		if (g_pitch <= gp_limit) {
			g_code *= gcode0;
			g2_pitch = g_pitch * g_pitch;
			g2_code = g_code * g_code;
			g_pit_cod = g_code * g_pitch;
			tmp = coeff[0] * g2_pitch;
			tmp += coeff[1] * g_pitch;
			tmp += coeff[2] * g2_code;
			tmp += coeff[3] * g_code;
			tmp += coeff[4] * g_pit_cod;

			/*
			* store table index if MSE for this index is lower
			* than the minimum MSE seen so far
			*/
			if (tmp < dist_min) {
				dist_min = tmp;
				index = i;
			}
		}
	}

	/*
	* read quantized gains and new values for MA predictor memories
	*/
	p = &table_gain[index << 1];
	*gain_pit = *p++;
	g_code_tmp = (Word32)(4096 * *p);

	/*
	* calculate final fixed codebook gain:
	* gc = gc0 * g
	*/

	gcode_0 = Pow2(14, gcode0_fra);
	if (gcode0_exp < 11) {
		*gain_cod = (Float32)((g_code_tmp * gcode_0) >> (25 - gcode0_exp));
	}
	else {
		i = ((g_code_tmp * gcode_0) << (gcode0_exp - 9));

		if ((i >> (gcode0_exp - 9)) != (g_code_tmp * gcode_0)) {
			*gain_cod = 0x7FFF;
		}
		else {
			*gain_cod = (Float32)(i >> 16);
		}
	}
	*gain_cod = *gain_cod * 0.5F;
	*qua_ener_index += index;

	return(Word16)index;
}


/*
* gainQuant
*
*
* Parameters:
*    gcode0            I: predicted CB gain
*    coeff             I: energy coefficients (5)
*    gp_limit          I: pitch gain limit
*    gain_pit          O: Pitch gain
*    gain_cod          O: Code gain
*    qua_ener          O: quantized energy error,
*    mode              I: AMR mode
*    even_subframe     I: even subframe indicator flag
*    past_qua_en       B: past quantized energies [4]
*    past_qua_en_unq   B: past energies [4]
*    sf0_coeff         B: energy coefficients subframe 0 (or 2)
*    sf0_target_en     B: target energy from subframe 0 (or 2)
*    sf0_gcode0        B: predicted gain factor subframe 0 (or 2)
*    gain_idx_ptr      B: gain index pointer
*    sf0_gain_pit      B: Pitch gain subframe 0 (or 2)
*    sf0_gain_cod      B: Code gain subframe 0 (or 2)
*    res               I: LP residual
*    exc               I: LTP excitation (unfiltered)
*    code              I: innovative codebook vector
*    xn                I: Target vector
*    xn2               I: CB target vector
*    y1                I: Adaptive codebook
*    y2                I: Filtered innovative vector
*    gCoeff            I: Correlations <xn y1> <y1 y1>
*    gp_limit          I: pitch gain limit
*    gain_pit          O: Pitch gain
*    gain_cod          O: Code gain
*    prev_gc           B: B: previous code gain
*    onset             B: onset indicator
*    ltpg_mem          B: stored past LTP coding gains
*    prev_alpha        B: previous gain adaptation factor
*    anap              B: Index of quantization
*
* Function:
*    Quantization of gains
*
* Returns:
*    index             index of quantization
*/
__device__ static void gainQuant(enum Mode mode, Word32 even_subframe, Word32 *
	past_qua_en, Word32 *past_qua_en_unq, Float32 *sf0_coeff, Float32 *
	sf0_target_en, Word32 *sf0_gcode0_exp, Word32 *sf0_gcode0_fra, Word16 **gain_idx_ptr, Float32 *
	sf0_gain_pit, Float32 *sf0_gain_cod, Float32 *res, Float32 *exc, Float32
	code[], Float32 xn[], Float32 xn2[], Float32 y1[], Float32 y2[], Float32
	gCoeff[], Float32 gp_limit, Float32 *gain_pit, Float32 *gain_cod, Float32
	*prev_gc, Word16 *onset, Float32 *ltpg_mem, Float32 *prev_alpha, Word16 **
	anap)
{
	Float32 coeff[5];
	Float32 gcode0, cod_gain, en = 0;
	Word32 i, exp, frac, qua_ener_index;


	if (mode == MR475) {
		if (even_subframe != 0) {
			/*
			* save position in output parameter stream and current
			* state of codebook gain predictor
			*/
			*gain_idx_ptr = (*anap)++;
			past_qua_en_unq[0] = past_qua_en[0];
			past_qua_en_unq[1] = past_qua_en[1];
			past_qua_en_unq[2] = past_qua_en[2];
			past_qua_en_unq[3] = past_qua_en[3];

			/*
			* predict codebook gain (using "unquantized" predictor)
			* (note that code[] is unsharpened in MR475)
			*/
			gc_pred(past_qua_en, mode, code, sf0_gcode0_exp, sf0_gcode0_fra, &en);
			gcode0 = (Float32)Pow2(*sf0_gcode0_exp, *sf0_gcode0_fra);

			/*
			* calculate energy coefficients for quantization
			* and store them in state structure (will be used
			* in next subframe when real quantizer is run)
			*/
			calc_filt_energies(mode, xn, xn2, y1, y2, gCoeff, sf0_coeff, &cod_gain
			);

			/* store optimum codebook gain */
			*gain_cod = cod_gain;
			*sf0_target_en = (Float32)Dotproduct40(xn, xn);

			/*
			* calculate optimum codebook gain and update
			* "unquantized" predictor
			*/
			MR475_update_unq_pred(past_qua_en_unq, gcode0, cod_gain);

			/* the real quantizer is not run here... */
		}
		else {
			/*
			* predict codebook gain (using "unquantized" predictor)
			* (note that code[] is unsharpened in MR475)
			*/
			gc_pred(past_qua_en_unq, mode, code, &exp, &frac, &en);

			/* calculate energy coefficients for quantization */
			calc_filt_energies(mode, xn, xn2, y1, y2, gCoeff, coeff, &cod_gain);
			en = (Float32)Dotproduct40(xn, xn);

			/* run real (4-dim) quantizer and update real gain predictor */
			**gain_idx_ptr = MR475_gain_quant(past_qua_en, *sf0_gcode0_exp, *sf0_gcode0_fra, sf0_coeff,
				*sf0_target_en, code, exp, frac, coeff, en, gp_limit, sf0_gain_pit,
				sf0_gain_cod, gain_pit, gain_cod);
		}
	}
	else {
		/*
		* predict codebook gain and quantize
		*  (also compute normalized CB innovation energy for MR795)
		*/
		gc_pred(past_qua_en, mode, code, &exp, &frac, &en);

		if (mode == MR122) {
			/*
			* Compute the innovative codebook gain.
			* The innovative codebook gain is given by
			* g = <xn2[], y2[]> / <y2[], y2[]>
			* where xn2[] is the target vector,
			* y2[] is the filtered innovative
			* codevector
			*/

			gcode0 = (Float32)Pow2(exp, frac);
			/* saturation at decoder */
			if (gcode0 > 2047.9375F) gcode0 = 2047.9375F;

			*gain_cod = (Float32)(Dotproduct40(xn2, y2) / (Dotproduct40(y2, y2) + 0.01F));

			if (*gain_cod < 0)
				*gain_cod = 0.0F;
			*(*anap)++ = q_gain_code(gcode0, gain_cod, &qua_ener_index);
		}
		else {
			/* calculate energy coefficients for quantization */
			calc_filt_energies(mode, xn, xn2, y1, y2, gCoeff, coeff, &cod_gain);

			if (mode == MR795) {
				MR795_gain_quant(prev_gc, onset, ltpg_mem, prev_alpha, res, exc,
					code, coeff, en, exp, frac, cod_gain, gp_limit, gain_pit,
					gain_cod, &qua_ener_index, anap);
			}
			else {

				*(*anap)++ = Qua_gain(mode, exp, frac, coeff, gp_limit, gain_pit,
					gain_cod, &qua_ener_index);
			}
		}

		/*
		* update table of past quantized energies
		*/
		for (i = 3; i > 0; i--) {
			past_qua_en[i] = past_qua_en[i - 1];
		}
		past_qua_en[0] = qua_ener_index;

	}
}


/*
* subframePostProc
*
*
* Parameters:
*    speech            I: Speech segment
*    i_subfr           I: Subframe number
*    gain_pit          I: Pitch gain
*    gain_code         I: Decoded innovation gain
*    a_q               I: A(z) quantized for the 4 subframes
*    synth             I: Local synthesis
*    xn                I: Target vector for pitch search
*    code              I: Fixed codebook exitation
*    y1                I: Filtered adaptive exitation
*    y2                I: Filtered fixed codebook excitation
*    mem_syn           B: memory of synthesis filter
*    mem_err           O: pointer to error signal
*    mem_w0            O: memory of weighting filter
*    exc               O: long term prediction residual
*    sharp             O: pitch sharpening value
*
* Function:
*    Subframe post processing
*
*    Memory update (all modes)
*    An update of the states of the synthesis and weighting filters is needed
*   in order to compute the target signal in the next subframe.
*   After the two gains are quantified, the excitation signal, u(n),
*   in the present subframe is found by:
*
*   u(n) = Gp_q * v(n) + Gc_q * c(n), n = 0, ..., 39,
*
*   where Gp_q and Gc_q are the quantified adaptive and fixed codebook gains,
*   respectively, v(n) the adaptive codebook vector
*   (interpolated past excitation), and c(n) is the fixed codebook vector
*   (algebraic code including pitch sharpening). The states of the filters
*   can be updated by filtering the signal res_lp(n) - u(n)
*   (difference between residual and excitation) through the filters
*   1 / A_q(z) and A(z/g1) / A(z/g2) for the 40-sample subframe and saving
*   the states of the filters. This would require 3 filterings.
*   A simpler approach which requires only one filtering is as follows.
*   The local synthesized speech, S_s(n), is computed by filtering
*   the excitation signal through 1 / A_q(z). The output of the filter
*   due to the input res_lp(n) - u(n) is equivalent to e(n) = S(n) - S_s(n).
*   So the states of the synthesis filter 1 / A_q(z) are given by
*   e(n), n = 30, ..., 39. Updating the states of the filter A(z/g1) / A(z/g2)
*   can be done by filtering the error signal e(n) through this filter
*   to find the perceptually weighted error ew(n). However, the signal ew(n)
*   can be equivalently found by:
*
*   ew(n) = x(n) - Gp_q * y(n) - Gc_q(n) * z(n)
*
*   Since the signals x(n), y(n) and z(n) are available, the states of
*   the weighting filter are updated by computing ew(n) for n = 30, ..., 39.
*   This saves two filterings.
*
* Returns:
*    void
*/
__device__ static void subframePostProc(Float32 *speech, Word16 i_subfr, Float32 gain_pit,
	Float32 gain_code, Float32 *a_q, Float32 synth[], Float32 xn[], Float32
	code[], Float32 y1[], Float32 y2[], Float32 *mem_syn, Float32 *mem_err,
	Float32 *mem_w0, Float32 *exc, Float32 *sharp)
{
	Word32 i, j;


	/*
	* Update pitch sharpening "sharp" with quantized gain_pit
	*/
	*sharp = gain_pit;
	if (*sharp > 0.794556F) {
		*sharp = 0.794556F;
	}

	/* Find the total excitation */
	for (i = 0; i < L_SUBFR; i += 4) {
		exc[i + i_subfr] = (Float32)floor((gain_pit * exc[i + i_subfr] + gain_code * code[i]) + 0.5F);
		exc[i + i_subfr + 1] = (Float32)floor((gain_pit * exc[i + i_subfr + 1] + gain_code * code[i
			+ 1]) + 0.5F);
		exc[i + i_subfr + 2] = (Float32)floor((gain_pit * exc[i + i_subfr + 2] + gain_code * code[
			i + 2]) + 0.5F);
		exc[i + i_subfr + 3] = (Float32)floor((gain_pit * exc[i + i_subfr + 3] + gain_code * code[
			i + 3]) + 0.5F);
	}


	/* The local synthesis speech */
	Syn_filt(a_q, &exc[i_subfr], &synth[i_subfr], mem_syn, 1);

	for (i = L_SUBFR - M, j = 0; i < L_SUBFR; i++, j++) {
		/* e(n) = S(n) - S_s(n) */
		mem_err[j] = speech[i_subfr + i] - synth[i_subfr + i];

		/* ew(n) = x(n) - Gp_q * y(n) - Gc_q(n) * z(n) */
		mem_w0[j] = xn[i] - y1[i] * gain_pit - y2[i] * gain_code;
	}
}


/*
* Convolve
*
*
* Parameters:
*    x                 I: First input
*    h                 I: second input
*    y                 O: output
*
* Function:
*    Convolution
*
* Returns:
*    void
*/
__device__ static void Convolve(Float32 x[], Float32 h[], Float32 y[])
{
	Word32 i, n;
	Float32 s;


	for (n = 0; n < L_SUBFR; n++) {
		s = 0.0F;

		for (i = 0; i <= n; i++) {
			s += x[i] * h[n - i];
		}
		y[n] = s;
	}
	return;
}


/*
* tx_dtx_handler
*
*
* Parameters:
*    vad_flag             I:vad decision
*    decAnaElapsedCount   B: state machine that synch with the GSMEFR txDtx machine
*    dtxHangoverCount     B: dtx hangover counter
*    used_mode            O: used mode
*
* Function:
*    Adds extra speech hangover to analyze speech on the decoding side
*
* Returns:
*    compute_new_sid_possible
*/
__device__ static Word16 tx_dtx_handler(Word16 vad_flag, Word16 *decAnaElapsedCount,
	Word16 *dtxHangoverCount, enum Mode *used_mode)
{
	Word16 compute_new_sid_possible;


	/* this state machine is in synch with the GSMEFR txDtx machine */
	*decAnaElapsedCount += 1;
	compute_new_sid_possible = 0;

	if (vad_flag != 0) {
		*dtxHangoverCount = DTX_HANG_CONST;
	}

	/* non-speech */
	else {
		/* out of decoder analysis hangover */
		if (*dtxHangoverCount == 0) {
			*decAnaElapsedCount = 0;
			*used_mode = MRDTX;
			compute_new_sid_possible = 1;
		}

		/* in possible analysis hangover */
		else {
			*dtxHangoverCount -= 1;

			/* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
			if ((*decAnaElapsedCount + *dtxHangoverCount) <
				DTX_ELAPSED_FRAMES_THRESH) {
				*used_mode = MRDTX;

				/* if short time since decoder update, do not add extra HO */
			}

			/*
			* else
			* override VAD and stay in
			* speech mode *used_mode
			* and add extra hangover
			*/
		}
	}
	return compute_new_sid_possible;
}


/*
* dtx_buffer
*
*
* Parameters:
*    hist_ptr       B: Circular buffer pointer
*    lsp_hist       O: LSP history
*    lsp_new        I: LSP vector
*    speech         I: input speech
*    log_en_hist    O: frame energy
*
* Function:
*    Handles the DTX buffer
*
*    The frame energy is computed for each frame marked with VAD=0
*    according to the equation:
*
*                                       N-1
*    en_log(i) = 0.5 * log2 ( (1 / N) * SUM[ s(n) * s(n) ] )
*                                       N=0
*
*    where s(n) is the HP-filtered input speech signal of
*    the current frame i.
*
* Returns:
*    void
*/
__device__ static void dtx_buffer(Word16 *hist_ptr, Float32 *lsp_hist, Float32 lsp_new[],
	Float32 speech[], Float32 *log_en_hist)
{
	Float64 frame_en;


	/* update pointer to circular buffer */
	*hist_ptr += 1;

	if (*hist_ptr == DTX_HIST_SIZE) {
		*hist_ptr = 0;
	}

	/* copy lsp vector into buffer */
	memcpy(&lsp_hist[*hist_ptr * M], lsp_new, sizeof(Float32)*M);

	/* compute log energy based on frame energy */
	frame_en = Dotproduct40(speech, speech);
	frame_en += Dotproduct40(&speech[40], &speech[40]);
	frame_en += Dotproduct40(&speech[80], &speech[80]);
	frame_en += Dotproduct40(&speech[120], &speech[120]);

	if (frame_en > 1) {
		log_en_hist[*hist_ptr] = (Float32)(log10(frame_en * 0.00625F)*
			1.660964F);
	}
	else {
		log_en_hist[*hist_ptr] = -3.660965F;
	}
}


/*
* dtx_enc
*
*
* Parameters:
*    log_en_index      O: logarithmic energy quantized
*    log_en_hist       I: history of logarithmic energy
*    lsp_hist          I: history of LSP
*    lsp_index         O: quantization indices of 3 LSP vectors
*    init_lsf_vq_index O: init index for MA prediction
*    compute_sid_flag  I: SID flag
*    past_rq           I: past quantized residual
*    past_qua_en       O: gain predictor memory
*    anap              O: analysis parameters
*
* Function:
*    DTX encoder
*
*    The averaged logarithmic energy is computed by:
*
*                          7
*    en_log_mean(i) = (1 / 8) * SUM[ en_log(i - n) ]
*                         n=0
*
*    The averaged logarithmic energy is quantized means of a 6 bit
*    algorithmic quantizer. The 6 bits for the energy index are
*    transmitted in the SID frame.
*
* Returns:
*    void
*/
__device__ static Word32 dtx_enc(Word16 *log_en_index, Float32 log_en_hist[], Float32
	lsp_hist[], Word16 *lsp_index, Word32 *init_lsf_vq_index, Word16
	compute_sid_flag, Float32 past_rq[], Word32 *past_qua_en, Word16 **anap)
{
	Float32 log_en, lsf[M], lsp[M], lsp_q[M];
	Word32 i, j;


	/* VOX mode computation of SID parameters */
	if ((compute_sid_flag != 0)) {
		/*
		* compute new SID frame if safe i.e don't
		* compute immediately after a talk spurt
		*/
		log_en = 0;
		memset(lsp, 0, sizeof(Float32)*M);

		/* average energy and lsp */
		for (i = 0; i < DTX_HIST_SIZE; i++) {
			log_en += log_en_hist[i];

			for (j = 0; j < M; j++) {
				lsp[j] += lsp_hist[i * M + j];
			}
		}
		log_en = log_en * 0.125F;

		for (j = 0; j < M; j++) {
			/* divide by 8 */
			lsp[j] = lsp[j] * 0.125F;
		}

		/*  quantize logarithmic energy to 6 bits */
		log_en = log_en + 2.5F;
		*log_en_index = (Word16)((log_en * 4) + 0.5F);   /* 6 bits */

														 /* *log_en_index = ( Word16 )( ( log_en + 2.5F + 0.125F ) * 4.0F ); */
		if (*log_en_index > 63) {
			*log_en_index = 63;
		}

		if (*log_en_index < 0) {
			*log_en_index = 0;
		}

		if (*log_en_index > 46) {
			past_qua_en[0] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + 46;
			past_qua_en[1] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + 46;
			past_qua_en[2] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + 46;
			past_qua_en[3] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + 46;
		}
		else {
			past_qua_en[0] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + *log_en_index;
			past_qua_en[1] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + *log_en_index;
			past_qua_en[2] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + *log_en_index;
			past_qua_en[3] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + (MR475_VQ_SIZE * 2) + *log_en_index;
		}

		/* make sure that LSP's are ordered */
		Lsp_lsf(lsp, lsf);
		Reorder_lsf(lsf, 0.00625F);
		Lsf_lsp(lsf, lsp);

		/* Quantize lsp and put on parameter list */
		Q_plsf_3(MRDTX, past_rq, lsp, lsp_q, lsp_index, init_lsf_vq_index);
	}

	/* 3 bits */
	*(*anap)++ = (Word16)*init_lsf_vq_index;

	/* 8 bits */
	*(*anap)++ = lsp_index[0];

	/* 9 bits */
	*(*anap)++ = lsp_index[1];

	/* 9 bits */
	*(*anap)++ = lsp_index[2];

	/* 6 bits */
	*(*anap)++ = *log_en_index;

	/* = 35 bits */
	return 0;
}


/*
* complex_estimate_adapt
*
*
* Parameters:
*    st->best_corr_hp  I: complex background detector
*    st->corr_hp_fast  B: long term complex signal estimate
*    low_power         I: very low level flag of the input frame
*
* Function:
*    Update/adapt of complex signal estimate
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void complex_estimate_adapt(vadState *st, Word16 low_power)
{
	Float32 alpha;


	/* adapt speed on own state */
	/* decrease */
	if (st->best_corr_hp < st->corr_hp_fast) {
		/* low state */
		if (st->corr_hp_fast < CVAD_THRESH_ADAPT_HIGH) {
			alpha = CVAD_ADAPT_FAST;
		}

		/* high state */
		else {
			alpha = CVAD_ADAPT_REALLY_FAST;
		}
	}

	/* increase */
	else {
		if (st->corr_hp_fast < CVAD_THRESH_ADAPT_HIGH) {
			alpha = CVAD_ADAPT_FAST;
		}
		else {
			alpha = CVAD_ADAPT_SLOW;
		}
	}
	st->corr_hp_fast = st->corr_hp_fast - alpha * st->corr_hp_fast + alpha * st->
		best_corr_hp;

	if (st->corr_hp_fast < CVAD_MIN_CORR) {
		st->corr_hp_fast = CVAD_MIN_CORR;
	}

	if (low_power != 0) {
		st->corr_hp_fast = CVAD_MIN_CORR;
	}
}
#endif

/*
* complex_vad
*
*
* Parameters:
*    st->complex_high        B: 1 if (corr_hp_fast > CVAD_THRESH_ADAPT_HIGH)
*    st->complex_low         B: 1 if (corr_hp_fast > CVAD_THRESH_ADAPT_LOW)
*    low_power               I: flag power of the input frame
*    st->best_corr_hp        I: complex background detector
*    st->corr_hp_fast        B: long term complex signal estimate
*    st->complex_hang_timer  B: complex hang timer
*
*
* Function:
*    Complex background decision
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static Word32 complex_vad(vadState *st, Word16 low_power)
{
	st->complex_high = st->complex_high >> 1;
	st->complex_low = st->complex_low >> 1;

	if (low_power == 0) {
		if (st->corr_hp_fast > CVAD_THRESH_ADAPT_HIGH) {
			st->complex_high = st->complex_high | 0x00004000;
		}

		if (st->corr_hp_fast > CVAD_THRESH_ADAPT_LOW) {
			st->complex_low = st->complex_low | 0x00004000;
		}
	}

	if (st->corr_hp_fast > CVAD_THRESH_HANG) {
		st->complex_hang_timer += 1;
	}
	else {
		st->complex_hang_timer = 0;
	}
	return(Word16)(((st->complex_high & 0x00007f80) == 0x00007f80) || ((
		st->complex_low & 0x00007fff) == 0x00007fff));
}
#endif

/*
* complex_vad
*
*
* Parameters:
*    st->complex_warning  I: flags for complex detection
*    st->stat_count       B: stationary counter
*    st->pitch            I: flags for pitch detection
*    st->tone             I: flags indicating presence of a tone
*    st->vadreg           I: intermediate VAD flags
*    level                I: sub-band levels of the input frame
*    st->ave_level        B: Average amplitude estimate
*
* Function:
*    Control update of the background noise estimate
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void update_cntrl(vadState *st, Float32 level[])
{
	Float32 stat_rat, num, denom;
	Float32 alpha;
	Word32 i;


	/*
	* handle highband complex signal input  separately
	* if ther has been highband correlation for some time
	* make sure that the VAD update speed is low for a while
	*/
	if (st->complex_warning != 0) {
		if (st->stat_count < CAD_MIN_STAT_COUNT) {
			st->stat_count = CAD_MIN_STAT_COUNT;
		}
	}

	/*
	* NB stat_count is allowed to be decreased by one below again
	* deadlock in speech is not possible unless the signal is very
	* complex and need a high rate
	* if fullband pitch or tone have been detected for a while, initialize stat_count
	*/
	if (((st->pitch & 0x6000) == 0x6000) || ((st->tone & 0x00007c00) ==
		0x7c00)) {
		st->stat_count = STAT_COUNT;
	}
	else {
		/* if 8 last vad-decisions have been "0", reinitialize stat_count */
		if ((st->vadreg & 0x7f80) == 0) {
			st->stat_count = STAT_COUNT;
		}
		else {
			stat_rat = 0;

			for (i = 0; i < COMPLEN; i++) {
				if (level[i] > st->ave_level[i]) {
					num = level[i];
					denom = st->ave_level[i];
				}
				else {
					num = st->ave_level[i];
					denom = level[i];
				}

				/* Limit nimimum value of num and denom to STAT_THR_LEVEL */
				if (num < STAT_THR_LEVEL) {
					num = STAT_THR_LEVEL;
				}

				if (denom < STAT_THR_LEVEL) {
					denom = STAT_THR_LEVEL;
				}
				stat_rat += num / denom * 64;
			}

			/* compare stat_rat with a threshold and update stat_count */
			if (stat_rat > STAT_THR) {
				st->stat_count = STAT_COUNT;
			}
			else {
				if ((st->vadreg & 0x4000) != 0) {
					if (st->stat_count != 0) {
						st->stat_count -= 1;
					}
				}
			}
		}
	}

	/* Update average amplitude estimate for stationarity estimation */
	alpha = ALPHA4;

	if (st->stat_count == STAT_COUNT) {
		alpha = 1.0F;
	}
	else if ((st->vadreg & 0x4000) == 0) {
		alpha = ALPHA5;
	}

	for (i = 0; i < COMPLEN; i++) {
		st->ave_level[i] += alpha * (level[i] - st->ave_level[i]);
	}
}
#endif

/*
* noise_estimate_update
*
*
* Parameters:
*    st                      B: State struct
*    level                   I: sub-band levels of the input frame
*    st->vadreg              I: intermediate VAD flags
*    st->pitch               I: flags for pitch detection
*    st->complex_hang_count  I: signal is too complex for VAD
*    st->stat_count          B: stationary counter
*    st->old_level           B: signal levels of the previous frame
*    st->bckr_est            B: noise estimate
*
* Function:
*    Update of background noise estimate
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void noise_estimate_update(vadState *st, Float32 level[])
{
	Float32 alpha_up, alpha_down, bckr_add;
	Word32 i;


	/* Control update of bckr_est[] */
	update_cntrl(st, level);

	/* Choose update speed */
	bckr_add = 2;

	if (((0x7800 & st->vadreg) == 0) && ((st->pitch & 0x7800) == 0) && (
		st->complex_hang_count == 0)) {
		alpha_up = ALPHA_UP1;
		alpha_down = ALPHA_DOWN1;
	}
	else {
		if ((st->stat_count == 0) && (st->complex_hang_count == 0)) {
			alpha_up = ALPHA_UP2;
			alpha_down = ALPHA_DOWN2;
		}
		else {
			alpha_up = 0;
			alpha_down = ALPHA3;
			bckr_add = 0;
		}
	}

	/* Update noise estimate (bckr_est) */
	for (i = 0; i < COMPLEN; i++) {
		Float32 temp;


		temp = st->old_level[i] - st->bckr_est[i];

		/* update downwards*/
		if (temp < 0) {
			st->bckr_est[i] = (-2 + (st->bckr_est[i] + (alpha_down * temp)));

			/* limit minimum value of the noise estimate to NOISE_MIN */
			if (st->bckr_est[i] < NOISE_MIN) {
				st->bckr_est[i] = NOISE_MIN;
			}
		}

		/* update upwards */
		else {
			st->bckr_est[i] = (bckr_add + (st->bckr_est[i] + (alpha_up * temp)
				));

			/* limit maximum value of the noise estimate to NOISE_MAX */
			if (st->bckr_est[i] > NOISE_MAX) {
				st->bckr_est[i] = NOISE_MAX;
			}
		}
	}

	/* Update signal levels of the previous frame (old_level) */
	for (i = 0; i < COMPLEN; i++) {
		st->old_level[i] = level[i];
	}
}
#endif

/*
* hangover_addition
*
*
* Parameters:
*    noise_level             I: average level of the noise estimates
*    low_power               I: flag power of the input frame
*    st->burst_count         O: counter for the length of speech bursts
*    st->hang_count          O: hangover counter
*    st->complex_hang_count  B: signal is too complex for VAD
*    st->complex_hang_timer  B: complex hang timer
*    st->vadreg              I: intermediate VAD flags
*    st->corr_hp_fast        I: long term complex signal estimate
*
* Function:
*    Add hangover for complex signal or after speech bursts
*
* Returns:
*    VAD_flag indicating final VAD decision
*/
#ifndef VAD2
__device__ static Word16 hangover_addition(vadState *st, Float32 noise_level, Word16
	low_power)
{
	Word16 hang_len, burst_len;


	/*
	* Calculate burst_len and hang_len
	* burst_len: number of consecutive intermediate vad flags with "1"-decision
	* required for hangover addition
	* hang_len:  length of the hangover
	*/
	if (noise_level > HANG_NOISE_THR) {
		burst_len = BURST_LEN_HIGH_NOISE;
		hang_len = HANG_LEN_HIGH_NOISE;
	}
	else {
		burst_len = BURST_LEN_LOW_NOISE;
		hang_len = HANG_LEN_LOW_NOISE;
	}

	/*
	* if the input power (pow_sum) is lower than a threshold, clear
	* counters and set VAD_flag to "0"  "fast exit"
	*/
	if (low_power != 0) {
		st->burst_count = 0;
		st->hang_count = 0;
		st->complex_hang_count = 0;
		st->complex_hang_timer = 0;
		return 0;
	}

	if (st->complex_hang_timer > CVAD_HANG_LIMIT) {
		if (st->complex_hang_count < CVAD_HANG_LENGTH) {
			st->complex_hang_count = CVAD_HANG_LENGTH;
		}
	}

	/* long time very complex signal override VAD output function */
	if (st->complex_hang_count != 0) {
		st->burst_count = BURST_LEN_HIGH_NOISE;
		st->complex_hang_count -= 1;
		return 1;
	}
	else {
		/* let hp_corr work in from a noise_period indicated by the VAD */
		if (((st->vadreg & 0x3ff0) == 0) && (st->corr_hp_fast >
			CVAD_THRESH_IN_NOISE)) {
			return 1;
		}
	}

	/* update the counters (hang_count, burst_count) */
	if ((st->vadreg & 0x4000) != 0) {
		st->burst_count += 1;

		if (st->burst_count >= burst_len) {
			st->hang_count = hang_len;
		}
		return 1;
	}
	else {
		st->burst_count = 0;

		if (st->hang_count > 0) {
			st->hang_count -= 1;
			return 1;
		}
	}
	return 0;
}
#endif

/*
* vad_decision
*
*
* Parameters:
*    st                      B: State struct
*    level                   I: sub-band levels of the input frame
*    pow_sum                 I: power of the input frame
*    st->bckr_est            I: background noise components
*    st->vadreg              I: intermediate VAD flags
*    st->complex_warning     O: flags for complex detection
*    st->speech_vad_decision O: speech VAD flag
*
* Function:
*    Calculates VAD_flag
*
* Returns:
*    VAD_flag indicating final VAD decision
*/
#ifndef VAD2
__device__ static Word16 vad_decision(vadState *st, Float32 level[COMPLEN], Float32
	pow_sum)
{
	Float32 snr_sum, temp, vad_thr, noise_level;
	Word32 i;
	Word16 low_power_flag;


	/*
	* Calculate squared sum of the input levels (level)
	* divided by the background noise components (bckr_est).
	*/
	snr_sum = 0;

	for (i = 0; i < COMPLEN; i++) {
		temp = level[i] / st->bckr_est[i];
		snr_sum += temp * temp;
	}
	snr_sum = snr_sum * 56.8889F;

	/* Calculate average level of estimated background noise */
	noise_level = st->bckr_est[0] + st->bckr_est[1] + st->bckr_est[2] + st->
		bckr_est[3] + st->bckr_est[4] + st->bckr_est[5] + st->bckr_est[6] + st
		->bckr_est[7] + st->bckr_est[8];
	noise_level = noise_level * 0.111111F;

	/* Calculate VAD threshold */
	vad_thr = VAD_SLOPE * (noise_level - VAD_P1) + VAD_THR_HIGH;

	if (vad_thr < VAD_THR_LOW) {
		vad_thr = VAD_THR_LOW;
	}

	/* Shift VAD decision register */
	st->vadreg >>= 1;

	/* Make intermediate VAD decision */
	if (snr_sum > vad_thr) {
		st->vadreg = st->vadreg | 0x4000;
	}

	/*
	* primary vad decision made
	* check if the input power (pow_sum) is lower than a threshold"
	*/
	if (pow_sum < VAD_POW_LOW) {
		low_power_flag = 1;
	}
	else {
		low_power_flag = 0;
	}

	/*
	* update complex signal estimate st->corr_hp_fast and hangover reset timer using
	* low_power_flag and corr_hp_fast and various adaptation speeds
	*/
	complex_estimate_adapt(st, low_power_flag);

	/* check multiple thresholds of the st->corr_hp_fast value */
	st->complex_warning = complex_vad(st, low_power_flag);

	/* Update speech subband vad background noise estimates */
	noise_estimate_update(st, level);

	/*
	*  Add speech and complex hangover and return speech VAD_flag
	*  long term complex hangover may be added
	*/
	st->speech_vad_decision = hangover_addition(st, noise_level, low_power_flag
	);
	return(st->speech_vad_decision);
}
#endif

/*
* level_calculation
*
*
* Parameters:
*    data              I: signal buffer
*    sub_level         B: level calculate at the end of the previous frame/
*                         level of signal calculated from the last
*                         (count2 - count1) samples
*    count1            I: number of samples to be counted
*    count2            I: number of samples to be counted
*    ind_m             I: step size for the index of the data buffer
*    ind_a             I: starting index of the data buffer
*    scale             I: scaling for the level calculation
*
* Function:
*    Calculate signal level in a sub-band.
*
*    Level is calculated by summing absolute values of the input data.
*
* Returns:
*    signal level
*/
#ifndef VAD2
__device__ static Float32 level_calculation(Float32 data[], Float32 *sub_level, Word16
	count1, Word16 count2, Word16 ind_m, Word16 ind_a, Word16 scale)
{
	Float32 level, temp1;
	Word32 i;


	temp1 = 0;

	for (i = count1; i < count2; i++) {
		temp1 += (Float32)fabs(data[ind_m * i + ind_a]);
	}
	level = temp1 + *sub_level;
	*sub_level = temp1;

	for (i = 0; i < count1; i++) {
		level += (Float32)fabs(data[ind_m * i + ind_a]);
	}
	return(scale * level);
}
#endif

/*
* filter3
*
*
* Parameters:
*    in0               B: input values; output low-pass part
*    in1               B: input values; output high-pass part
*    data              B: updated filter memory
*
* Function:
*    Third-order half-band lowpass/highpass filter pair.
*
* Returns:
*   void
*/
#ifndef VAD2
__device__ static void filter3(Float32 *in0, Float32 *in1, Float32 *data)
{
	Float32 temp1, temp2;


	temp1 = *in1 - (COEFF3 * *data);
	temp2 = *data + (COEFF3 * temp1);
	*data = temp1;
	*in1 = (*in0 - temp2) * 0.5F;
	*in0 = (*in0 + temp2) * 0.5F;
}
#endif

/*
* filter5
*
*
* Parameters:
*    in0               B: input values; output low-pass part
*    in1               B: input values; output high-pass part
*    data              B: updated filter memory
*
* Function:
*    Fifth-order half-band lowpass/highpass filter pair.
*
* Returns:
*   void
*/
#ifndef VAD2
__device__ static void filter5(Float32 *in0, Float32 *in1, Float32 data[])
{
	Float32 temp0, temp1, temp2;


	temp0 = *in0 - (COEFF5_1 * data[0]);
	temp1 = data[0] + (COEFF5_1 * temp0);
	data[0] = temp0;
	temp0 = *in1 - (COEFF5_2 * data[1]);
	temp2 = data[1] + (COEFF5_2 * temp0);
	data[1] = temp0;
	*in0 = (temp1 + temp2) * 0.5F;
	*in1 = (temp1 - temp2) * 0.5F;
}
#endif

/*
* first_filter_stage
*
*
* Parameters:
*    in                I: input signal
*    out               O: output values,
*                         every other output is low-pass part and
*                         every other output is high-pass part
*    data              B: updated filter memory
*
* Function:
*    Calculate 5th order half-band lowpass/highpass filter pair
*
* Returns:
*   void
*/
#ifndef VAD2
__device__ static void first_filter_stage(Float32 in[], Float32 out[], Float32 data[])
{
	Float32 temp0, temp1, temp2, temp3;
	Float32 data0, data1;
	Word32 i;


	data0 = data[0];
	data1 = data[1];

	for (i = 0; i < L_SUBFR; i++) {
		temp0 = (in[4 * i + 0] * 0.25F) - (COEFF5_1 * data0);
		temp1 = data0 + (COEFF5_1 * temp0);
		temp3 = (in[4 * i + 1] * 0.25F) - (COEFF5_2 * data1);
		temp2 = data1 + (COEFF5_2 * temp3);
		out[4 * i + 0] = temp1 + temp2;
		out[4 * i + 1] = temp1 - temp2;
		data0 = (in[4 * i + 2] * 0.25F) - (COEFF5_1 * temp0);
		temp1 = temp0 + (COEFF5_1 * data0);
		data1 = (in[4 * i + 3] * 0.25F) - (COEFF5_2 * temp3);
		temp2 = temp3 + (COEFF5_2 * data1);
		out[4 * i + 2] = temp1 + temp2;
		out[4 * i + 3] = temp1 - temp2;
	}
	data[0] = data0;
	data[1] = data1;
}
#endif

/*
* filter_bank
*
*
* Parameters:
*    in                I: input frame
*    st->a_data5       B: filter memory
*    st->a_data3       B: filter memory
*    st->sub_level     B: level memory
*    level             O: signal levels at each band
*
* Function:
*    Divides input signal into 9-bands and calcultes level of the signal in each band
*
* Returns:
*    void
*/
#ifndef VAD2
__device__ static void filter_bank(vadState *st, Float32 in[], Float32 level[])
{
	Word32 i;
	Float32 tmp_buf[FRAME_LEN];


	/* calculate the filter bank */
	first_filter_stage(in, tmp_buf, st->a_data5[0]);

	for (i = 0; i < FRAME_LEN / 4; i++) {
		filter5(&tmp_buf[4 * i], &tmp_buf[4 * i + 2], st->a_data5[1]);
		filter5(&tmp_buf[4 * i + 1], &tmp_buf[4 * i + 3], st->a_data5[2]);
	}

	for (i = 0; i < FRAME_LEN / 8; i++) {
		filter3(&tmp_buf[8 * i + 0], &tmp_buf[8 * i + 4], &st->a_data3[0]);
		filter3(&tmp_buf[8 * i + 2], &tmp_buf[8 * i + 6], &st->a_data3[1]);
		filter3(&tmp_buf[8 * i + 3], &tmp_buf[8 * i + 7], &st->a_data3[4]);
	}

	for (i = 0; i < FRAME_LEN / 16; i++) {
		filter3(&tmp_buf[16 * i + 0], &tmp_buf[16 * i + 8], &st->a_data3[2]);
		filter3(&tmp_buf[16 * i + 4], &tmp_buf[16 * i + 12], &st->a_data3[3]);
	}

	/* calculate levels in each frequency band */
	/* 3000 - 4000 Hz*/
	level[8] = level_calculation(tmp_buf, &st->sub_level[8], FRAME_LEN / 4 - 8,
		FRAME_LEN / 4, 4, 1, 1);

	/* 2500 - 3000 Hz*/
	level[7] = level_calculation(tmp_buf, &st->sub_level[7], FRAME_LEN / 8 - 4,
		FRAME_LEN / 8, 8, 7, 2);

	/* 2000 - 2500 Hz*/
	level[6] = level_calculation(tmp_buf, &st->sub_level[6], FRAME_LEN / 8 - 4,
		FRAME_LEN / 8, 8, 3, 2);

	/* 1500 - 2000 Hz*/
	level[5] = level_calculation(tmp_buf, &st->sub_level[5], FRAME_LEN / 8 - 4,
		FRAME_LEN / 8, 8, 2, 2);

	/* 1000 - 1500 Hz*/
	level[4] = level_calculation(tmp_buf, &st->sub_level[4], FRAME_LEN / 8 - 4,
		FRAME_LEN / 8, 8, 6, 2);

	/* 750 - 1000 Hz*/
	level[3] = level_calculation(tmp_buf, &st->sub_level[3], FRAME_LEN / 16 - 2,
		FRAME_LEN / 16, 16, 4, 2);

	/* 500 - 750 Hz*/
	level[2] = level_calculation(tmp_buf, &st->sub_level[2], FRAME_LEN / 16 - 2,
		FRAME_LEN / 16, 16, 12, 2);

	/* 250 - 500 Hz*/
	level[1] = level_calculation(tmp_buf, &st->sub_level[1], FRAME_LEN / 16 - 2,
		FRAME_LEN / 16, 16, 8, 2);

	/* 0 - 250 Hz*/
	level[0] = level_calculation(tmp_buf, &st->sub_level[0], FRAME_LEN / 16 - 2,
		FRAME_LEN / 16, 16, 0, 2);
}
#endif

/*
* vad
*
*
* Parameters:
*    in_buf            I: samples of the input frame
*    st                B: State struct
*    st->pitch         B: flags for pitch detection
*    st->complex_low   B: complex flag
*
* Function:
*    Voice Activity Detection (VAD)
*
* Returns:
*    VAD Decision, 1 = speech, 0 = noise
*/
#ifndef VAD2
__device__ static Word16 vad(vadState *st, Float32 in_buf[])
{
	Float32 level[COMPLEN];
	Float32 pow_sum;
	Word32 i;


	/* Calculate power of the input frame. */
	pow_sum = 0L;

	for (i = -40; i < 120; i += 8) {
		pow_sum += in_buf[i] * in_buf[i];
		pow_sum += in_buf[i + 1] * in_buf[i + 1];
		pow_sum += in_buf[i + 2] * in_buf[i + 2];
		pow_sum += in_buf[i + 3] * in_buf[i + 3];
		pow_sum += in_buf[i + 4] * in_buf[i + 4];
		pow_sum += in_buf[i + 5] * in_buf[i + 5];
		pow_sum += in_buf[i + 6] * in_buf[i + 6];
		pow_sum += in_buf[i + 7] * in_buf[i + 7];
	}

	/*
	* If input power is very low, clear pitch flag of the current frame
	*/
	if (pow_sum < POW_PITCH_THR) {
		st->pitch = (Word16)(st->pitch & 0x3fff);
	}

	/*
	* If input power is very low, clear complex flag of the "current" frame
	*/
	if (pow_sum < POW_COMPLEX_THR) {
		st->complex_low = (Word16)(st->complex_low & 0x3fff);
	}

	/*
	* Run the filter bank which calculates signal levels at each band
	*/
	filter_bank(st, in_buf, level);
	return(vad_decision(st, level, pow_sum));
}
#endif

/*
* vad_pitch_detection
*
*
* Parameters:
*    st->oldlag        B: old LTP lag
*    T_op              I: speech encoder open loop lags
*    st->pitch         B: flags for pitch detection
*    st                B: State struct
*    st->pitch         B: flags for pitch detection
*    st->oldlag_count  B: lag count
*
* Function:
*    Test if signal contains pitch or other periodic component.
*
* Returns:
*    Boolean voiced / unvoiced decision in state variable
*/
#ifndef VAD2
__device__ static void vad_pitch_detection(vadState *st, Word32 T_op[])
{
	Word32 lagcount, i;


	lagcount = 0;

	for (i = 0; i < 2; i++) {
		if (abs(st->oldlag - T_op[i]) < LTHRESH) {
			lagcount += 1;
		}

		/* Save the current LTP lag */
		st->oldlag = T_op[i];
	}

	/*
	* Make pitch decision.
	* Save flag of the pitch detection to the variable pitch.
	*/
	st->pitch = st->pitch >> 1;

	if ((st->oldlag_count + lagcount) >= NTHRESH) {
		st->pitch = st->pitch | 0x4000;
	}

	/* Update oldlagcount */
	st->oldlag_count = lagcount;
}
#endif


#ifdef VAD2

/***************************************************************************
*
*   FUNCTION NAME: vad2()
*
*   PURPOSE:
*     This function provides the Voice Activity Detection function option 2
*     for the Adaptive Multi-rate (AMR) codec.
*
*   INPUTS:
*
*     vadState
*                     pointer to vadState state structure
*     farray_ptr
*                     pointer to Float32[80] input array
*
*   OUTPUTS:
*
*     state variables in vadState are updated
*
*   RETURN VALUE:
*
*     Word16
*                     VAD(m) - two successive calls to vad2() yield
*                     the VAD decision for the 20 ms frame:
*                     VAD_flag = VAD(m-1) || VAD(m)
*
*
*************************************************************************/

int		vad2(vadState *st, Float32 *farray_ptr)
{

	/* Static variables */

	/* The channel table is defined below.  In this table, the
	lower and higher frequency coefficients for each of the 16
	channels are specified.  The table excludes the coefficients
	with numbers 0 (DC), 1, and 64 (Foldover frequency).  For
	these coefficients, the gain is always set at 1.0 (0 dB). */

	static int	ch_tbl[NUM_CHAN][2] = {

		{ 2,  3 },
		{ 4,  5 },
		{ 6,  7 },
		{ 8,  9 },
		{ 10, 11 },
		{ 12, 13 },
		{ 14, 16 },
		{ 17, 19 },
		{ 20, 22 },
		{ 23, 26 },
		{ 27, 30 },
		{ 31, 35 },
		{ 36, 41 },
		{ 42, 48 },
		{ 49, 55 },
		{ 56, 63 }

	};

	/* The voice metric table is defined below.  It is a non-
	linear table with a deadband near zero.  It maps the SNR
	index (quantized SNR value) to a number that is a measure
	of voice quality. */

	static int	vm_tbl[90] = {
		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
		3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7,
		8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15,
		15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 24,
		24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34,
		35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45,
		46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50,
		50, 50
	};

	/* hangover as a function of peak SNR (3 dB steps) */
	static Word16 hangover_table[20] =
	{
		30, 30, 30, 30, 30, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 8, 8, 8
	};

	/* burst sensitivity as a function of peak SNR (3 dB steps) */
	static Word16 burstcount_table[20] =
	{
		8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4
	};

	/* voice metric sensitivity as a function of peak SNR (3 dB steps) */
	static Word16 vm_threshold_table[20] =
	{
		34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 40, 51, 71, 100, 139, 191, 257, 337, 432
	};


	/* Automatic variables */

	float		data_buffer[FFT_LEN1], enrg, snr;
	float		tne, tce, ftmp;
	int		ch_snr[NUM_CHAN];
	int		i, j, j1, j2;
	int		vm_sum;
	int		update_flag;

	float		ch_enrg_dev;		/* for forced update... */
	float		ch_enrg_db[NUM_CHAN];
	float		alpha;


	/* For detecting sine waves */
	float		peak, avg, peak2avg;
	int		sine_wave_flag;

	/* For computing frame SNR and long-term SNR */
	float		tce_db, tne_db;
	float		xt;

	/* More VAD stuff */
	int	tsnrq;
	int	ivad;


	/* Functions */

	void real_fft(float *, int);


	/****** Executable code starts here ******/

	/* Increment frame counter */
	st->Lframe_cnt++;

	/* Preemphasize the input data and store in the data buffer with
	appropriate delay */

	for (i = 0; i < DELAY0; i++)
		data_buffer[i] = 0.0;

	data_buffer[DELAY0] = *farray_ptr + PRE_EMP_FAC1 * st->pre_emp_mem;

	for (i = DELAY0 + 1, j = 1; i < DELAY0 + FRM_LEN1; i++, j++)
		data_buffer[i] = *(farray_ptr + j) + PRE_EMP_FAC1 *
		*(farray_ptr + j - 1);

	st->pre_emp_mem = *(farray_ptr + FRM_LEN1 - 1);

	for (i = DELAY0 + FRM_LEN1; i < FFT_LEN1; i++)
		data_buffer[i] = 0.0;

	/* Perform FFT on the data buffer */
	real_fft(data_buffer, +1);

	/* Estimate the energy in each channel */
	alpha = (st->Lframe_cnt == 1) ? 1.0 : CEE_SM_FAC1;
	for (i = LO_CHAN; i <= HI_CHAN; i++)
	{
		enrg = 0.0;
		j1 = ch_tbl[i][0], j2 = ch_tbl[i][1];
		for (j = j1; j <= j2; j++)
			enrg += square(data_buffer[2 * j]) + square(data_buffer[2 * j + 1]);
		enrg /= (float)(j2 - j1 + 1);
		st->ch_enrg[i] = (1 - alpha) * st->ch_enrg[i] + alpha * enrg;
		if (st->ch_enrg[i] < MIN_CHAN_ENRG) st->ch_enrg[i] = MIN_CHAN_ENRG;
	}

	/* Compute the total channel energy estimate (tce) */
	tce = 0.0;
	for (i = LO_CHAN; i <= HI_CHAN; i++)
		tce += st->ch_enrg[i];

	/* Calculate spectral peak-to-average ratio */
	peak = avg = 0.;
	for (i = LO_CHAN; i <= HI_CHAN; i++) {
		/* Sine waves not valid for low frequencies: */
		if (i >= SINE_START_CHAN && st->ch_enrg[i] > peak)
			peak = st->ch_enrg[i];
		avg += st->ch_enrg[i];
	}
	avg /= HI_CHAN - LO_CHAN + 1;
	peak2avg = (avg < 1. / NORM_ENRG) ? 0. : 10.*log10(peak / avg);

	/* Detect sine waves */
	if (peak2avg > 10.)
		sine_wave_flag = TRUE;
	else
		sine_wave_flag = FALSE;

	/* Initialize channel noise estimate to channel energy of first few frames
	(if sufficiently low Peak-to-Average ratio) */
	if (st->Lframe_cnt <= INIT_FRAMES) {
		if (sine_wave_flag == TRUE) {
			for (i = LO_CHAN; i <= HI_CHAN; i++)
				st->ch_noise[i] = INE;
		}
		else {
			for (i = LO_CHAN; i <= HI_CHAN; i++)
				st->ch_noise[i] = max(st->ch_enrg[i], INE);
		}
	}

	/* Compute the channel SNR indices */
	for (i = LO_CHAN; i <= HI_CHAN; i++) {
		snr = 10.0 * log10((double)st->ch_enrg[i] / st->ch_noise[i]);
		if (snr < 0.0) snr = 0.0;
		ch_snr[i] = (snr + 0.1875) / 0.375;
	}

	/* Compute the sum of voice metrics */
	vm_sum = 0;
	for (i = LO_CHAN; i <= HI_CHAN; i++) {
		j = min(ch_snr[i], 89);
		vm_sum += vm_tbl[j];
	}

	/* Initialize voice energy to nominal value */
	if (st->Lframe_cnt <= INIT_FRAMES || st->fupdate_flag == TRUE) {
#if NORM_ENERG==4
		tce_db = 49.918;
#elif NORM_ENERG==1
		tce_db = 55.938;
#else
		tce_db = (96. - 22. - 10 * log10(FFT_LEN1 / 2) - 10.*log10(NORM_ENRG));
#endif

		st->negSNRvar = 0.0;
		st->negSNRbias = 0.0;

		/* Compute the total noise energy estimate (tne) */
		tne = 0.0;
		for (i = LO_CHAN; i <= HI_CHAN; i++)
			tne += st->ch_noise[i];

		/* Get total noise in dB */
		tne_db = 10 * log10(tne);

		/* Initialise instantaneous and long-term peak signal-to-noise ratios */
		xt = tce_db - tne_db;
		st->tsnr = xt;

	}
	else {

		/* Calculate instantaneous signal-to-noise ratio */
		xt = 0;
		for (i = LO_CHAN; i <= HI_CHAN; i++)
			xt += st->ch_enrg[i] / st->ch_noise[i];
		xt = 10 * log10(xt / NUM_CHAN);

		/* Estimate long-term "peak" SNR */
		if (xt > st->tsnr)
			st->tsnr = 0.9*st->tsnr + 0.1*xt;
		else if (xt > 0.625*st->tsnr)
			st->tsnr = 0.998*st->tsnr + 0.002*xt;
	}

	/* Quantize the long-term SNR in 3 dB steps */
	tsnrq = (int)(st->tsnr / 3.);
	tsnrq = min(19, max(0, tsnrq));

	/* Calculate the negative SNR sensitivity bias */
	if (xt < 0) {
		st->negSNRvar = min(0.99*st->negSNRvar + 0.01*xt*xt, 4.0);
		st->negSNRbias = max(12.0*(st->negSNRvar - 0.65), 0.0);
	}

	/* Determine VAD as a function of the voice metric sum and quantized SNR */
	if (vm_sum > vm_threshold_table[tsnrq] + st->negSNRbias) {
		ivad = 1;
		if (++st->burstcount > burstcount_table[tsnrq]) {
			st->hangover = hangover_table[tsnrq];
		}
	}
	else {
		st->burstcount = 0;
		if (--st->hangover <= 0) {
			ivad = 0;
			st->hangover = 0;
		}
		else {
			ivad = 1;
		}
	}

	/* Calculate log spectral deviation */
	for (i = LO_CHAN; i <= HI_CHAN; i++)
		ch_enrg_db[i] = 10.*log10(st->ch_enrg[i]);

	ch_enrg_dev = 0.;
	if (st->Lframe_cnt == 1)
		for (i = LO_CHAN; i <= HI_CHAN; i++)
			st->ch_enrg_long_db[i] = ch_enrg_db[i];
	else
		for (i = LO_CHAN; i <= HI_CHAN; i++)
			ch_enrg_dev += fabs(st->ch_enrg_long_db[i] - ch_enrg_db[i]);


	/*
	* Calculate long term integration constant as a function of instantaneous SNR
	* (i.e., high SNR (tsnr dB) -> slower integration (alpha = HIGH_ALPHA),
	*         low SNR (0 dB) -> faster integration (alpha = LOW_ALPHA)
	*/

	/* alpha = HIGH_ALPHA - ALPHA_RANGE * (tsnr - xt) / tsnr, low <= alpha <= high */
	ftmp = st->tsnr - xt;
	if (ftmp <= 0.0 || st->tsnr <= 0.0)
		alpha = HIGH_ALPHA1;
	else if (ftmp > st->tsnr)
		alpha = LOW_ALPHA1;
	else
		alpha = HIGH_ALPHA1 - (ALPHA_RANGE1 * ftmp / st->tsnr);

	/* Calc long term log spectral energy */
	for (i = LO_CHAN; i <= HI_CHAN; i++) {
		st->ch_enrg_long_db[i] = alpha*st->ch_enrg_long_db[i] + (1. - alpha)*ch_enrg_db[i];
	}

	/* Set or reset the update flag */
	update_flag = FALSE;
	st->fupdate_flag = FALSE;
	if ((vm_sum <= UPDATE_THLD) ||
		(st->Lframe_cnt <= INIT_FRAMES && sine_wave_flag == FALSE)) {
		update_flag = TRUE;
		st->update_cnt = 0;
	}
	else if (tce > NOISE_FLOOR && ch_enrg_dev < DEV_THLD1 &&
		sine_wave_flag == FALSE && st->LTP_flag == FALSE) {
		st->update_cnt++;
		if (st->update_cnt >= UPDATE_CNT_THLD1) {
			update_flag = TRUE;
			st->fupdate_flag = TRUE;
		}
	}

	if (st->update_cnt == st->last_update_cnt)
		st->hyster_cnt++;
	else
		st->hyster_cnt = 0;
	st->last_update_cnt = st->update_cnt;

	if (st->hyster_cnt > HYSTER_CNT_THLD1)
		st->update_cnt = 0;

	/* Update the channel noise estimates */
	if (update_flag == TRUE) {
		for (i = LO_CHAN; i <= HI_CHAN; i++) {
			st->ch_noise[i] = (1.0 - CNE_SM_FAC1) * st->ch_noise[i] +
				CNE_SM_FAC1 * st->ch_enrg[i];
			if (st->ch_noise[i] < MIN_CHAN_ENRG) st->ch_noise[i] = MIN_CHAN_ENRG;
		}
	}

	return (ivad);

}		/* end vad2 () */


		/**************************************************************************
		*
		*   FUNCTION NAME: real_fft()
		*
		*   PURPOSE: FFT/IFFT function for real sequences
		*
		**************************************************************************
		*
		* This is an implementation of decimation-in-time FFT algorithm for
		* real sequences.  The techniques used here can be found in several
		* books, e.g., i) Proakis and Manolakis, "Digital Signal Processing",
		* 2nd Edition, Chapter 9, and ii) W.H. Press et. al., "Numerical
		* Recipes in C", 2nd Ediiton, Chapter 12.
		*
		* Input -  There is two inputs to this function:
		*
		*	1) A float pointer to the input data array,
		*	2) A control parameter (isign) specifying forward (+1) or
		*         inverse (-1) FFT.
		*
		* Output - There is no return value.
		*	The input data are replaced with transformed data.  If the
		*	input is a real time domain sequence, it is replaced with
		*	the complex FFT for positive frequencies.  The FFT value
		*	for DC and the foldover frequency are combined to form the
		*	first complex number in the array.  The remaining complex
		*	numbers correspond to increasing frequencies.  If the input
		*	is a complex frequency domain sequence arranged	as above,
		*	it is replaced with the corresponding time domain sequence.
		*
		* Notes:
		*
		*	1) This function is designed to be a part of a VAD
		*	   algorithm that requires 128-point FFT of real
		*	   sequences.  This is achieved here through a 64-point
		*	   complex FFT.  Consequently, the FFT size information is
		*	   not transmitted explicitly.  However, some flexibility
		*	   is provided in the function to change the size of the
		*	   FFT by specifying the size information through "define"
		*	   statements.
		*
		*	2) The values of the complex sinusoids used in the FFT
		*	   algorithm are stored in a ROM table.
		*
		*	3) In the c_fft function, the FFT values are divided by
		*	   2 after each stage of computation thus dividing the
		*	   final FFT values by 64.  This is somewhat different
		*         from the usual definition of FFT where the factor 1/N,
		*         i.e., 1/64, used for the IFFT and not the FFT.  No factor
		*         is used in the r_fft function.
		*
		*************************************************************************/

static double	phs_tbl[SIZE];		/* holds the complex sinusoids */

void		real_fft(float *farray_ptr, int isign)
{

	float		ftmp1_real, ftmp1_imag, ftmp2_real, ftmp2_imag;
	int		i, j;
	static int	first = TRUE;

	void		cmplx_fft(float *, int);
	void		fill_tbl();

	/* If this is the first call to the function, fill up the
	phase table  */
	if (first == TRUE) {
		fill_tbl();
		first = FALSE;
	}

	/* The FFT part */
	if (isign == 1) {

		/* Perform the complex FFT */
		cmplx_fft(farray_ptr, isign);

		/* First, handle the DC and foldover frequencies */
		ftmp1_real = *farray_ptr;
		ftmp2_real = *(farray_ptr + 1);
		*farray_ptr = ftmp1_real + ftmp2_real;
		*(farray_ptr + 1) = ftmp1_real - ftmp2_real;

		/* Now, handle the remaining positive frequencies */
		for (i = 2, j = SIZE - i; i <= SIZE_BY_TWO; i = i + 2, j = SIZE - i) {

			ftmp1_real = *(farray_ptr + i) + *(farray_ptr + j);
			ftmp1_imag = *(farray_ptr + i + 1) - *(farray_ptr + j + 1);
			ftmp2_real = *(farray_ptr + i + 1) + *(farray_ptr + j + 1);
			ftmp2_imag = *(farray_ptr + j) - *(farray_ptr + i);

			*(farray_ptr + i) = (ftmp1_real + phs_tbl[i] * ftmp2_real -
				phs_tbl[i + 1] * ftmp2_imag) / 2.0;
			*(farray_ptr + i + 1) = (ftmp1_imag + phs_tbl[i] * ftmp2_imag +
				phs_tbl[i + 1] * ftmp2_real) / 2.0;
			*(farray_ptr + j) = (ftmp1_real + phs_tbl[j] * ftmp2_real +
				phs_tbl[j + 1] * ftmp2_imag) / 2.0;
			*(farray_ptr + j + 1) = (-ftmp1_imag - phs_tbl[j] * ftmp2_imag +
				phs_tbl[j + 1] * ftmp2_real) / 2.0;
		}
	}

	/* The IFFT part */
	else {

		/* First, handle the DC and foldover frequencies */

		ftmp1_real = *farray_ptr;
		ftmp2_real = *(farray_ptr + 1);
		*farray_ptr = (ftmp1_real + ftmp2_real) / 2.0;
		*(farray_ptr + 1) = (ftmp1_real - ftmp2_real) / 2.0;

		/* Now, handle the remaining positive frequencies */

		for (i = 2, j = SIZE - i; i <= SIZE_BY_TWO; i = i + 2, j = SIZE - i) {

			ftmp1_real = *(farray_ptr + i) + *(farray_ptr + j);
			ftmp1_imag = *(farray_ptr + i + 1) - *(farray_ptr + j + 1);
			ftmp2_real = -(*(farray_ptr + i + 1) + *(farray_ptr + j + 1));
			ftmp2_imag = -(*(farray_ptr + j) - *(farray_ptr + i));

			*(farray_ptr + i) = (ftmp1_real + phs_tbl[i] * ftmp2_real +
				phs_tbl[i + 1] * ftmp2_imag) / 2.0;
			*(farray_ptr + i + 1) = (ftmp1_imag + phs_tbl[i] * ftmp2_imag -
				phs_tbl[i + 1] * ftmp2_real) / 2.0;
			*(farray_ptr + j) = (ftmp1_real + phs_tbl[j] * ftmp2_real -
				phs_tbl[j + 1] * ftmp2_imag) / 2.0;
			*(farray_ptr + j + 1) = (-ftmp1_imag - phs_tbl[j] * ftmp2_imag -
				phs_tbl[j + 1] * ftmp2_real) / 2.0;
		}

		/* Perform the complex IFFT */
		cmplx_fft(farray_ptr, isign);
	}

	return;
}		/* end real_fft () */



		/*
		* FFT/IFFT function for complex sequences
		*
		* The decimation-in-time complex FFT/IFFT is implemented below.
		* The input complex numbers are presented as real part followed by
		* imaginary part for each sample.  The counters are therefore
		* incremented by two to access the complex valued samples.
		*/
void		cmplx_fft(float *farray_ptr, int isign)
{
	int		i, j, k, ii, jj, kk, ji, kj;
	float		ftmp, ftmp_real, ftmp_imag;

	/* Rearrange the input array in bit reversed order */
	for (i = 0, j = 0; i < SIZE - 2; i = i + 2) {
		if (j > i) {
			ftmp = *(farray_ptr + i);
			*(farray_ptr + i) = *(farray_ptr + j);
			*(farray_ptr + j) = ftmp;

			ftmp = *(farray_ptr + i + 1);
			*(farray_ptr + i + 1) = *(farray_ptr + j + 1);
			*(farray_ptr + j + 1) = ftmp;
		}
		k = SIZE_BY_TWO;
		while (j >= k) {
			j -= k;
			k >>= 1;
		}
		j += k;
	}

	/* The FFT part */
	if (isign == 1) {
		for (i = 0; i < NUM_STAGE; i++) {		/* i is stage counter */
			jj = (2 << i);				/* FFT size */
			kk = (jj << 1);				/* 2 * FFT size */
			ii = SIZE / jj;				/* 2 * number of FFT's */
			for (j = 0; j < jj; j = j + 2) {		/* j is sample counter */
				ji = j * ii;				/* ji is phase table index */
				for (k = j; k < SIZE; k = k + kk) {	/* k is butterfly top */
					kj = k + jj;				/* kj is butterfly bottom */

												/* Butterfly computations */
					ftmp_real = *(farray_ptr + kj) * phs_tbl[ji] -
						*(farray_ptr + kj + 1) * phs_tbl[ji + 1];

					ftmp_imag = *(farray_ptr + kj + 1) * phs_tbl[ji] +
						*(farray_ptr + kj) * phs_tbl[ji + 1];

					*(farray_ptr + kj) = (*(farray_ptr + k) - ftmp_real) / 2.0;
					*(farray_ptr + kj + 1) = (*(farray_ptr + k + 1) - ftmp_imag) / 2.0;

					*(farray_ptr + k) = (*(farray_ptr + k) + ftmp_real) / 2.0;
					*(farray_ptr + k + 1) = (*(farray_ptr + k + 1) + ftmp_imag) / 2.0;
				}
			}
		}
	}

	/* The IFFT part */
	else {
		for (i = 0; i < NUM_STAGE; i++) {		/* i is stage counter */
			jj = (2 << i);				/* FFT size */
			kk = (jj << 1);				/* 2 * FFT size */
			ii = SIZE / jj;				/* 2 * number of FFT's */
			for (j = 0; j < jj; j = j + 2) {		/* j is sample counter */
				ji = j * ii;				/* ji is phase table index */
				for (k = j; k < SIZE; k = k + kk) {	/* k is butterfly top */
					kj = k + jj;				/* kj is butterfly bottom */

												/* Butterfly computations */
					ftmp_real = *(farray_ptr + kj) * phs_tbl[ji] +
						*(farray_ptr + kj + 1) * phs_tbl[ji + 1];

					ftmp_imag = *(farray_ptr + kj + 1) * phs_tbl[ji] -
						*(farray_ptr + kj) * phs_tbl[ji + 1];

					*(farray_ptr + kj) = *(farray_ptr + k) - ftmp_real;
					*(farray_ptr + kj + 1) = *(farray_ptr + k + 1) - ftmp_imag;

					*(farray_ptr + k) = *(farray_ptr + k) + ftmp_real;
					*(farray_ptr + k + 1) = *(farray_ptr + k + 1) + ftmp_imag;
				}
			}
		}
	}
	return;
}		/* end of cmplx_fft () */


		/* Function to fill the phase table values
		*/

void		fill_tbl()
{
	int		i;
	double	delta_f, theta;

	delta_f = -PI / (double)SIZE_BY_TWO;
	for (i = 0; i < SIZE_BY_TWO; i++) {
		theta = delta_f * (double)i;
		phs_tbl[2 * i] = cos(theta);
		phs_tbl[2 * i + 1] = sin(theta);
	}
	return;
}		/* end fill_tbl () */


		/***************************************************************************
		*
		*   FUNCTION NAME: LTP_flag_update
		*
		*   PURPOSE:
		*     Set LTP_flag if the LTP gain > LTP_THRESHOLD, where the value of
		*     LTP_THRESHOLD depends on the LTP analysis window length.
		*
		*   INPUTS:
		*
		*     mode
		*                     AMR mode
		*     vadState->R0
		*                     LTP energy
		*     vadState->Rmax
		*                     LTP maximum autocorrelation
		*   OUTPUTS:
		*
		*     vadState->LTP_flag
		*                     Set if LTP gain > LTP_THRESHOLD
		*
		*   RETURN VALUE:
		*
		*     none
		*
		*************************************************************************/

void LTP_flag_update(vadState * st, Word16 mode)
{
	Float32 thresh;

	if ((mode == MR475) || (mode == MR515))
		thresh = 0.55;
	else if (mode == MR102)
		thresh = 0.60;
	else
		thresh = 0.65;

	if (st->Rmax  > thresh*st->R0)
		st->LTP_flag = TRUE;
	else
		st->LTP_flag = FALSE;

	return;
}

/***************************************************************************/
#endif

/*
* cod_amr
*
*
* Parameters:
*    st          B: state structure
*    mode        I: encoder mode
*    new_speech  I: input speech frame, size L_FRAME
*    st          B: State struct
*    ana         O: Analysis parameters
*    used_mode   B: In: -1 forces VAD on, Out:used encoder mode
*    synth       O: local synthesis, size L_FRAME
*
* Function:
*    GSM adaptive multi rate speech encoder
*
* Returns:
*    void
*/
__device__ static void cod_amr(cod_amrState *st, enum Mode mode, Float32 new_speech[],
	Word16 ana[], enum Mode *used_mode, Float32 synth[])
{
	/* LPC coefficients */
	Float32 A_t[(MP1) * 4];   /* A(z) unquantized for the 4 subframes */
	Float32 Aq_t[(MP1) * 4];   /* A(z)   quantized for the 4 subframes */
	Float32 *A, *Aq;   /* Pointer on Aq_t */
	Float32 lsp_new[M];


	/* Other vectors */
	Float32 xn[L_SUBFR];   /* Target vector for pitch search */
	Float32 xn2[L_SUBFR];   /* Target vector for codebook search */
	Float32 code[L_SUBFR];   /* Fixed codebook excitation */
	Float32 y1[L_SUBFR];   /* Filtered adaptive excitation */
	Float32 y2[L_SUBFR];   /* Filtered fixed codebook excitation */
	Float32 gCoeff[3];   /* Correlations between xn, y1, & y2: */
	Float32 res[L_SUBFR];   /* Short term (LPC) prediction residual */
	Float32 res2[L_SUBFR];   /* Long term (LTP) prediction residual */


							 /* Vector and scalars needed for the MR475 */
	Float32 xn_sf0[L_SUBFR];   /* Target vector for pitch search */
	Float32 y2_sf0[L_SUBFR];   /* Filtered codebook innovation */
	Float32 code_sf0[L_SUBFR];   /* Fixed codebook excitation */
	Float32 h1_sf0[L_SUBFR];   /* The impulse response of sf0 */
	Float32 mem_syn_save[M];   /* Filter memory */
	Float32 mem_w0_save[M];   /* Filter memory */
	Float32 mem_err_save[M];   /* Filter memory */
	Float32 sharp_save = 0.0;   /* Sharpening */
	Float32 gain_pit_sf0 = 0.0;   /* Quantized pitch gain for sf0 */
	Float32 gain_code_sf0 = 0.0;   /* Quantized codebook gain for sf0 */
	Word16 i_subfr_sf0 = 0;   /* Position in exc[] for sf0 */


							  /* Scalars & Flags */
	Float32 gain_pit, gain_code;
	Float32 gp_limit;   /* pitch gain limit value */
	Word32 T0_sf0 = 0;   /* Integer pitch lag of sf0 */
	Word32 T0_frac_sf0 = 0;   /* Fractional pitch lag of sf0 */
	Word32 T0, T0_frac;
	Word32 T_op[2];
	Word32 evenSubfr;
	Word32 i;
	Word16 i_subfr, subfrNr;
	Word16 lsp_flag = 0;   /* indicates resonance in LPC filter */
	Word16 compute_sid_flag;
	Word16 vad_flag;

	Word16 *gain_idx_ptr = NULL;

	memcpy(&st->old_speech[st->new_speech], new_speech, L_FRAME << 2);

	if (st->dtx) {
#ifdef VAD2
		/* Find VAD decision (option 2) */
		vad_flag = vad2(&st->vadSt, &st->old_speech[st->new_speech]);
		vad_flag = vad2(&st->vadSt, &st->old_speech[st->new_speech + 80]) || vad_flag;
#else
		/* Find VAD decision (option 1) */
		vad_flag = vad(&st->vadSt, &st->old_speech[st->new_speech]);
#endif
		/* force VAD on   */
		if (*used_mode < 0)
			vad_flag = 1;
		*used_mode = mode;

		/* NB! used_mode may change here */
		compute_sid_flag = tx_dtx_handler(vad_flag, &st->dtxEncSt.
			decAnaElapsedCount, &st->dtxEncSt.dtxHangoverCount, used_mode);
	}
	else {
		compute_sid_flag = 0;
		*used_mode = mode;
	}

	/*
	* Perform LPC analysis:
	* Autocorrelation + Lag windowing.
	* Levinson-durbin algorithm to find a[].
	* Convert a[] to lsp[].
	* Quantize and code the LSPs.
	* find the interpolated LSPs and convert to a[] for all
	* subframes (both quantized and unquantized).
	*/
	/* LP analysis */
	lpc(st->lpcSt.LevinsonSt.old_A, &st->old_speech[st->p_window], &st->old_speech[st->p_window_12k2], A_t, mode
	);

	/*
	* The LP filter coefficients, are converted to
	* the line spectral pair (LSP) representation for
	* quantization and interpolation purposes.
	*/
	lsp(mode, *used_mode, st->lspSt.lsp_old, st->lspSt.lsp_old_q, st->lspSt.
		qSt.past_rq, A_t, Aq_t, lsp_new, &ana);

	/* Buffer lsp's and energy */
	dtx_buffer(&st->dtxEncSt.hist_ptr, st->dtxEncSt.lsp_hist, lsp_new, &st->old_speech[st->
		new_speech], st->dtxEncSt.log_en_hist);

	if (*used_mode == MRDTX) {
		dtx_enc(&st->dtxEncSt.log_en_index, st->dtxEncSt.log_en_hist, st->
			dtxEncSt.lsp_hist, st->dtxEncSt.lsp_index, &st->dtxEncSt.
			init_lsf_vq_index, compute_sid_flag, &st->lspSt.qSt.past_rq[0], st
			->gainQuantSt.gc_predSt.past_qua_en, &ana);
		memset(st->old_exc, 0, (PIT_MAX + L_INTERPOL) << 2);
		memset(st->mem_w0, 0, M << 2);
		memset(st->mem_err, 0, M << 2);
		memset(&st->ai_zero[st->zero], 0, L_SUBFR << 2);
		memset(st->hvec, 0, L_SUBFR << 2);
		memset(st->lspSt.qSt.past_rq, 0, M << 2);
		memcpy(st->lspSt.lsp_old, lsp_new, M << 2);
		memcpy(st->lspSt.lsp_old_q, lsp_new, M << 2);

		/* Reset clLtp states */
		st->clLtpSt.pitchSt.T0_prev_subframe = 0;
		st->sharp = 0;
	}
	else {
		/* check resonance in the filter */
		lsp_flag = check_lsp(&st->tonStabSt.count, st->lspSt.lsp_old);
	}

#ifdef VAD2
	if (st->dtx) {
		st->vadSt.Rmax = 0.0;
		st->vadSt.R0 = 0.0;
	}
#endif

	for (subfrNr = 0, i_subfr = 0; subfrNr < 2; subfrNr++, i_subfr +=
		L_FRAME_BY2) {
		/*
		* Pre-processing on 80 samples
		* Find the weighted input speech for the whole speech frame
		*/
		pre_big(mode, gamma1, gamma1_12k2, gamma2, A_t, i_subfr, &st->old_speech[st->speech], st->
			mem_w, &st->old_wsp[st->wsp]);

		/* Find open loop pitch lag for two subframes */
		if ((mode != MR475) && (mode != MR515)) {
			ol_ltp(mode, &st->vadSt, &st->old_wsp[st->wsp + i_subfr], &T_op[subfrNr], st->
				ol_gain_flg, &st->pitchOLWghtSt.old_T0_med, &st->pitchOLWghtSt.
				wght_flg, &st->pitchOLWghtSt.ada_w, st->old_lags, st->dtx,
				subfrNr);
		}
	}

	if ((mode == MR475) || (mode == MR515)) {
		/*
		* Find open loop pitch lag for ONE FRAME ONLY
		* search on 160 samples
		*/
		ol_ltp(mode, &st->vadSt, &st->old_wsp[st->wsp], &T_op[0], st->ol_gain_flg, &st->
			pitchOLWghtSt.old_T0_med, &st->pitchOLWghtSt.wght_flg, &st->
			pitchOLWghtSt.ada_w, st->old_lags, st->dtx, 1);
		T_op[1] = T_op[0];
	}

#ifdef VAD2
	if (st->dtx) {
		LTP_flag_update(&st->vadSt, mode);
	}
#endif

#ifndef VAD2
	if (st->dtx) {
		vad_pitch_detection(&st->vadSt, T_op);
	}
#endif

	if (*used_mode == MRDTX) {
		goto the_end;
	}

	/*
	* Loop for every subframe in the analysis frame
	*
	* To find the pitch and innovation parameters. The subframe size is
	* L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.
	*     - find the weighted LPC coefficients
	*     - find the LPC residual signal res[]
	*     - compute the target signal for pitch search
	*     - compute impulse response of weighted synthesis filter (h1[])
	*     - find the closed-loop pitch parameters
	*     - encode the pitch dealy
	*     - update the impulse response h1[] by including fixed-gain pitch
	*     - find target vector for codebook search
	*     - codebook search
	*     - encode codebook address
	*     - VQ of pitch and codebook gains
	*     - find synthesis speech
	*     - update states of weighting filter
	*/
	/* pointer to interpolated LPC parameters */
	A = A_t;

	/* pointer to interpolated quantized LPC parameters */
	Aq = Aq_t;
	evenSubfr = 0;
	subfrNr = -1;

	for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR) {
		subfrNr += 1;
		evenSubfr = 1 - evenSubfr;

		if ((evenSubfr != 0) && (*used_mode == MR475)) {
			memcpy(mem_syn_save, st->mem_syn, M << 2);
			memcpy(mem_w0_save, st->mem_w0, M << 2);
			memcpy(mem_err_save, st->mem_err, M << 2);
			sharp_save = st->sharp;
		}

		/* Preprocessing of subframe */
		if (*used_mode != MR475) {
			subframePreProc(*used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st->old_speech[st->
				speech + i_subfr], st->mem_err, st->mem_w0, &st->ai_zero[st->zero], st->ai_zero,
				&st->old_exc[st->exc + i_subfr], &st->hvec[st->h1], xn, res, &st->mem_err[st->error]);
		}

		/* MR475 */
		else {
			subframePreProc(*used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st->old_speech[st->
				speech + i_subfr], st->mem_err, mem_w0_save, &st->ai_zero[st->zero], st->ai_zero,
				&st->old_exc[st->exc + i_subfr], &st->hvec[st->h1], xn, res, &st->mem_err[st->error]);

			if (evenSubfr != 0) {
				memcpy(h1_sf0, &st->hvec[st->h1], L_SUBFR << 2);
			}
		}

		/* copy the LP residual (res2 is modified in the CL LTP search) */
		memcpy(res2, res, L_SUBFR << 2);

		/* Closed-loop LTP search */
		cl_ltp(&st->clLtpSt.pitchSt.T0_prev_subframe, st->tonStabSt.gp, *
			used_mode, i_subfr, T_op, &st->hvec[st->h1], &st->old_exc[st->exc + i_subfr], res2, xn,
			lsp_flag, xn2, y1, &T0, &T0_frac, &gain_pit, gCoeff, &ana, &gp_limit
		);

		/* update LTP lag history */
		if ((subfrNr == 0) && (st->ol_gain_flg[0] > 0)) {
			st->old_lags[1] = T0;
		}

		if ((subfrNr == 3) && (st->ol_gain_flg[1] > 0)) {
			st->old_lags[0] = T0;
		}

		/* Innovative codebook search (find index and gain) */
		cbsearch(*used_mode, subfrNr, xn2, &st->hvec[st->h1], T0, st->sharp, gain_pit, code,
			y2, res2, &ana);

		/* Quantization of gains. */
		gainQuant(*used_mode, evenSubfr, st->gainQuantSt.gc_predSt.past_qua_en,
			st->gainQuantSt.gc_predUncSt.past_qua_en, st->gainQuantSt.
			sf0_coeff, &st->gainQuantSt.sf0_target_en, &st->gainQuantSt.
			sf0_gcode0_exp, &st->gainQuantSt.
			sf0_gcode0_fra, &gain_idx_ptr, &gain_pit_sf0, &
			gain_code_sf0, res, &st->old_exc[st->exc + i_subfr], code, xn, xn2, y1, y2, gCoeff
			, gp_limit, &gain_pit, &gain_code, &st->gainQuantSt.adaptSt.
			prev_gc, &st->gainQuantSt.adaptSt.onset, st->gainQuantSt.adaptSt
			.ltpg_mem, &st->gainQuantSt.adaptSt.prev_alpha, &ana);

		/* update gain history */
		for (i = 0; i < N_FRAME - 1; i++) {
			st->tonStabSt.gp[i] = st->tonStabSt.gp[i + 1];
		}
		st->tonStabSt.gp[N_FRAME - 1] = gain_pit;

		/* Subframe Post Processing */
		if (*used_mode != MR475) {
			subframePostProc(&st->old_speech[st->speech], i_subfr, gain_pit, gain_code, Aq, synth,
				xn, code, y1, y2, st->mem_syn, st->mem_err, st->mem_w0, &st->old_exc[st->exc],
				&st->sharp);
		}
		else {
			if (evenSubfr != 0) {
				i_subfr_sf0 = i_subfr;
				memcpy(xn_sf0, xn, L_SUBFR << 2);
				memcpy(y2_sf0, y2, L_SUBFR << 2);
				memcpy(code_sf0, code, L_SUBFR << 2);
				T0_sf0 = T0;
				T0_frac_sf0 = T0_frac;

				/* Subframe Post Porcessing */
				subframePostProc(&st->old_speech[st->speech], i_subfr, gain_pit, gain_code, Aq,
					synth, xn, code, y1, y2, mem_syn_save, st->mem_err,
					mem_w0_save, &st->old_exc[st->exc], &st->sharp);
				st->sharp = sharp_save;
			}
			else {
				/*
				* update both subframes for the MR475
				* Restore states for the MR475 mode
				*/
				memcpy(st->mem_err, mem_err_save, M << 2);

				/* re-build excitation for sf 0 */
				Pred_lt_3or6(&st->old_exc[st->exc + i_subfr_sf0], T0_sf0, T0_frac_sf0, 1);
				Convolve(&st->old_exc[st->exc + i_subfr_sf0], h1_sf0, y1);
				Aq -= MP1;
				subframePostProc(&st->old_speech[st->speech], i_subfr_sf0, gain_pit_sf0,
					gain_code_sf0, Aq, synth, xn_sf0, code_sf0, y1, y2_sf0, st->
					mem_syn, st->mem_err, st->mem_w0, &st->old_exc[st->exc], &sharp_save);

				/* overwrites sharp_save */
				Aq += MP1;

				/*
				* re-run pre-processing to get xn right (needed by postproc)
				* (this also reconstructs the unsharpened h1 for sf 1)
				*/
				subframePreProc(*used_mode, gamma1, gamma1_12k2, gamma2, A, Aq, &st->old_speech[st->
					speech + i_subfr], st->mem_err, st->mem_w0, &st->ai_zero[st->zero], st->
					ai_zero, &st->old_exc[st->exc + i_subfr], &st->hvec[st->h1], xn, res, &st->mem_err[st->error]);

				/* re-build excitation sf 1 (changed if lag < L_SUBFR) */
				Pred_lt_3or6(&st->old_exc[st->exc + i_subfr], T0, T0_frac, 1);
				Convolve(&st->old_exc[st->exc + i_subfr], &st->hvec[st->h1], y1);
				subframePostProc(&st->old_speech[st->speech], i_subfr, gain_pit, gain_code, Aq,
					synth, xn, code, y1, y2, st->mem_syn, st->mem_err, st->mem_w0,
					&st->old_exc[st->exc], &st->sharp);
			}
		}

		/* interpolated LPC parameters for next subframe */
		A += MP1;
		Aq += MP1;
	}
the_end:

	/* Update signal for next frame. */
	for (i = 0; i < PIT_MAX; i++) {
		st->old_wsp[i] = st->old_wsp[L_FRAME + i];
	}

	for (i = 0; i < PIT_MAX + L_INTERPOL; i++) {
		st->old_exc[i] = st->old_exc[L_FRAME + i];
	}

	for (i = 0; i < L_TOTAL - L_FRAME; i++) {
		st->old_speech[i] = st->old_speech[L_FRAME + i];
	}
}


/*
* Pre_Process_reset
*
*
* Parameters:
*    state                O: state structure
*
* Function:
*    Initializes state memory to zero
*
* Returns:
*
*/
__device__ static Word32 Pre_Process_reset(Pre_ProcessState *state)
{
	state->y2 = 0;
	state->y1 = 0;
	state->x0 = 0;
	state->x1 = 0;
	return 0;
}




/*
* Pre_Process_init
*
*
* Parameters:
*    state             O: state structure
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    succeed = 0
*/
__device__ static Word32 Pre_Process_init(Pre_ProcessState *state)
{
	Pre_Process_reset(state);
	return 0;
}


/*
* Pre_Process
*
*
* Parameters:
*    y2, y1, x0, x1    B: filter memory
*    speech            I: speech vector to be processed
*    fspeech           O: processed vector
*    size              I: size of the vector
*
* Function:
*    Pre-processing
*
*    Two pre-processing functions are applied prior to
*    the encoding process: high-pass filtering and signal down-scaling.
*    Down-scaling consists of dividing the input by a factor of 2
*    to reduce the possibility of overflows in the fixed-point
*    implementation. The high-pass filter serves as a precaution
*    against undesired low frequency components. A filter with
*    a cut off frequency of 80 Hz is used, and it is given by:
*
*            0.927246093 - 1.8544941z^-1 + 0.927246903z^-2
*    H(z) = -----------------------------------------------
*                1 - 1.906005859z^-1 + 0.911376953z^-2
*
*    Down-scaling and high-pass filtering are combined by dividing
*    the coefficients at the numerator by 2.
*
* Returns:
*    void
*/
__device__ static void Pre_Process(Float32 *y2, Float32 *y1, Float32 *x0, Float32
	*x1, Word16 *speech, Float32 *f_speech)
{
	Word32 i;
	Float32 x2;
	Float32 tmp;


	for (i = 0; i < 160; i++) {
		x2 = *x1;
		*x1 = *x0;
		*x0 = speech[i];
		tmp = (Float32)(0.4636230465* *x0 - 0.92724705 * *x1 + 0.4636234515 *
			x2 + 1.906005859 * *y1 - 0.911376953 * *y2);
		f_speech[i] = tmp;
		*y2 = *y1;
		*y1 = tmp;
	}

	if ((fabs(*y1) + fabs(*y2)) < 0.0000000001)
		*y2 = *y1 = 0;
}


/*
* cod_amr_reset
*
*
* Parameters:
*    s                 B: state structure
*    dtx               I: dtx on/off
*
* Function:
*    Resets state memory
*
* Returns:
*    void
*/
__device__ static void cod_amr_reset(cod_amrState *s, Word32 dtx)
{
	Word32 i;


	/* reset DTX */
	s->dtx = dtx;

	/* reset Pitch_frState */
	s->clLtpSt.pitchSt.T0_prev_subframe = 0;

	/* reset Q_plsfState */
	memset(s->lspSt.qSt.past_rq, 0, sizeof(Float32)*M);
	memcpy(s->lspSt.lsp_old, lsp_init_data, sizeof(lsp_init_data));
	memcpy(s->lspSt.lsp_old_q, lsp_init_data, sizeof(lsp_init_data));

	/* reset gc_predState */
	for (i = 0; i < NPRED; i++) {
		s->gainQuantSt.gc_predSt.past_qua_en[i] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + MR475_VQ_SIZE * 2 + DTX_VQ_SIZE;
		s->gainQuantSt.gc_predUncSt.past_qua_en[i] = NB_QUA_CODE + VQ_SIZE_HIGHRATES + VQ_SIZE_LOWRATES + MR475_VQ_SIZE * 2 + DTX_VQ_SIZE;
	}

	/* reset gain_adaptState */
	s->gainQuantSt.adaptSt.onset = 0;
	s->gainQuantSt.adaptSt.prev_alpha = 0.0F;
	s->gainQuantSt.adaptSt.prev_gc = 0.0F;
	memset(s->gainQuantSt.adaptSt.ltpg_mem, 0, sizeof(Float32)*LTPG_MEM_SIZE);
	s->gainQuantSt.sf0_gcode0_exp = 0;
	s->gainQuantSt.sf0_gcode0_fra = 0;
	s->gainQuantSt.sf0_target_en = 0.0F;
	memset(s->gainQuantSt.sf0_coeff, 0, sizeof(Float32) * 5);

	/* reset pitchOLWghtState */
	s->pitchOLWghtSt.old_T0_med = 40;
	s->pitchOLWghtSt.ada_w = 0.0F;
	s->pitchOLWghtSt.wght_flg = 0;

	/* reset tonStabState */
	s->tonStabSt.count = 0;
	memset(s->tonStabSt.gp, 0, sizeof(Float32)*N_FRAME);

	/* reset LevinsonState */
	s->lpcSt.LevinsonSt.old_A[0] = 1.0F;
	memset(&s->lpcSt.LevinsonSt.old_A[1], 0, sizeof(Float32)*M);

#ifdef VAD2
	/* reset vadState */
	s->vadSt.pre_emp_mem = 0.0;
	s->vadSt.update_cnt = 0;
	s->vadSt.hyster_cnt = 0;
	s->vadSt.last_update_cnt = 0;
	for (i = 0; i < NUM_CHAN; i++) {
		s->vadSt.ch_enrg_long_db[i] = 0.0;
		s->vadSt.ch_enrg[i] = 0.0;
		s->vadSt.ch_noise[i] = 0.0;
	}
	s->vadSt.Lframe_cnt = 0L;
	s->vadSt.tsnr = 0.0;
	s->vadSt.hangover = 0;
	s->vadSt.burstcount = 0;
	s->vadSt.fupdate_flag = 0;
	s->vadSt.negSNRvar = 0.0;
	s->vadSt.negSNRbias = 0.0;
	s->vadSt.R0 = 0.0;
	s->vadSt.Rmax = 0.0;
	s->vadSt.LTP_flag = 0;
#else
	/* reset vadState */
	s->vadSt.oldlag_count = 0;
	s->vadSt.oldlag = 0;
	s->vadSt.pitch = 0;
	s->vadSt.tone = 0;
	s->vadSt.complex_high = 0;
	s->vadSt.complex_low = 0;
	s->vadSt.complex_hang_timer = 0;
	s->vadSt.vadreg = 0;
	s->vadSt.burst_count = 0;
	s->vadSt.hang_count = 0;
	s->vadSt.complex_hang_count = 0;

	/* initialize memory used by the filter bank */
	for (i = 0; i < 3; i++) {
		s->vadSt.a_data5[i][0] = 0;
		s->vadSt.a_data5[i][1] = 0;
	}

	for (i = 0; i < 5; i++) {
		s->vadSt.a_data3[i] = 0;
	}

	/* reset dtx_encState */
	/* initialize the rest of the memory */
	for (i = 0; i < COMPLEN; i++) {
		s->vadSt.bckr_est[i] = NOISE_INIT;
		s->vadSt.old_level[i] = NOISE_INIT;
		s->vadSt.ave_level[i] = NOISE_INIT;
		s->vadSt.sub_level[i] = 0;
	}
	s->vadSt.best_corr_hp = CVAD_LOWPOW_RESET;
	s->vadSt.speech_vad_decision = 0;
	s->vadSt.complex_warning = 0;
	s->vadSt.sp_burst_count = 0;
	s->vadSt.corr_hp_fast = CVAD_LOWPOW_RESET;
#endif

	s->dtxEncSt.hist_ptr = 0;
	s->dtxEncSt.log_en_index = 0;
	s->dtxEncSt.init_lsf_vq_index = 0;
	s->dtxEncSt.lsp_index[0] = 0;
	s->dtxEncSt.lsp_index[1] = 0;
	s->dtxEncSt.lsp_index[2] = 0;

	for (i = 0; i < DTX_HIST_SIZE; i++) {
		memcpy(&s->dtxEncSt.lsp_hist[i * M], lsp_init_data, sizeof(Float32)*M
		);
	}
	memset(s->dtxEncSt.log_en_hist, 0, M * sizeof(Float32));
	s->dtxEncSt.dtxHangoverCount = DTX_HANG_CONST;
	s->dtxEncSt.decAnaElapsedCount = DTX_ELAPSED_FRAMES_THRESH;

	/* init speech offsets */
	/* New speech */
	s->new_speech = L_TOTAL - L_FRAME;

	/* Present frame */
	s->speech = s->new_speech - L_NEXT;
	s->p_window = L_TOTAL - L_WINDOW;

	/* For LPC window				*/
	s->p_window_12k2 = s->p_window - L_NEXT;

	/* Initialize static offset */
	s->wsp = PIT_MAX;
	s->exc = PIT_MAX + L_INTERPOL;
	s->zero = MP1;
	s->error = M;
	s->h1 = L_SUBFR;

	/* Static vectors to zero */
	memset(s->old_speech, 0, sizeof(Float32)*L_TOTAL);
	memset(s->old_exc, 0, sizeof(Float32)*(PIT_MAX + L_INTERPOL));
	memset(s->old_wsp, 0, sizeof(Float32)*PIT_MAX);
	memset(s->mem_syn, 0, sizeof(Float32)*M);
	memset(s->mem_w, 0, sizeof(Float32)*M);
	memset(s->mem_w0, 0, sizeof(Float32)*M);
	memset(s->mem_err, 0, sizeof(Float32)*M);
	memset(s->ai_zero, 0, sizeof(Float32)*L_SUBFR);
	memset(s->hvec, 0, sizeof(Float32)*L_SUBFR);

	for (i = 0; i < 5; i++) {
		s->old_lags[i] = 40;
	}
	s->sharp = 0.0F;
}


/*
* cod_amr_init
*
*
* Parameters:
*    state             O: state structure
*    dtx               I: dtx mode used
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    succeed = 0
*/
__device__ static Word32 cod_amr_init(cod_amrState *state, Word32 dtx)
{
	cod_amr_reset(state, dtx);
	return 0;
}

/*
* Speech_Encode_Frame_init
*
*
* Parameters:
*    state             O: state structure
*    dtx               I: dtx mode used
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    succeed = 0
*/
__device__ void Speech_Encode_Frame_init(Speech_Encode_FrameState* state, int dtx)
{
	state->dtx = dtx;
	Pre_Process_init(&state->pre_state);
	cod_amr_init(&state->cod_amr_state, dtx);
}


/*
* Speech_Encode_Frame_reset
*
*
* Parameters:
*    state          O: state structure
*
* Function:
*    Resets state memory
*
* Returns:
*
*/
__device__ int Speech_Encode_Frame_reset(Speech_Encode_FrameState *state, int dtx)
{
	Pre_Process_reset(&state->pre_state);
	cod_amr_reset(&state->cod_amr_state, dtx);
	return 0;
}

/*
* Speech_Encode_Frame
*
*
* Parameters:
*    st                B: state structure
*    mode              I: speech coder mode
*    new_speech        I: speech input, size L_FRAME
*    prm               O: Analysis parameters
*    used_mode         B: force VAD/used_mode
* Function:
*    Encode one frame
*
* Returns:
*    Void
*/
__device__ void Speech_Encode_Frame(Speech_Encode_FrameState* state, enum Mode mode, Word16 *new_speech, Word16 *
	prm, enum Mode *used_mode)
{
	Float32 syn[L_FRAME];   /* Buffer for synthesis speech */
	Float32 speech[160];
	Word32 i;

	for (i = 0; i < 160; i++) {
		new_speech[i] = (Word16)(new_speech[i] & 0xfff8);
	}

	/* filter + downscaling */
	Pre_Process(&state->pre_state.y2, &state->pre_state.y1, &state->pre_state
		.x0, &state->pre_state.x1, new_speech, speech);

	/* Call the speech encoder */
	cod_amr(&state->cod_amr_state, mode, speech, prm, used_mode, syn);
}

//static short block_size[16] = { 12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0 };
__device__  static int EncoderMMS(enum Mode mode, Word16 *param, UWord8 *stream, enum
	TXFrameType frame_type, enum Mode speech_mode)
{
	Word32 j = 0, k;
	Word16 *mask;

	memset(stream, 0, block_size[mode]);

	*stream = toc_byte[mode];
	stream++;

	if (mode == 15) {
		return 1;
	}
	else if (mode == MRDTX) {
		mask = order_MRDTX;

		for (j = 1; j < 36; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}

		/* add SID type information */
		if (frame_type == TX_SID_UPDATE)
			*stream += 0x01;
		*stream <<= 3;

		/* speech mode indication */
		*stream += (unsigned char)(((speech_mode & 0x0001) << 2) | (speech_mode & 0x0002) | ((speech_mode & 0x0004) >> 2));

		*stream <<= 1;

		/* don't shift at the end of the function */
		return 6;
	}
	else if (mode == MR475) {
		mask = order_MR475;

		for (j = 1; j < 96; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR515) {
		mask = order_MR515;

		for (j = 1; j < 104; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR59) {
		mask = order_MR59;

		for (j = 1; j < 119; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR67) {
		mask = order_MR67;

		for (j = 1; j < 135; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR74) {
		mask = order_MR74;

		for (j = 1; j < 149; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR795) {
		mask = order_MR795;

		for (j = 1; j < 160; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR102) {
		mask = order_MR102;

		for (j = 1; j < 205; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}
	else if (mode == MR122) {
		mask = order_MR122;

		for (j = 1; j < 245; j++) {
			if (param[*mask] & *(mask + 1))
				*stream += 0x01;
			mask += 2;

			if (j % 8)
				*stream <<= 1;
			else
				stream++;
		}
	}

	/* shift remaining bits */
	k = j % 8;
	if (k) {
		*stream <<= (8 - k);
	}
	return((int)block_size[mode]);
}

/*
* Sid_Sync_reset
*
*
* Parameters:
*    st                O: state structure
*
* Function:
*    Initializes state memory
*
* Returns:
*    void
*/
__device__   static void Sid_Sync_reset(enc_interface_State *st)
{
	st->sid_update_counter = 3;
	st->sid_handover_debt = 0;
	st->prev_ft = TX_SPEECH_GOOD;
}


/*
* Encoder_Interface_Encode
*
*
* Parameters:
*    st                I: pointer to state structure
*    mode              I: Speech Mode
*    speech            I: Input speech
*    serial            O: Output octet structure 3GPP
*                         stream
*    force_speech      I: Force speech in DTX
*
* Function:
*    Encoding and packing one frame of speech
*
* Returns:
*    number of octets
*/
__device__ int Encoder_Interface_Encode(enc_interface_State* state, enum Mode mode, Word16 *speech,
	UWord8 *serial,
	int force_speech)
{
	Word16 prm[PRMNO_MR122];   /* speech parameters, max size */
	const Word16 *homing;   /* pointer to homing frame */
	Word16 homing_size;   /* frame size for homing frame */


	enum TXFrameType txFrameType;   /* frame type */

	int i, noHoming = 0;


	/*
	* used encoder mode,
	* if used_mode == -1, force VAD on
	*/
	enum Mode used_mode = (Mode)-force_speech;

	/*
	* Checks if all samples of the input frame matches the encoder
	* homing frame pattern, which is 0x0008 for all samples.
	*/
	for (i = 0; i < 160; i++) {
		noHoming = speech[i] ^ 0x0008;

		if (noHoming)
			break;
	}

	if (noHoming) {
		Speech_Encode_Frame(&state->encoderState, mode, speech, prm, &used_mode);
	}
	else {
		switch (mode) {
		case MR122:
			homing = dhf_MR122;
			homing_size = 18;
			break;

		case MR102:
			homing = dhf_MR102;
			homing_size = 12;
			break;

		case MR795:
			homing = dhf_MR795;
			homing_size = 8;
			break;

		case MR74:
			homing = dhf_MR74;
			homing_size = 7;
			break;

		case MR67:
			homing = dhf_MR67;
			homing_size = 7;
			break;

		case MR59:
			homing = dhf_MR59;
			homing_size = 7;
			break;

		case MR515:
			homing = dhf_MR515;
			homing_size = 7;
			break;

		case MR475:
			homing = dhf_MR475;
			homing_size = 7;
			break;

		default:
			homing = NULL;
			homing_size = 0;
			break;
		}
		for (i = 0; i < homing_size; i++) {
			prm[i] = homing[i];
		}
		/* rest of the parameters are zero */
		memset(&prm[homing_size], 0, (PRMNO_MR122 - homing_size) << 1);
		used_mode = mode;
	}
	if (used_mode == MRDTX) {
		state->sid_update_counter--;

		if (state->prev_ft == TX_SPEECH_GOOD) {
			txFrameType = TX_SID_FIRST;
			state->sid_update_counter = 3;
		}
		else {
			/* TX_SID_UPDATE or TX_NO_DATA */
			if ((state->sid_handover_debt > 0) && (state->sid_update_counter > 2)) {
				/*
				* ensure extra updates are properly delayed after
				* a possible SID_FIRST
				*/
				txFrameType = TX_SID_UPDATE;
				state->sid_handover_debt--;
			}
			else {
				if (state->sid_update_counter == 0) {
					txFrameType = TX_SID_UPDATE;
					state->sid_update_counter = 8;
				}
				else {
					txFrameType = TX_NO_DATA;
					used_mode = (Mode)15;
				}
			}
		}
	}
	else {
		state->sid_update_counter = 8;
		txFrameType = TX_SPEECH_GOOD;
	}
	state->prev_ft = txFrameType;

	if (noHoming == 0) {
		Speech_Encode_Frame_reset(&state->encoderState, state->dtx);
		Sid_Sync_reset(state);
	}

	return EncoderMMS(used_mode, prm, serial, txFrameType, mode);
}


/*
* Encoder_Interface_init
*
*
* Parameters:
*    state             I: pointer to state structure
*    dtx               I: DTX flag
*
* Function:
*    Allocates state memory and initializes state memory
*
* Returns:
*    pointer to encoder interface structure
*/
__device__ void Encoder_Interface_init(enc_interface_State* state, int dtx)
{
	Speech_Encode_Frame_init(&state->encoderState, dtx);
	Sid_Sync_reset(state);
	state->dtx = dtx;
	return;
}
